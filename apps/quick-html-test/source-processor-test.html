<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SourceProcessor Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .control-panel {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-bottom: 20px;
      }
      .slider-container {
        margin: 10px 0;
      }
      .slider-container label {
        display: inline-block;
        width: 150px;
      }
      .status {
        background-color: #f0f0f0;
        padding: 10px;
        border-radius: 5px;
        height: 200px;
        overflow: auto;
        margin-top: 20px;
      }
      button {
        padding: 8px 12px;
        margin-right: 5px;
        cursor: pointer;
      }
      canvas {
        width: 100%;
        height: 150px;
        background-color: #f8f8f8;
        border: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <h1>SourceProcessor Test</h1>

    <div class="button-panel">
      <button id="loadSound">Load Piano C4</button>
      <button id="playButton" disabled>Play</button>
      <button id="stopButton" disabled>Stop</button>
      <button id="enableLooping">Enable Looping</button>
      <button id="disableLooping">Disable Looping</button>
      <button id="streamPosition">Stream Position</button>
    </div>

    <div class="control-panel">
      <div>
        <h3>Playback Controls</h3>
        <div class="slider-container">
          <label for="startSlider">Start:</label>
          <input
            type="range"
            id="startSlider"
            min="0"
            max="0.5"
            step="0.005"
            value="0"
          />
          <span id="startValue">0.00 s</span>
        </div>

        <div class="slider-container">
          <label for="endSlider">End:</label>
          <input
            type="range"
            id="endSlider"
            min="0"
            max="0.5"
            step="0.005"
            value="0.5"
          />
          <span id="endValue">0.50 s</span>
        </div>

        <div class="slider-container">
          <label for="playbackRateSlider">Playback Rate:</label>
          <input
            type="range"
            id="playbackRateSlider"
            min="0.25"
            max="4"
            step="0.005"
            value="1"
          />
          <span id="playbackRateValue">1.00</span>
        </div>
      </div>

      <div>
        <h3>Loop Controls</h3>
        <div class="slider-container">
          <label for="loopStartSlider">Loop Start:</label>
          <input
            type="range"
            id="loopStartSlider"
            min="0"
            max="0.5"
            step="0.005"
            value="0"
          />
          <span id="loopStartValue">0.00 s</span>
        </div>

        <div class="slider-container">
          <label for="loopEndSlider">Loop End:</label>
          <input
            type="range"
            id="loopEndSlider"
            min="0"
            max="0.5"
            step="0.005"
            value="0.5"
          />
          <span id="loopEndValue">0.50 s</span>
        </div>

        <div class="slider-container">
          <label for="interpolationSpeedSlider">Interp. Speed:</label>
          <input
            type="range"
            id="interpolationSpeedSlider"
            min="0.01"
            max="0.5"
            step="0.01"
            value="0.05"
          />
          <span id="interpolationSpeedValue">0.05</span>
        </div>
      </div>
    </div>

    <h3>Waveform and Position</h3>
    <canvas id="waveform"></canvas>
    <div id="positionInfo">Position: 0.00 s</div>

    <h3>Status Messages</h3>
    <div class="status" id="statusMessages"></div>

    <script type="module">
      import { SourceNode } from '@repo/audiolib';

      console.log(SourceNode);

      let audioContext;
      let sourceNode;
      let audioBuffer;
      let workletNode;
      let isPlaying = false;
      let loopingEnabled = false;
      let isStreamingPosition = false;
      let bufferChannelData;
      let bufferDuration = 0;

      const WORKLET_PATH = './source-processor.js';

      // Get DOM elements
      const playButton = document.getElementById('playButton');
      const stopButton = document.getElementById('stopButton');
      const loadButton = document.getElementById('loadSound');
      const enableLoopingButton = document.getElementById('enableLooping');
      const disableLoopingButton = document.getElementById('disableLooping');
      const streamPositionButton = document.getElementById('streamPosition');
      const statusMessages = document.getElementById('statusMessages');
      const waveformCanvas = document.getElementById('waveform');
      const positionInfo = document.getElementById('positionInfo');

      // Sliders
      const startSlider = document.getElementById('startSlider');
      const endSlider = document.getElementById('endSlider');
      const loopStartSlider = document.getElementById('loopStartSlider');
      const loopEndSlider = document.getElementById('loopEndSlider');
      const playbackRateSlider = document.getElementById('playbackRateSlider');
      const interpolationSpeedSlider = document.getElementById(
        'interpolationSpeedSlider'
      );

      // Values displays
      const startValue = document.getElementById('startValue');
      const endValue = document.getElementById('endValue');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndValue = document.getElementById('loopEndValue');
      const playbackRateValue = document.getElementById('playbackRateValue');
      const interpolationSpeedValue = document.getElementById(
        'interpolationSpeedValue'
      );

      // Log function
      function log(message) {
        const div = document.createElement('div');
        div.textContent = message;
        statusMessages.appendChild(div);
        statusMessages.scrollTop = statusMessages.scrollHeight;
      }

      // Initialize audio context and load worklet
      async function init() {
        try {
          audioContext = new AudioContext();

          // Check if worklet module is already registered
          let isWorkletLoaded = false;
          try {
            // This will throw if the processor isn't registered
            new AudioWorkletNode(audioContext, 'source-processor');
            isWorkletLoaded = true;
          } catch (e) {
            isWorkletLoaded = false;
          }

          // Load worklet if needed
          if (!isWorkletLoaded) {
            await audioContext.audioWorklet.addModule(WORKLET_PATH);
          }

          log('Audio worklet loaded successfully');
          loadButton.disabled = false;
        } catch (error) {
          log('Error initializing: ' + error.message);
          console.error(error);
        }
      }

      // Load the piano C4 sound
      async function loadPianoSound() {
        try {
          log('Loading piano C4 sound...');

          // Load audio file
          const response = await fetch('piano-c4.mp3');
          const arrayBuffer = await response.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          // Extract channel data for the processor
          bufferChannelData = [];
          for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
            bufferChannelData.push(audioBuffer.getChannelData(i));
          }

          bufferDuration = audioBuffer.duration;
          log(`Piano C4 loaded: ${bufferDuration.toFixed(2)}s`);

          // Draw waveform
          drawWaveform(bufferChannelData[0]);

          // Enable play button
          playButton.disabled = false;

          // If buffer duration is longer than slider max (0.5s), we'll use first 0.5s
          if (bufferDuration > 0.5) {
            log('Note: Using first 0.5 seconds of audio');
            // Update slider values to match 0.5s limit
            updateSliderRanges(0.5);
          } else {
            updateSliderRanges(bufferDuration);
          }
        } catch (error) {
          log('Error loading piano sound: ' + error.message);
          console.error(error);
        }
      }

      function updateSliderRanges(duration) {
        // We'll limit to 0.5s as requested
        const maxDuration = Math.min(0.5, duration);

        // Update slider max values if needed
        startSlider.max = maxDuration;
        endSlider.max = maxDuration;
        endSlider.value = maxDuration;
        loopStartSlider.max = maxDuration;
        loopEndSlider.max = maxDuration;
        loopEndSlider.value = maxDuration;

        // Update displayed values
        startValue.textContent = '0.00 s';
        endValue.textContent = maxDuration.toFixed(2) + ' s';
        loopStartValue.textContent = '0.00 s';
        loopEndValue.textContent = maxDuration.toFixed(2) + ' s';
      }

      function drawWaveform(data) {
        const canvas = waveformCanvas;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Draw center line
        ctx.strokeStyle = '#999';
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();

        // Draw waveform
        ctx.strokeStyle = '#0066FF';
        ctx.beginPath();

        // We'll only visualize the first 0.5 seconds regardless of file length
        const samplesToShow = Math.min(
          data.length,
          audioContext.sampleRate * 0.5
        );
        const step = Math.ceil(samplesToShow / width);

        for (let i = 0; i < width; i++) {
          const dataIndex = i * step;
          if (dataIndex < samplesToShow) {
            const y = (0.5 - data[dataIndex] / 2) * height;
            if (i === 0) {
              ctx.moveTo(i, y);
            } else {
              ctx.lineTo(i, y);
            }
          }
        }

        ctx.stroke();
      }

      function playSound() {
        if (isPlaying) return;

        try {
          // Create and connect the worklet node
          workletNode = new AudioWorkletNode(audioContext, 'source-processor');
          workletNode.connect(audioContext.destination);

          // Set up message handling from the processor
          workletNode.port.onmessage = (event) => {
            if (event.data.type === 'update') {
              log(
                `Update: playbackRate=${event.data.playbackRate.toFixed(2)}, ` +
                  `isPlaying=${event.data.isPlaying}`
              );
            } else if (event.data.type === 'positionUpdate') {
              // Update position display
              positionInfo.textContent = `Position: ${event.data.position.toFixed(2)} s`;

              // Draw playhead on waveform
              drawPlayhead(event.data.position);
            }
          };

          // Send buffer to processor
          workletNode.port.postMessage({
            type: 'setBuffer',
            buffer: bufferChannelData,
            sampleRate: audioContext.sampleRate,
          });

          // Enable position streaming
          if (isStreamingPosition) {
            workletNode.port.postMessage({
              type: 'streamPosition',
              enabled: true,
              interval: 5,
            });
          }

          // Set initial parameters
          workletNode.parameters.get('targetStart').value = parseFloat(
            startSlider.value
          );
          workletNode.parameters.get('targetEnd').value = parseFloat(
            endSlider.value
          );
          workletNode.parameters.get('targetLoopStart').value = parseFloat(
            loopStartSlider.value
          );
          workletNode.parameters.get('targetLoopEnd').value = parseFloat(
            loopEndSlider.value
          );
          workletNode.parameters.get('interpolationSpeed').value = parseFloat(
            interpolationSpeedSlider.value
          );
          workletNode.parameters.get('targetPlaybackRate').value = parseFloat(
            playbackRateSlider.value
          );

          // Enable updates from processor
          workletNode.port.postMessage({
            type: 'enableUpdates',
            interval: 50,
          });

          // Tell processor to start playback
          workletNode.port.postMessage({ type: 'play' });

          // Tell processor about looping state
          if (loopingEnabled) {
            workletNode.port.postMessage({ type: 'enableLooping' });
          } else {
            workletNode.port.postMessage({ type: 'disableLooping' });
          }

          isPlaying = true;
          playButton.disabled = true;
          stopButton.disabled = false;

          log('Playback started');
        } catch (error) {
          log('Error starting playback: ' + error.message);
          console.error(error);
        }
      }

      function stopSound() {
        if (!isPlaying) return;

        try {
          // Tell processor to stop playback
          workletNode.port.postMessage({ type: 'stop' });

          // Disconnect and clean up
          workletNode.disconnect();

          isPlaying = false;
          playButton.disabled = false;
          stopButton.disabled = true;

          log('Playback stopped');
        } catch (error) {
          log('Error stopping playback: ' + error.message);
          console.error(error);
        }
      }

      function drawPlayhead(position) {
        const canvas = waveformCanvas;
        const ctx = canvas.getContext('2d');

        // Redraw waveform to clear previous playhead
        if (bufferChannelData && bufferChannelData[0]) {
          drawWaveform(bufferChannelData[0]);
        }

        // Draw playhead - limit to first 0.5 seconds
        const maxPosition = Math.min(position, 0.5);
        const x = (maxPosition / 0.5) * canvas.width;
        ctx.strokeStyle = '#FF0000';
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // Event listeners
      loadButton.addEventListener('click', loadPianoSound);
      playButton.addEventListener('click', playSound);
      stopButton.addEventListener('click', stopSound);

      enableLoopingButton.addEventListener('click', () => {
        loopingEnabled = true;
        log('Looping enabled');
        if (isPlaying && workletNode) {
          workletNode.port.postMessage({ type: 'enableLooping' });
        }
      });

      disableLoopingButton.addEventListener('click', () => {
        loopingEnabled = false;
        log('Looping disabled');
        if (isPlaying && workletNode) {
          workletNode.port.postMessage({ type: 'disableLooping' });
        }
      });

      streamPositionButton.addEventListener('click', () => {
        isStreamingPosition = !isStreamingPosition;
        streamPositionButton.textContent = isStreamingPosition
          ? 'Stop Streaming Position'
          : 'Stream Position';

        if (isPlaying && workletNode) {
          workletNode.port.postMessage({
            type: 'streamPosition',
            enabled: isStreamingPosition,
            interval: 5,
          });
        }

        log(
          isStreamingPosition
            ? 'Position streaming enabled'
            : 'Position streaming disabled'
        );
      });

      // Slider event listeners
      startSlider.addEventListener('input', () => {
        const value = parseFloat(startSlider.value);
        startValue.textContent = value.toFixed(2) + ' s';
        if (isPlaying && workletNode) {
          workletNode.parameters.get('targetStart').value = value;
        }
      });

      endSlider.addEventListener('input', () => {
        const value = parseFloat(endSlider.value);
        endValue.textContent = value.toFixed(2) + ' s';
        if (isPlaying && workletNode) {
          workletNode.parameters.get('targetEnd').value = value;
        }
      });

      loopStartSlider.addEventListener('input', () => {
        const value = parseFloat(loopStartSlider.value);
        loopStartValue.textContent = value.toFixed(2) + ' s';
        if (isPlaying && workletNode) {
          workletNode.parameters.get('targetLoopStart').value = value;
        }
      });

      loopEndSlider.addEventListener('input', () => {
        const value = parseFloat(loopEndSlider.value);
        loopEndValue.textContent = value.toFixed(2) + ' s';
        if (isPlaying && workletNode) {
          workletNode.parameters.get('targetLoopEnd').value = value;
        }
      });

      playbackRateSlider.addEventListener('input', () => {
        const value = parseFloat(playbackRateSlider.value);
        playbackRateValue.textContent = value.toFixed(2);
        if (isPlaying && workletNode) {
          workletNode.parameters.get('targetPlaybackRate').value = value;
        }
      });

      interpolationSpeedSlider.addEventListener('input', () => {
        const value = parseFloat(interpolationSpeedSlider.value);
        interpolationSpeedValue.textContent = value.toFixed(2);
        if (isPlaying && workletNode) {
          workletNode.parameters.get('interpolationSpeed').value = value;
        }
      });

      // Canvas setup
      function setupCanvas() {
        const canvas = waveformCanvas;
        const rect = canvas.parentNode.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = 150;
      }

      // Initialize
      window.addEventListener('load', () => {
        setupCanvas();
        init();
      });

      window.addEventListener('resize', setupCanvas);
    </script>
  </body>
</html>
