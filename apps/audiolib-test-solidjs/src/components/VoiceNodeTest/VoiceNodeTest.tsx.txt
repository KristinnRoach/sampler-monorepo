import {
  Component,
  createSignal,
  createEffect,
  onMount,
  onCleanup,
} from 'solid-js';
// Temporarily use a direct import to workaround build issue
import { VoiceNode } from '@repo/audiolib';
import styles from './VoiceNodeTest.module.css';

interface AudioSample {
  name: string;
  url: string;
  buffer?: AudioBuffer;
}

const VoiceNodeTest: Component = () => {
  // Audio context and nodes
  const [audioContext, setAudioContext] = createSignal<AudioContext | null>(
    null
  );
  const [voiceNode, setVoiceNode] = createSignal<VoiceNode | null>(null);

  // UI state
  const [isPlaying, setIsPlaying] = createSignal(false);
  const [isReleasing, setIsReleasing] = createSignal(false);
  const [currentSampleIndex, setCurrentSampleIndex] = createSignal(0);
  const [attack, setAttack] = createSignal(0.05);
  const [release, setRelease] = createSignal(0.3);
  const [loopEnabled, setLoopEnabled] = createSignal(false);

  // Sample data
  const samples: AudioSample[] = [
    { name: 'Guitar', url: '/audio/test-samples/guitar.mp3' },
    { name: 'Piano', url: '/audio/test-samples/c4.mp3' },
    { name: 'Drum', url: '/audio/test-samples/Kit03-120C-04.wav' },
  ];

  // Initialize audio context
  const initAudio = async () => {
    if (audioContext()) return;

    try {
      const context = new AudioContext();
      setAudioContext(context);

      // Create and initialize voice node
      const voice = new VoiceNode(context);
      voice.setEnvelope(EnvelopeType.AR, {
        attack: attack(),
        release: release(),
      });
      voice.connect(context.destination);
      setVoiceNode(voice);

      // Load initial sample
      if (samples[currentSampleIndex()]) {
        await loadSample(samples[currentSampleIndex()]!);
      }
    } catch (error) {
      console.error('Failed to initialize audio:', error);
    }
  };

  // Load a sample into the voice node
  const loadSample = async (sample: AudioSample) => {
    const context = audioContext();
    const voice = voiceNode();

    if (!context || !voice) return;

    try {
      // Use cached buffer if available
      if (sample.buffer) {
        voice.setBuffer(sample.buffer);
        return;
      }

      // Load and decode the audio file
      const response = await fetch(sample.url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await context.decodeAudioData(arrayBuffer);

      // Cache the buffer and set it on the voice node
      sample.buffer = audioBuffer;
      voice.setBuffer(audioBuffer);
    } catch (error) {
      console.error(`Failed to load sample "${sample.name}":`, error);
    }
  };

  // Play the current sample
  const playSample = () => {
    const voice = voiceNode();
    if (!voice) return;

    voice.start();
    setIsPlaying(true);
    setIsReleasing(false);
  };

  // Release the current note
  const releaseSample = () => {
    const voice = voiceNode();
    if (!voice || !isPlaying()) return;

    voice.release();
    setIsReleasing(true);

    // Wait for release to complete before resetting state
    setTimeout(
      () => {
        setIsPlaying(false);
        setIsReleasing(false);
      },
      release() * 1000 + 100
    ); // Add a small buffer
  };

  // Stop immediately
  const stopSample = () => {
    const voice = voiceNode();
    if (!voice || !isPlaying()) return;

    voice.stop();
    setIsPlaying(false);
    setIsReleasing(false);
  };

  // Change sample
  const changeSample = (index: number) => {
    if (index === currentSampleIndex()) return;

    // Stop current playback
    if (isPlaying()) {
      stopSample();
    }

    setCurrentSampleIndex(index);
    if (samples[index]) loadSample(samples[index]);
  };

  // Toggle looping
  const toggleLoop = (enabled: boolean) => {
    const voice = voiceNode();
    if (!voice) return;

    setLoopEnabled(enabled);
    voice.setLoop(enabled);
  };

  // Update envelope parameters
  createEffect(() => {
    const voice = voiceNode();
    if (!voice) return;

    voice.setEnvelope(EnvelopeType.AR, {
      attack: attack(),
      release: release(),
    });
  });

  // Clean up on unmount
  onCleanup(() => {
    const voice = voiceNode();
    if (voice && isPlaying()) {
      voice.stop();
    }

    const context = audioContext();
    if (context && context.state !== 'closed') {
      context.close();
    }
  });

  return (
    <div class={styles.container}>
      <h2 class={styles.title}>VoiceNode Test</h2>

      <div class={styles.controls}>
        <button
          class={styles.initButton}
          onClick={initAudio}
          disabled={!!audioContext()}
        >
          Initialize Audio
        </button>

        <div class={styles.sampleSelector}>
          <span>Sample:</span>
          {samples.map((sample, index) => (
            <button
              class={
                currentSampleIndex() === index
                  ? styles.activeButton
                  : styles.button
              }
              onClick={() => changeSample(index)}
              disabled={!audioContext()}
            >
              {sample.name}
            </button>
          ))}
        </div>

        <div class={styles.playbackControls}>
          <button
            class={isPlaying() ? styles.activeButton : styles.button}
            onClick={playSample}
            disabled={!audioContext() || isPlaying()}
          >
            Play
          </button>

          <button
            class={isReleasing() ? styles.activeButton : styles.button}
            onClick={releaseSample}
            disabled={!audioContext() || !isPlaying() || isReleasing()}
          >
            Release
          </button>

          <button
            class={styles.button}
            onClick={stopSample}
            disabled={!audioContext() || !isPlaying()}
          >
            Stop
          </button>
        </div>

        <div class={styles.envelopeControls}>
          <div class={styles.control}>
            <label for='attack'>Attack: {attack().toFixed(2)}s</label>
            <input
              id='attack'
              type='range'
              min='0.001'
              max='2'
              step='0.01'
              value={attack()}
              onInput={(e) => setAttack(parseFloat(e.currentTarget.value))}
              disabled={!audioContext()}
            />
          </div>

          <div class={styles.control}>
            <label for='release'>Release: {release().toFixed(2)}s</label>
            <input
              id='release'
              type='range'
              min='0.001'
              max='2'
              step='0.01'
              value={release()}
              onInput={(e) => setRelease(parseFloat(e.currentTarget.value))}
              disabled={!audioContext()}
            />
          </div>
        </div>

        <div class={styles.loopControl}>
          <label>
            <input
              type='checkbox'
              checked={loopEnabled()}
              onChange={(e) => toggleLoop(e.currentTarget.checked)}
              disabled={!audioContext()}
            />
            Loop Audio
          </label>
        </div>
      </div>

      <div class={styles.status}>
        Status:{' '}
        {!audioContext()
          ? 'Not initialized'
          : isPlaying()
            ? isReleasing()
              ? 'Releasing'
              : 'Playing'
            : 'Ready'}
      </div>
    </div>
  );
};

export default VoiceNodeTest;
