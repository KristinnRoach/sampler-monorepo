import React, { useState, useEffect, useRef } from 'react';
import { SourcePool, ensureAudioCtx, SourceNode } from '@repo/audiolib';
import KeyboardController from '../../input/KeyboardController';

const SourcePoolTester: React.FC = () => {
  const [isInitialized, setIsInitialized] = useState(false);
  // const [audioBuffer, setAudioBuffer] = useState<AudioBuffer | null>(null);

  const [isPlaying, setIsPlaying] = useState(false);
  const [playingNodes, setPlayingNodes] = useState<number>(0);
  const [availableNodes, setAvailableNodes] = useState<number>(0);
  const [polyphony, setPolyphony] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);

  // UI Controls
  const [playbackRate, setPlaybackRate] = useState(1);
  const [loopEnabled, setLoopEnabled] = useState(false);
  const [loopStart, setLoopStart] = useState(0);
  const [loopEnd, setLoopEnd] = useState(1);

  // Refs to maintain state across renders
  const audioContextRef = useRef<AudioContext | null>(null);
  const bufferRef = useRef<AudioBuffer | null>(null);
  const poolRef = useRef<SourcePool | null>(null);
  const activeNodesRef = useRef<Set<SourceNode>>(new Set());

  const initAudio = async (inputEvent: React.ChangeEvent<HTMLInputElement>) => {
    if (audioContextRef.current) {
      console.warn('Audio context already initialized');
      return;
    }
    const context = await ensureAudioCtx();
    audioContextRef.current = context;

    await handleFileUpload(inputEvent); // Trigger file upload handler to load default audio buffer

    initPool();

    setError(null);
  };

  const initPool = () => {
    if (!audioContextRef.current) {
      console.warn('Audio context not initialized');
      return;
    }
    if (!bufferRef.current) {
      console.warn('Audio buffer not set');
      return;
    }
    const pool = new SourcePool(audioContextRef.current, 8, {
      buffer: bufferRef.current,
    });
    poolRef.current = pool;
    setPolyphony(pool.polyphony);
    setAvailableNodes(pool.availableCount);
    setIsInitialized(true);
    console.log(`Pool initialized with ${pool.polyphony} nodes`);
    setError(null);
  };

  const handleFileUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) return;
    if (!audioContextRef.current) {
      setError('Audio context not initialized');
      return;
    }
    const file = e.target.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const decodedBuffer =
      await audioContextRef.current.decodeAudioData(arrayBuffer);

    poolRef.current?.stopAll();
    activeNodesRef.current.clear();
    poolRef.current?.dispose();
    poolRef.current = null;

    bufferRef.current = decodedBuffer;
    setLoopEnd(decodedBuffer.duration);
  };

  // Update available nodes count every 500ms
  useEffect(() => {
    if (!isInitialized) return;

    const interval = setInterval(() => {
      if (poolRef.current) {
        setAvailableNodes(poolRef.current.availableCount);
        setPlayingNodes(poolRef.current.activeCount);
      }
    }, 500);

    return () => clearInterval(interval);
  }, [isInitialized]);

  const handlePlay = (midiNote: number = 60, velocity: number = 1) => {
    if (!poolRef.current || !bufferRef.current) {
      setError('Audio not initialized yet');
      return;
    }

    const sourceNode = poolRef.current.playNote(midiNote, velocity);
    console.log({ sourceNode });
  };

  const handleStop = (midiNote: number) => {
    if (!poolRef.current) {
      setError('Audio not initialized yet');
      return;
    }

    const didStop = poolRef.current.stopNote(midiNote);
    console.log({ didStop });
  };

  const handleStopAll = () => {
    if (!poolRef.current) return;

    poolRef.current.stopAll();
    activeNodesRef.current.clear();
    setPlayingNodes(0);
    setAvailableNodes(poolRef.current.availableCount);
    setIsPlaying(false);
  };

  return (
    <div className='p-4 max-w-md mx-auto bg-white rounded-xl shadow-md'>
      <h2 className='text-xl font-bold mb-4'>Audio Source Pool Tester</h2>

      <div className='mb-4'>
        <input
          type='file'
          accept='audio/*'
          onChange={initAudio}
          className='mb-2'
        ></input>
      </div>

      {audioContextRef.current && (
        <KeyboardController
          onNoteOn={(midiNote: number, velocity: number = 1) => {
            handlePlay(midiNote, velocity);
          }}
          onNoteOff={(midiNote: number) => {
            handleStop(midiNote);
          }}
        />
      )}

      {error && (
        <div className='bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4'>
          <p>{error}</p>
          <button onClick={() => setError(null)} className='text-sm underline'>
            Dismiss
          </button>
        </div>
      )}

      {!isInitialized ? (
        <div className='text-center py-4'>
          <p>Initializing audio system...</p>
        </div>
      ) : (
        <div className='space-y-4'>
          {/* Pool Stats */}
          <div className='bg-gray-100 p-3 rounded'>
            <h3 className='font-semibold'>Pool Status:</h3>
            <div className='grid grid-cols-2 gap-2 text-sm mt-2'>
              <div>Total Nodes:</div>
              <div>{polyphony}</div>
              <div>Available:</div>
              <div>{availableNodes}</div>
              <div>Playing:</div>
              <div>{playingNodes}</div>
              <div>Is Playing:</div>
              <div>{isPlaying ? 'Yes' : 'No'}</div>
            </div>
          </div>

          {/* Playback Controls */}
          <div className='space-y-3'>
            <div>
              <label className='block text-sm font-medium'>
                Playback Rate: {playbackRate.toFixed(2)}x
              </label>
              <input
                type='range'
                min='0.5'
                max='2'
                step='0.01'
                value={playbackRate}
                onChange={(e) => setPlaybackRate(Number(e.target.value))}
                className='w-full'
              />
            </div>

            <div className='flex items-center'>
              <input
                type='checkbox'
                id='loop-toggle'
                checked={loopEnabled}
                onChange={(e) => setLoopEnabled(e.target.checked)}
                className='mr-2'
              />
              <label htmlFor='loop-toggle' className='text-sm font-medium'>
                Loop Enabled
              </label>
            </div>

            {loopEnabled && (
              <>
                <div>
                  <label className='block text-sm font-medium'>
                    Loop Start: {loopStart.toFixed(2)}s
                  </label>
                  <input
                    type='range'
                    min='0'
                    max={bufferRef.current?.duration || 1}
                    step='0.01'
                    value={loopStart}
                    onChange={(e) => setLoopStart(Number(e.target.value))}
                    className='w-full'
                  />
                </div>

                <div>
                  <label className='block text-sm font-medium'>
                    Loop End: {loopEnd.toFixed(2)}s
                  </label>
                  <input
                    type='range'
                    min='0'
                    max={bufferRef.current?.duration || 1}
                    step='0.01'
                    value={loopEnd}
                    onChange={(e) => setLoopEnd(Number(e.target.value))}
                    className='w-full'
                  />
                </div>
              </>
            )}
          </div>

          {/* Action Buttons */}
          <div className='flex space-x-2'>
            <button
              onClick={handleStopAll}
              disabled={playingNodes === 0}
              className='flex-1 bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded disabled:bg-gray-400'
            >
              Stop All
            </button>
          </div>

          {/* <button
            onClick={handleExpandPool}
            className='w-full bg-gray-200 hover:bg-gray-300 py-2 px-4 rounded'
          >
            Add More Nodes (+4)
          </button> */}
        </div>
      )}
    </div>
  );
};

export default SourcePoolTester;

// useEffect(() => {
//   const initAudio = async () => {
//     try {
//       // Create audio context
//       const context = await ensureAudioCtx();
//       if (!context) {
//         throw new Error('Failed to create AudioContext');
//       }
//       audioContextRef.current = context;

//       // Create oscillator buffer for testing
//       const sampleRate = context.sampleRate;
//       const duration = 2; // 2 seconds
//       const buffer = context.createBuffer(
//         1,
//         duration * sampleRate,
//         sampleRate
//       );

//       // Fill with a sine wave
//       const channelData = buffer.getChannelData(0);
//       for (let i = 0; i < channelData.length; i++) {
//         // Create a combined tone with fade-in/fade-out to avoid clicks
//         const fadeTime = 0.05; // 50ms fade
//         const fadeInSamples = fadeTime * sampleRate;
//         const fadeOutSamples = fadeTime * sampleRate;

//         // Basic amplitude envelope
//         let amplitude = 1.0;
//         if (i < fadeInSamples) {
//           amplitude = i / fadeInSamples;
//         } else if (i > channelData.length - fadeOutSamples) {
//           amplitude = (channelData.length - i) / fadeOutSamples;
//         }

//         // Combined tone (440Hz + 880Hz)
//         channelData[i] =
//           amplitude *
//           (0.7 * Math.sin((440 * 2 * Math.PI * i) / sampleRate) +
//             0.3 * Math.sin((880 * 2 * Math.PI * i) / sampleRate));
//       }

//       audioBufferRef.current = buffer;
//       setLoopEnd(duration);

//       const pool = new SourcePool(context, 8, { buffer: buffer });
//       poolRef.current = pool;
//       // await pool.init(buffer);

//       setIsInitialized(true);
//       setTotalNodes(pool.polyphony);
//       setAvailableNodes(pool.availableCount);

//       console.log(`Pool initialized with ${pool.polyphony} nodes`);
//     } catch (err: unknown) {
//       console.error('Initialization error:', err);
//       setError('Failed to initialize audio');
//     }
//   };

//   initAudio();

//   // Cleanup on unmount
//   return () => {
//     if (audioContextRef.current) {
//       audioContextRef.current.close();
//     }
//   };
// }, []);
