// env-playheads.ts
import { gsap, MotionPathPlugin, CustomEase } from 'gsap/all';
import { generateMidiNoteColors } from '../../../utils/generateColors';
import type { CustomEnvelope, EnvelopePoint } from '@repo/audiolib';
import { secondsToScreenX } from './env-utils';

gsap.registerPlugin(MotionPathPlugin, CustomEase);

export interface AnimationMessage {
  voiceId: number;
  midiNote: number;
  envDurations: Record<string, number>;
  loopEnabled?: Record<string, boolean>;
}

export interface PlayheadManager {
  triggerPlayAnimation: (msg: AnimationMessage, envelopeType: string) => void;
  releaseAnimation: (msg: AnimationMessage) => void;
  refreshPlayingAnimations: () => void;
  hideAllPlayheads: () => void;
  refreshSustainPoint: () => void;
  cleanup: () => void;
}

export const Playheads = (
  svgElement: SVGSVGElement,
  envelopePath: SVGPathElement,
  envelope: CustomEnvelope,
  svgWidth: number = 400,
  multiColorPlayheads: boolean = true
): PlayheadManager => {
  const activeTweens: Map<number, gsap.core.Timeline> = new Map();
  const playheads: Map<number, SVGCircleElement> = new Map();

  // Sustain state - store as time value
  let sustainTime: number = -1; // -1 means no sustain

  // Cache envelope points for Y interpolation
  let envelopePoints: Array<{ x: number; y: number }> = [];

  // Generate note colors for multi-colored playheads
  let noteColor: string | Record<number, string>;
  if (multiColorPlayheads) {
    noteColor = generateMidiNoteColors('none', [40, 90], true);
  } else {
    noteColor = 'red';
  }

  /**
   * Creates a playhead circle element
   */
  const createPlayhead = (voiceId: number): SVGCircleElement => {
    const circle = document.createElementNS(
      'http://www.w3.org/2000/svg',
      'circle'
    );
    circle.setAttribute('id', `playhead-${voiceId}`);
    circle.setAttribute('cx', '0'); // Start at x=0
    circle.setAttribute('cy', '0'); // Will be set by interpolation
    circle.setAttribute('r', '5');
    circle.setAttribute('fill', 'transparent');
    circle.setAttribute('stroke-width', '2');
    circle.setAttribute('class', 'playhead');
    circle.setAttribute('tabIndex', '-1');
    circle.style.pointerEvents = 'none';
    return circle;
  };

  /**
   * Extract points from envelope path for Y interpolation
   */
  const updateEnvelopePoints = (): void => {
    try {
      const pathData = envelopePath.getAttribute('d');
      if (!pathData) return;

      // Sample the path to get x,y coordinates
      const pathLength = envelopePath.getTotalLength();
      const numSamples = Math.max(100, Math.floor(svgWidth)); // At least one sample per pixel

      envelopePoints = [];
      for (let i = 0; i <= numSamples; i++) {
        const distance = (i / numSamples) * pathLength;
        const point = envelopePath.getPointAtLength(distance);
        envelopePoints.push({ x: point.x, y: point.y });
      }

      // Sort by x to ensure proper interpolation
      envelopePoints.sort((a, b) => a.x - b.x);
    } catch (e) {
      console.warn('Failed to extract envelope points:', e);
      envelopePoints = [];
    }
  };

  /**
   * Get Y coordinate for any X position using linear interpolation
   */
  const getYForX = (x: number): number => {
    if (envelopePoints.length === 0) return 100; // Fallback

    // Clamp x to valid range
    x = Math.max(0, Math.min(svgWidth, x));

    // Find the two points that bracket this x value
    for (let i = 0; i < envelopePoints.length - 1; i++) {
      const p1 = envelopePoints[i];
      const p2 = envelopePoints[i + 1];

      if (x >= p1.x && x <= p2.x) {
        // Linear interpolation between p1 and p2
        const t = p2.x === p1.x ? 0 : (x - p1.x) / (p2.x - p1.x);
        return p1.y + t * (p2.y - p1.y);
      }
    }

    // If x is beyond the last point, return the last y value
    return envelopePoints[envelopePoints.length - 1].y;
  };

  const refreshSustainPoint = (): void => {
    if (envelope.sustainPointIndex) {
      sustainTime = envelope.points[envelope.sustainPointIndex].time;
    } else {
      console.debug(`refreshSustainPoint: Envelope sustain point is null`);
    }
  };

  /**
   * Triggers a playhead animation for a voice
   */
  const triggerPlayAnimation = (
    msg: AnimationMessage,
    envelopeType: string
  ): void => {
    if (!envelope.isEnabled) return;

    // Kill existing animation for this voice
    if (activeTweens.has(msg.voiceId)) {
      const existing = activeTweens.get(msg.voiceId);
      if (existing && existing.isActive()) {
        existing.kill();
      }
      activeTweens.delete(msg.voiceId);
    }

    if (!msg.envDurations[envelopeType]) return;

    const envDuration = msg.envDurations[envelopeType] ?? envelope.fullDuration;

    // Update envelope points for current path
    updateEnvelopePoints();

    // Create and add playhead
    const playhead = createPlayhead(msg.voiceId);
    svgElement.appendChild(playhead);

    const color = multiColorPlayheads
      ? (noteColor as Record<number, string>)[msg.midiNote] || 'red'
      : 'red';

    // Set initial color
    playhead.setAttribute('fill', color);

    const isLoopingEnv = msg.loopEnabled?.[envelopeType] ?? false;
    const startX = 0;
    const endX = svgWidth;

    if (sustainTime >= 0 && sustainTime < envDuration) {
      // With sustain: create timeline with two phases
      const sustainX = secondsToScreenX(sustainTime, envDuration, svgWidth);
      const tl = gsap.timeline();

      // Phase 1: Start to sustain point (linear time)
      tl.to(playhead, {
        attr: { cx: sustainX },
        duration: sustainTime,
        ease: 'none', // Linear time progression
        onUpdate: function () {
          const currentX = parseFloat(playhead.getAttribute('cx') || '0');
          const currentY = getYForX(currentX);
          playhead.setAttribute('cy', currentY.toString());
        },
        onComplete: () => {
          // Pause the timeline when we reach the sustain point
          tl.pause();
        },
      });

      // Phase 2: Sustain to end (linear time)
      tl.to(playhead, {
        attr: { cx: endX },
        duration: envDuration - sustainTime,
        ease: 'none', // Linear time progression
        onUpdate: function () {
          const currentX = parseFloat(playhead.getAttribute('cx') || '0');
          const currentY = getYForX(currentX);
          playhead.setAttribute('cy', currentY.toString());
        },
        onComplete: () => {
          playhead.setAttribute('fill', 'transparent');
          // Cleanup
          if (playhead.parentNode === svgElement) {
            svgElement.removeChild(playhead);
          }
          activeTweens.delete(msg.voiceId);
          playheads.delete(msg.voiceId);
        },
      });

      activeTweens.set(msg.voiceId, tl);
    } else {
      // No sustain: normal full animation
      const tl = gsap.timeline();

      tl.to(playhead, {
        attr: { cx: endX },
        duration: envDuration,
        repeat: isLoopingEnv ? -1 : 0,
        ease: 'none', // Linear time progression
        onUpdate: function () {
          const currentX = parseFloat(playhead.getAttribute('cx') || '0');
          const currentY = getYForX(currentX);
          playhead.setAttribute('cy', currentY.toString());
        },
        onComplete: () => {
          if (!isLoopingEnv) {
            playhead.setAttribute('fill', 'transparent');
            if (playhead.parentNode === svgElement) {
              svgElement.removeChild(playhead);
            }
            activeTweens.delete(msg.voiceId);
            playheads.delete(msg.voiceId);
          }
        },
      });

      activeTweens.set(msg.voiceId, tl);
    }

    playheads.set(msg.voiceId, playhead);
  };

  /**
   * Releases/continues animation from sustain point
   */
  const releaseAnimation = (msg: AnimationMessage): void => {
    if (!envelope.isEnabled) return;

    const tl = activeTweens.get(msg.voiceId);

    if (tl && tl.paused()) {
      // Resume the timeline to continue to the end
      tl.play();
    } else {
      // No sustain or already finished - just cleanup
      const playhead = playheads.get(msg.voiceId);

      if (tl && tl.isActive()) {
        tl.kill();
      }
      if (playhead && playhead.parentNode === svgElement) {
        svgElement.removeChild(playhead);
      }
      activeTweens.delete(msg.voiceId);
      playheads.delete(msg.voiceId);
    }
  };

  /**
   * Refreshes all currently playing animations
   */
  const refreshPlayingAnimations = (): void => {
    if (!envelope.isEnabled) return;

    // Update envelope points for current path
    updateEnvelopePoints();

    for (const [voiceId, tl] of activeTweens) {
      if (tl.isActive() || tl.paused()) {
        const totalTime = tl.time();
        const wasPaused = tl.paused();
        const playhead = playheads.get(voiceId);

        if (playhead) {
          // Kill the old timeline
          tl.kill();

          // Recreate the timeline with updated path
          const newTl = gsap.timeline();
          const envDuration = envelope.fullDuration;
          const endX = svgWidth;

          if (sustainTime >= 0 && sustainTime < envDuration) {
            const sustainX = secondsToScreenX(
              sustainTime,
              envDuration,
              svgWidth
            );

            // Phase 1: Start to sustain
            newTl.to(playhead, {
              attr: { cx: sustainX },
              duration: sustainTime,
              ease: 'none',
              onUpdate: function () {
                const currentX = parseFloat(playhead.getAttribute('cx') || '0');
                const currentY = getYForX(currentX);
                playhead.setAttribute('cy', currentY.toString());
              },
            });

            // Phase 2: Sustain to end
            newTl.to(playhead, {
              attr: { cx: endX },
              duration: envDuration - sustainTime,
              ease: 'none',
              onUpdate: function () {
                const currentX = parseFloat(playhead.getAttribute('cx') || '0');
                const currentY = getYForX(currentX);
                playhead.setAttribute('cy', currentY.toString());
              },
              onComplete: () => {
                playhead.setAttribute('fill', 'transparent');
              },
            });

            // Restore time and pause state
            newTl.time(totalTime);
            if (wasPaused) {
              newTl.pause();
            }
          } else {
            // No sustain: normal animation
            newTl.to(playhead, {
              attr: { cx: endX },
              duration: envDuration,
              ease: 'none',
              onUpdate: function () {
                const currentX = parseFloat(playhead.getAttribute('cx') || '0');
                const currentY = getYForX(currentX);
                playhead.setAttribute('cy', currentY.toString());
              },
              onComplete: () => {
                playhead.setAttribute('fill', 'transparent');
              },
            });

            newTl.time(totalTime);
          }

          activeTweens.set(voiceId, newTl);
        }
      }
    }
  };

  /**
   * Hides all playheads
   */
  const hideAllPlayheads = (): void => {
    for (const [, playhead] of playheads) {
      playhead.setAttribute('fill', 'transparent');
    }
  };

  /**
   * Cleanup - kills all animations and removes playheads
   */
  const cleanup = (): void => {
    for (const [, tl] of activeTweens) {
      if (tl.isActive()) {
        tl.kill();
      }
    }
    activeTweens.clear();

    for (const [, playhead] of playheads) {
      if (playhead && playhead.parentNode === svgElement) {
        svgElement.removeChild(playhead);
      }
    }
    playheads.clear();

    envelopePoints = [];
  };

  return {
    triggerPlayAnimation,
    releaseAnimation,
    refreshPlayingAnimations,
    hideAllPlayheads,
    refreshSustainPoint,
    cleanup,
  };
};

// export interface PlayheadManager {
//   triggerPlayAnimation: (msg: AnimationMessage, envelopeType: string) => void;
//   releaseAnimation: (msg: AnimationMessage) => void;
//   refreshPlayingAnimations: () => void;
//   hideAllPlayheads: () => void;
//   setSustainPoint: (x: number, y: number) => void; // Pass coordinates
//   cleanup: () => void;
// }

// /**
//  * Creates a playhead animation manager for envelope visualization
//  */
// export const Playheads = (
//   svgElement: SVGSVGElement,
//   envelopePath: SVGPathElement,
//   isEnabled: State<boolean>,
//   currentDurationSeconds: State<number>,
//   currentEase: State<string | null>,
//   maxDurationSeconds: State<number>,
//   svgWidth: number = 400,
//   multiColorPlayheads: boolean = true
// ): PlayheadManager => {
//   const activeTweens: Map<number, gsap.core.Tween> = new Map();
//   const playheads: Map<number, SVGCircleElement> = new Map();
//   const easeCache = new Map<string, string>();

//   // Sustain state
//   let sustainPoint: { x: number; y: number } | null = null;
//   const sustainProgressCache = new Map<number, number>(); // Cache sustain progress per voice

//   // Generate note colors for multi-colored playheads
//   let noteColor: string | Record<number, string>;
//   if (multiColorPlayheads) {
//     noteColor = generateMidiNoteColors('none', [40, 90], true);
//   } else {
//     noteColor = 'red';
//   }

//   /**
//    * Creates a playhead circle element
//    */
//   const createPlayhead = (voiceId: number): SVGCircleElement => {
//     const circle = document.createElementNS(
//       'http://www.w3.org/2000/svg',
//       'circle'
//     );
//     circle.setAttribute('id', `playhead-${voiceId}`);
//     circle.setAttribute('cx', '2.5');
//     circle.setAttribute('cy', '197.5');
//     circle.setAttribute('r', '5');
//     circle.setAttribute('fill', 'transparent');
//     circle.setAttribute('stroke-width', '2');
//     circle.setAttribute('class', 'playhead');
//     circle.setAttribute('tabIndex', '-1');
//     circle.style.pointerEvents = 'none';
//     return circle;
//   };

//   /**
//    * Creates a time-based ease from the envelope path
//    */
//   const createTimeBasedEase = (pathElement: SVGPathElement): string | null => {
//     if (!envelope.isEnabled) return null;

//     const pathData = pathElement.getAttribute('d');
//     if (!pathData?.length) return null;

//     // Include maxDuration in cache key so ease updates when duration changes
//     const cacheKey = `ease-${pathData}-${maxenvelope.fullDuration}`;
//     if (easeCache.has(cacheKey)) {
//       return easeCache.get(cacheKey) || null;
//     }

//     try {
//       const pathLength = pathElement.getTotalLength();
//       const numSamples = 50;
//       const samples = [];

//       // Sample the path by progress (0 to 1)
//       for (let i = 0; i <= numSamples; i++) {
//         const progress = i / numSamples;
//         const distance = progress * pathLength;
//         const pt = pathElement.getPointAtLength(distance);
//         // Use actual maxDuration and svgWidth for accurate time mapping
//         const time =
//           ((pt.x / svgWidth) * maxenvelope.fullDuration) / maxenvelope.fullDuration; // Normalize to [0,1]
//         samples.push({ progress, time });
//       }

//       // For each target time, find the closest sample
//       const easePoints = [];
//       const numEasePoints = 10;
//       for (let i = 0; i <= numEasePoints; i++) {
//         const targetTime = i / numEasePoints;
//         let closest = samples[0];
//         for (const s of samples) {
//           if (
//             Math.abs(s.time - targetTime) < Math.abs(closest.time - targetTime)
//           ) {
//             closest = s;
//           }
//         }
//         easePoints.push({ x: targetTime, y: closest.progress });
//       }

//       // Build the ease path string
//       let pathStr = `M${easePoints[0].x},${easePoints[0].y}`;
//       for (let i = 1; i < easePoints.length; i++) {
//         pathStr += ` L${easePoints[i].x},${easePoints[i].y}`;
//       }

//       const easeName = `timeCorrection-${Date.now()}-${maxenvelope.fullDuration}`;
//       CustomEase.create(easeName, pathStr);
//       easeCache.set(cacheKey, easeName);

//       return easeName;
//     } catch (e) {
//       console.warn('Failed to create time-based ease:', e);
//       return null;
//     }
//   };
//   /**
//    * Helper function to find progress along path for given coordinates
//    */
//   const findProgressForCoordinates = (x: number, y: number): number => {
//     const pathLength = envelopePath.getTotalLength();
//     let sustainProgress = 0;
//     let minDistance = Infinity;

//     for (let i = 0; i <= 100; i++) {
//       const progress = i / 100;
//       const point = envelopePath.getPointAtLength(progress * pathLength);
//       const distance = Math.sqrt(
//         Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
//       );
//       if (distance < minDistance) {
//         minDistance = distance;
//         sustainProgress = progress;
//       }
//     }

//     return sustainProgress;
//   };

//   const setSustainPoint = (x: number, y: number): void => {
//     sustainPoint = { x, y };
//     // Clear cache when sustain point changes
//     sustainProgressCache.clear();
//   };

//   const triggerPlayAnimation = (
//     msg: AnimationMessage,
//     envelopeType: string
//   ): void => {
//     if (!envelope.isEnabled) return;

//     // Kill existing animation for this voice
//     if (activeTweens.has(msg.voiceId)) {
//       const existing = activeTweens.get(msg.voiceId);
//       if (existing && existing.isActive()) {
//         existing.kill();
//       }
//       activeTweens.delete(msg.voiceId);
//     }

//     if (!msg.envDurations[envelopeType]) return;

//     const envDuration =
//       msg.envDurations[envelopeType] ?? currentenvelope.fullDuration;

//     // Create and add playhead
//     const playhead = createPlayhead(msg.voiceId);
//     svgElement.appendChild(playhead);

//     const isLoopingEnv = msg.loopEnabled?.[envelopeType] ?? false;
//     const easeToUse = currentEase.val || 'none';
//     const color = multiColorPlayheads
//       ? (noteColor as Record<number, string>)[msg.midiNote] || 'red'
//       : 'red';

//     if (sustainPoint) {
//       // Calculate sustain progress and cache it
//       const sustainProgress = findProgressForCoordinates(
//         sustainPoint.x,
//         sustainPoint.y
//       );
//       sustainProgressCache.set(msg.voiceId, sustainProgress);

//       // Phase 1: Animate to sustain point
//       const tween = gsap.to(playhead, {
//         motionPath: {
//           path: envelopePath,
//           align: envelopePath,
//           alignOrigin: [0.5, 0.5],
//           start: 0,
//           end: sustainProgress,
//         },
//         duration: envDuration * sustainProgress,
//         ease: 'none', //easeToUse,
//         onStart: () => playhead.setAttribute('fill', color),
//       });

//       activeTweens.set(msg.voiceId, tween);
//     } else {
//       // No sustain: normal full animation
//       const tween = gsap.to(playhead, {
//         motionPath: {
//           path: envelopePath,
//           align: envelopePath,
//           alignOrigin: [0.5, 0.5],
//         },
//         duration: envDuration,
//         repeat: isLoopingEnv ? -1 : 0,
//         ease: 'none', //easeToUse,
//         onStart: () => playhead.setAttribute('fill', color),
//         onComplete: () => playhead.setAttribute('fill', 'transparent'),
//       });

//       activeTweens.set(msg.voiceId, tween);
//     }

//     playheads.set(msg.voiceId, playhead);
//   };

//   const releaseAnimation = (msg: AnimationMessage): void => {
//     if (!envelope.isEnabled) return;

//     const tween = activeTweens.get(msg.voiceId);
//     const playhead = playheads.get(msg.voiceId);
//     const sustainProgress = sustainProgressCache.get(msg.voiceId);

//     if (tween && playhead && sustainPoint && sustainProgress !== undefined) {
//       // Kill the sustain tween
//       tween.kill();

//       // Phase 2: Continue from sustain point to end
//       const remainingProgress = 1 - sustainProgress;
//       const totalDuration = currentenvelope.fullDuration;
//       const remainingDuration = totalDuration * remainingProgress;

//       const releaseTween = gsap.to(playhead, {
//         motionPath: {
//           path: envelopePath,
//           align: envelopePath,
//           alignOrigin: [0.5, 0.5],
//           start: sustainProgress,
//           end: 1,
//         },
//         duration: remainingDuration,
//         ease: currentEase.val || 'none',
//         onComplete: () => {
//           playhead.setAttribute('fill', 'transparent');
//           // Cleanup
//           if (playhead.parentNode === svgElement) {
//             svgElement.removeChild(playhead);
//           }
//           activeTweens.delete(msg.voiceId);
//           playheads.delete(msg.voiceId);
//           sustainProgressCache.delete(msg.voiceId);
//         },
//       });

//       activeTweens.set(msg.voiceId, releaseTween);
//     } else {
//       // No sustain or already finished - just cleanup
//       if (tween && tween.isActive()) {
//         tween.kill();
//       }
//       if (playhead && playhead.parentNode === svgElement) {
//         svgElement.removeChild(playhead);
//       }
//       activeTweens.delete(msg.voiceId);
//       playheads.delete(msg.voiceId);
//       sustainProgressCache.delete(msg.voiceId);
//     }
//   };

//   const refreshPlayingAnimations = (): void => {
//     if (!envelope.isEnabled) return;

//     // Always refresh the ease when this is called
//     refreshTimeBasedEase();

//     for (const [voiceId, tween] of activeTweens) {
//       if (tween.isActive()) {
//         const totalTime = tween.time();
//         const tweenDuration = (tween.vars.duration as number) ?? 0;
//         const playhead = playheads.get(voiceId);
//         const cachedSustainProgress = sustainProgressCache.get(voiceId);

//         if (playhead) {
//           // Kill the old tween
//           tween.kill();

//           if (sustainPoint && cachedSustainProgress !== undefined) {
//             // Recalculate sustain progress for updated path
//             const newSustainProgress = findProgressForCoordinates(
//               sustainPoint.x,
//               sustainPoint.y
//             );
//             sustainProgressCache.set(voiceId, newSustainProgress);

//             // Determine if we're in sustain phase or release phase
//             const sustainDuration =
//               currentenvelope.fullDuration * newSustainProgress;
//             const isInSustainPhase = totalTime <= sustainDuration;

//             if (isInSustainPhase) {
//               // Recreate sustain phase
//               const newTween = gsap.to(playhead, {
//                 motionPath: {
//                   path: envelopePath,
//                   align: envelopePath,
//                   alignOrigin: [0.5, 0.5],
//                   start: 0,
//                   end: newSustainProgress,
//                 },
//                 duration: sustainDuration,
//                 ease: currentEase.val || 'none',
//                 onStart: () => playhead.setAttribute('fill', 'red'),
//               });

//               newTween.time(totalTime);
//               activeTweens.set(voiceId, newTween);
//             } else {
//               // Recreate release phase
//               const remainingProgress = 1 - newSustainProgress;
//               const remainingDuration =
//                 currentenvelope.fullDuration * remainingProgress;
//               const releaseTime = totalTime - sustainDuration;

//               const newTween = gsap.to(playhead, {
//                 motionPath: {
//                   path: envelopePath,
//                   align: envelopePath,
//                   alignOrigin: [0.5, 0.5],
//                   start: newSustainProgress,
//                   end: 1,
//                 },
//                 duration: remainingDuration,
//                 ease: currentEase.val || 'none',
//                 onStart: () => playhead.setAttribute('fill', 'red'),
//                 onComplete: () => playhead.setAttribute('fill', 'transparent'),
//               });

//               newTween.time(releaseTime);
//               activeTweens.set(voiceId, newTween);
//             }
//           } else {
//             // No sustain: recreate normal animation
//             const newTween = gsap.to(playhead, {
//               motionPath: {
//                 path: envelopePath,
//                 align: envelopePath,
//                 alignOrigin: [0.5, 0.5],
//               },
//               duration: currentenvelope.fullDuration,
//               ease: currentEase.val || 'none',
//               onStart: () => playhead.setAttribute('fill', 'red'),
//               onComplete: () => playhead.setAttribute('fill', 'transparent'),
//             });

//             newTween.time(totalTime);
//             activeTweens.set(voiceId, newTween);
//           }
//         }
//       }
//     }
//   };

//   /**
//    * Forces a refresh of the time-based ease (call when path or duration changes)
//    */
//   const refreshTimeBasedEase = (): void => {
//     const newEase = createTimeBasedEase(envelopePath);
//     if (newEase !== currentEase.val) {
//       currentEase.val = newEase;
//     }
//   };

//   /**
//    * Hides all playheads (makes them transparent)
//    */
//   const hideAllPlayheads = (): void => {
//     for (const [, playhead] of playheads) {
//       playhead.setAttribute('fill', 'transparent');
//     }
//   };

//   /**
//    * Cleanup - kills all animations and removes playheads
//    */
//   const cleanup = (): void => {
//     // Kill all tweens
//     for (const [, tween] of activeTweens) {
//       if (tween.isActive()) {
//         tween.kill();
//       }
//     }
//     activeTweens.clear();

//     // Remove all playheads
//     for (const [, playhead] of playheads) {
//       if (playhead && playhead.parentNode === svgElement) {
//         svgElement.removeChild(playhead);
//       }
//     }
//     playheads.clear();

//     // Clear ease cache
//     easeCache.clear();
//   };

//   return {
//     triggerPlayAnimation,
//     releaseAnimation,
//     refreshPlayingAnimations,
//     hideAllPlayheads,
//     setSustainPoint,
//     cleanup,
//   };
// };

// /**
//  * Triggers a playhead animation for a voice
//  */
// const triggerPlayAnimation = (
//   msg: AnimationMessage,
//   envelopeType: string
// ): void => {
//   if (!envelope.isEnabled) return;

//   // Kill existing animation for this voice
//   if (activeTweens.has(msg.voiceId)) {
//     const existing = activeTweens.get(msg.voiceId);
//     if (existing && existing.isActive()) {
//       existing.kill();
//     }
//     activeTweens.delete(msg.voiceId);
//   }

//   // Check if we have duration for this envelope type
//   if (!msg.envDurations[envelopeType]) return;

//   const envDuration =
//     msg.envDurations[envelopeType] ?? currentenvelope.fullDuration;

//   // Update current duration if needed
//   if (currentenvelope.fullDuration !== envDuration) {
//     currentenvelope.fullDuration = envDuration;
//   }

//   // Create and add playhead
//   const playhead = createPlayhead(msg.voiceId);
//   svgElement.appendChild(playhead);

//   const isLoopingEnv = msg.loopEnabled?.[envelopeType] ?? false;
//   const easeToUse = currentEase.val || 'none';
//   const color = multiColorPlayheads
//     ? (noteColor as Record<number, string>)[msg.midiNote] || 'red'
//     : 'red';

//   // Create GSAP animation
//   const newTween = gsap.to(playhead, {
//     id: msg.voiceId,
//     motionPath: {
//       path: envelopePath,
//       align: envelopePath,
//       alignOrigin: [0.5, 0.5],
//     },
//     duration: envDuration,
//     repeat: isLoopingEnv ? -1 : 0,
//     ease: 'none', //easeToUse,
//     onStart: () => playhead.setAttribute('fill', color),
//     onComplete: () => playhead.setAttribute('fill', 'transparent'),
//   });

//   // Store references
//   playheads.set(msg.voiceId, playhead);
//   activeTweens.set(msg.voiceId, newTween);
// };

// /**
//  * Releases/stops animation for a voice
//  */
// const releaseAnimation = (msg: AnimationMessage): void => {
//   if (!envelope.isEnabled) return;

//   // Kill the tween
//   if (activeTweens.has(msg.voiceId)) {
//     const existing = activeTweens.get(msg.voiceId);
//     if (existing && existing.isActive()) {
//       existing.kill();
//     }
//     activeTweens.delete(msg.voiceId);
//   }

//   // Remove the playhead
//   if (playheads.has(msg.voiceId)) {
//     const head = playheads.get(msg.voiceId);
//     if (head && head.parentNode === svgElement) {
//       svgElement.removeChild(head);
//     }
//     playheads.delete(msg.voiceId);
//   }
// };

// /**
//  * Refreshes all currently playing animations (useful when path changes)
//  */
// const refreshPlayingAnimations = (): void => {
//   if (!envelope.isEnabled) return;

//   // Always refresh the ease when this is called
//   refreshTimeBasedEase();

//   for (const [voiceId, tween] of activeTweens) {
//     if (tween.isActive()) {
//       const totalTime = tween.time(); // Capture absolute time
//       const tweenDuration = (tween.vars.duration as number) ?? 0;
//       const isLoopingEnv = tween.vars.repeat === -1;
//       const currentDuration = currentenvelope.fullDuration;

//       // Check if duration changed for looping animations
//       const durationChanged =
//         Math.abs(currentDuration - tweenDuration) > 0.001;
//       const shouldUpdateDuration = isLoopingEnv && durationChanged;

//       // Kill the old tween
//       tween.kill();

//       const playhead = playheads.get(voiceId);
//       if (playhead) {
//         // Create new tween with updated path/duration
//         const newTween = gsap.to(playhead, {
//           motionPath: {
//             path: envelopePath, // Always update path
//             align: envelopePath,
//             alignOrigin: [0.5, 0.5],
//           },
//           duration: shouldUpdateDuration ? currentDuration : tweenDuration,
//           repeat: isLoopingEnv ? -1 : 0,
//           ease: currentEase.val || 'none',
//           onStart: () => playhead.setAttribute('fill', 'red'),
//           onComplete: () => playhead.setAttribute('fill', 'transparent'),
//         });

//         // Restore absolute time position
//         newTween.time(totalTime);
//         activeTweens.set(voiceId, newTween);
//       }
//     }
//   }
// };
