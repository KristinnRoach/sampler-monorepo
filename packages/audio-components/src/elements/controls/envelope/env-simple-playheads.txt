import { CustomEnvelope, EnvelopeType, SamplePlayer } from '@repo/audiolib';
import { generateMidiNoteColors } from '../../../utils/generateColors';
import { gsap, MotionPathPlugin, CustomEase } from 'gsap/all';

gsap.registerPlugin(MotionPathPlugin, CustomEase);

export interface PlayheadManager {
  cleanup: () => void;
}

export const createSimplePlayheads = (
  svgElement: SVGSVGElement,
  pointsGroup: SVGGElement,
  envelope: CustomEnvelope,
  instrument: SamplePlayer,
  envType: EnvelopeType,
  svgWidth: number = 400
): PlayheadManager => {
  const activeAnimations = new Map<string, gsap.core.Timeline>();
  const playheads = new Map<string, SVGCircleElement>();

  const colors = generateMidiNoteColors('none', [40, 90], true);

  // Get actual coordinates from rendered control points
  const getPointCoordinates = (): Array<{ x: number; y: number }> => {
    const circles = Array.from(pointsGroup.querySelectorAll('circle'));
    return circles.map((circle) => ({
      x: parseFloat(circle.getAttribute('cx') || '0'),
      y: parseFloat(circle.getAttribute('cy') || '0'),
    }));
  };

  // Create playhead element
  const createPlayhead = (
    voiceId: string,
    midiNote: number
  ): SVGCircleElement => {
    const circle = document.createElementNS(
      'http://www.w3.org/2000/svg',
      'circle'
    );
    circle.setAttribute('r', '5');
    circle.setAttribute('fill', colors[midiNote]);
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '2');
    circle.style.pointerEvents = 'none';
    return circle;
  };

  // Listen to envelope messages
  const unsubscribe = instrument.onMessage(`${envType}:trigger`, (msg) => {
    if (!msg.voiceId) return;

    const { voiceId, midiNote = 60, duration, sustainEnabled } = msg;

    // Clean up existing animation
    stopAnimation(voiceId);

    // Create new playhead
    const playhead = createPlayhead(voiceId, midiNote);
    svgElement.appendChild(playhead);
    playheads.set(voiceId, playhead);

    // Get current point coordinates
    const pointCoords = getPointCoordinates();
    if (pointCoords.length === 0) return;

    const tl = gsap.timeline();

    if (sustainEnabled && envelope.sustainPointIndex !== null) {
      const sustainIndex = envelope.sustainPointIndex;

      if (sustainIndex < pointCoords.length) {
        const sustainCoord = pointCoords[sustainIndex];

        // Phase 1: Animate through points to sustain point
        tl.to(playhead, {
          motionPath: {
            path: pointCoords
              .slice(0, sustainIndex + 1)
              .map((coord, i) =>
                i === 0 ? `M${coord.x},${coord.y}` : `L${coord.x},${coord.y}`
              )
              .join(' '),
            autoRotate: false,
          },
          duration: duration,
          ease: 'none',
          onComplete: () => {
            tl.pause(); // Wait for release
          },
        });
        // Phase 2: Continue from release point to end
        const releaseIndex = envelope.releasePointIndex;
        if (releaseIndex < pointCoords.length - 1) {
          tl.to(playhead, {
            motionPath: {
              path: pointCoords
                .slice(releaseIndex)
                .map((coord, i) =>
                  i === 0 ? `M${coord.x},${coord.y}` : `L${coord.x},${coord.y}`
                )
                .join(' '),
              autoRotate: false,
            },
            duration: envelope.releaseTime, // Use the calculated release time
            ease: 'none',
            onComplete: () => {
              stopAnimation(voiceId);
            },
          });
        }
      }
      //     // Phase 2: Continue from sustain to end
      //     if (sustainIndex < pointCoords.length - 1) {
      //       tl.to(playhead, {
      //         motionPath: {
      //           path: pointCoords
      //             .slice(sustainIndex)
      //             .map((coord, i) =>
      //               i === 0 ? `M${coord.x},${coord.y}` : `L${coord.x},${coord.y}`
      //             )
      //             .join(' '),
      //           autoRotate: false,
      //         },
      //         duration:
      //           (envelope.fullDuration - envelope.points[sustainIndex].time) /
      //           envelope.timeScale,
      //         ease: 'none',
      //         onComplete: () => {
      //           stopAnimation(voiceId);
      //         },
      //       });
      //     }
      //   }
    } else {
      // No sustain: animate through all points
      tl.to(playhead, {
        motionPath: {
          path: pointCoords
            .map((coord, i) =>
              i === 0 ? `M${coord.x},${coord.y}` : `L${coord.x},${coord.y}`
            )
            .join(' '),
          autoRotate: false,
        },
        duration: duration,
        ease: 'none',
        onComplete: () => {
          stopAnimation(voiceId);
        },
      });
    }

    activeAnimations.set(voiceId, tl);
  });

  const unsubscribeRelease = instrument.onMessage(
    `${envType}:release`,
    (msg) => {
      if (!msg.voiceId) return;

      const tl = activeAnimations.get(msg.voiceId);
      const playhead = playheads.get(msg.voiceId);

      if (tl && playhead) {
        // Always jump to release point and continue to end
        const pointCoords = getPointCoordinates();
        const releaseIndex = envelope.releasePointIndex;

        if (releaseIndex < pointCoords.length) {
          const releaseCoord = pointCoords[releaseIndex];
          gsap.set(playhead, { x: releaseCoord.x, y: releaseCoord.y });

          // Kill current animation and start release phase
          tl.kill();
          const newTl = gsap.timeline();
          newTl.to(playhead, {
            motionPath: {
              path: pointCoords
                .slice(releaseIndex)
                .map((coord, i) =>
                  i === 0 ? `M${coord.x},${coord.y}` : `L${coord.x},${coord.y}`
                )
                .join(' '),
            },
            duration: envelope.releaseTime,
            ease: 'none',
            onComplete: () => stopAnimation(msg.voiceId),
          });
          activeAnimations.set(msg.voiceId, newTl);
        }
      }
    }
  );

  const stopAnimation = (voiceId: string) => {
    const tl = activeAnimations.get(voiceId);
    const playhead = playheads.get(voiceId);

    if (tl) {
      tl.kill();
      activeAnimations.delete(voiceId);
    }

    if (playhead && playhead.parentNode === svgElement) {
      svgElement.removeChild(playhead);
      playheads.delete(voiceId);
    }
  };

  return {
    cleanup: () => {
      unsubscribe();
      unsubscribeRelease();
      [...activeAnimations.keys()].forEach(stopAnimation);
    },
  };
};
