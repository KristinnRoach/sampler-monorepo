// EnvelopeSVG.ts
import van, { State } from '@repo/vanjs-core';
import type { EnvelopePoint, EnvelopeType } from '@repo/audiolib';
import { generateMidiNoteColors } from '../../utils/generateColors';
import { gsap, MotionPathPlugin, DrawSVGPlugin, CustomEase } from 'gsap/all';
import { defineElement } from '../elementRegistry.ts';
import {
  KnobElement,
  type KnobChangeEventDetail,
} from '../primitives/KnobElement.ts';

gsap.registerPlugin(MotionPathPlugin, DrawSVGPlugin, CustomEase);

const { div, button } = van.tags;

const { svg, path, line, g, circle } = van.tags('http://www.w3.org/2000/svg');

export interface EnvelopeSVG {
  element: Element | SVGSVGElement;
  triggerPlayAnimation: (msg: any) => void;
  releaseAnimation: (msg: any) => void;
  updateMaxDuration: (seconds: number) => void;
  updateEnvelopeDuration: (seconds: number) => void;
  drawWaveform: (audiobuffer: AudioBuffer) => void;
  cleanup: () => void;
}

export const EnvelopeSVG = (
  envelopeType: EnvelopeType,
  initialPoints: EnvelopePoint[],
  maxDurationSeconds: State<number>,
  onPointUpdate: (
    envType: EnvelopeType,
    index: number,
    time: number,
    value: number
  ) => void,
  onEnable: (envType: EnvelopeType) => void,
  onDisable: (envType: EnvelopeType) => void,
  onLoopChange: (envType: EnvelopeType, enabled: boolean) => void,
  onSyncChange: (envType: EnvelopeType, enabled: boolean) => void,
  width: string = '100%',
  height: string = '120px',
  snapToValues: { y?: number[]; x?: number[] } = { y: [0], x: [0, 1] },
  snapThreshold = 0.025,
  enabled = true,
  initialLoopState = false,
  multiColorPlayheads = true,
  setEnvelopeTimeScale?: (envType: EnvelopeType, timeScale: number) => void // ! Testing
): EnvelopeSVG => {
  if (!initialPoints.length) {
    const emptyDiv = div(
      {
        style: `width: ${width}; height: ${height}; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666;`,
      },
      'No envelope data'
    );
    return {
      element: emptyDiv,
      triggerPlayAnimation: () => {},
      releaseAnimation: () => {},
      updateMaxDuration: () => {},
      updateEnvelopeDuration: () => {},
      drawWaveform: () => {},
      cleanup: () => {},
    };
  }

  const SVG_WIDTH = 400;
  const SVG_HEIGHT = 200;

  let svgElement: SVGSVGElement;
  let pointsGroup: SVGGElement;
  let envelopePath: SVGPathElement;
  let waveformPath: SVGPathElement | null = null;

  const activeTweens: Map<number, gsap.core.Tween> = new Map();
  const playheads: Map<number, Element> = new Map();
  const easeCache = new Map<string, string>(); // ease key -> ease name

  let noteColor: string | Record<number, string>;
  if (multiColorPlayheads)
    noteColor = generateMidiNoteColors('none', [40, 90], true);
  else noteColor = 'red';

  // UI states
  const isEnabled = van.state(enabled);
  const isLooping = van.state(initialLoopState);
  const syncToPlaybackRate = van.state(false);

  const currentDurationSeconds = van.state(maxDurationSeconds.rawVal);

  const selectedPoint = van.state<number | null>(null);
  const isDragging = van.state(false);
  const points = van.state([...initialPoints]);
  const currentEase = van.state<string | null>(null);

  const timeToScreenX = (timeInSeconds: number): number => {
    return (timeInSeconds / maxDurationSeconds.val) * SVG_WIDTH;
  };

  // Helper to generate SVG path from points
  const generateSVGPath = (pts: EnvelopePoint[]): string => {
    if (pts.length < 2) return `M0,200 L400,200`;

    const sortedPoints = [...pts].sort((a, b) => a.time - b.time);
    // let path = `M${(sortedPoints[0].time / maxDurationSeconds.val) * SVG_WIDTH},${(1 - sortedPoints[0].value) * SVG_HEIGHT}`;
    let path = `M${sortedPoints[0].time * SVG_WIDTH},${(1 - sortedPoints[0].value) * SVG_HEIGHT}`;

    for (let i = 1; i < sortedPoints.length; i++) {
      const point = sortedPoints[i];
      const prevPoint = sortedPoints[i - 1];

      // const x = (point.time / maxDurationSeconds.val) * SVG_WIDTH;
      // const x = point.time * SVG_WIDTH;
      const x = timeToScreenX(point.time);
      const y = (1 - point.value) * SVG_HEIGHT;

      if (prevPoint.curve === 'exponential') {
        // const prevX = (prevPoint.time / maxDurationSeconds.val) * SVG_WIDTH;
        // const prevX = prevPoint.time * SVG_WIDTH;
        const prevX = timeToScreenX(prevPoint.time);
        const prevY = (1 - prevPoint.value) * SVG_HEIGHT;
        const cp1X = prevX + (x - prevX) * 0.3;
        const cp1Y = prevY;
        const cp2X = prevX + (x - prevX) * 0.7;
        const cp2Y = y;
        path += ` C${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
      } else {
        path += ` L${x},${y}`;
      }
    }
    return path;
  };

  // Playback position indicator
  const createPlayhead = (voiceId: string) =>
    circle({
      style: () => `pointer-events: none`,
      id: `playhead-${voiceId}`,
      cx: 2.5,
      cy: 197.5,
      r: 5,
      fill: 'transparent',
      'stroke-width': 2,
      class: 'playhead',
      tabIndex: -1,
    }) as SVGCircleElement;

  let clickCounts: Record<number, number> = {};
  const activeTimeouts = new Set<number>();

  const updateControlPoints = () => {
    if (!pointsGroup) return;

    // Clear all existing timeouts before destroying circles
    activeTimeouts.forEach(clearTimeout);
    activeTimeouts.clear();

    pointsGroup.replaceChildren();

    const pts = points.val;

    pts.forEach((point, index) => {
      const circle = document.createElementNS(
        'http://www.w3.org/2000/svg',
        'circle'
      );

      circle.setAttribute('cx', timeToScreenX(point.time).toString());
      circle.setAttribute('cy', ((1 - point.value) * SVG_HEIGHT).toString());
      circle.setAttribute('r', '4');
      circle.setAttribute(
        'fill',
        selectedPoint.val === index
          ? '#ff6b6b'
          : isEnabled.val
            ? '#4ade80'
            : '#666'
      );
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '1');
      circle.style.cursor = 'pointer';

      // Special case for start/end points
      if (index === 0 || index === pts.length - 1) {
        // Update duration based on time span of envelope points
        const timeSpan = pts[pts.length - 1].time - pts[0].time;

        const newDuration = timeSpan; // * maxDurationSeconds.val; // ! NOT Convert back to seconds

        if (Math.abs(currentDurationSeconds.val - newDuration) > 0.001) {
          currentDurationSeconds.val = newDuration;
        }

        circle.setAttribute('fill', isEnabled.val ? '#ff9500' : '#666'); // Orange for duration handles
        circle.setAttribute('r', '6'); // Slightly bigger
      }

      // Mouse down - start drag
      // Current approach is a somewhat convoluted way to allow using single click
      // for moving a point and double click for adding a point (only one that worked)

      // const activeTimeouts = new Set<number>();
      let clickTimeout: number;

      circle.addEventListener('mousedown', (e: MouseEvent) => {
        if (!isEnabled.val) return;

        const currentCount = (clickCounts[index] || 0) + 1;
        clickCounts = { ...clickCounts, [index]: currentCount };

        // First click - start drag immediately and start timer
        isDragging.val = true;
        selectedPoint.val = index;

        // Clear existing timeout
        clearTimeout(clickTimeout);

        if (currentCount === 1) {
          // 250ms time given to double click
          clickTimeout = setTimeout(() => {
            clickCounts = { ...clickCounts, [index]: 0 };
            activeTimeouts.delete(clickTimeout);
          }, 250);
          activeTimeouts.add(clickTimeout);
        } else if (currentCount === 2) {
          // Second click - delete and stop dragging
          isDragging.val = false;
          if (index > 0 && index < pts.length - 1) {
            const newPoints = points.val.filter((_, i) => i !== index);
            points.val = newPoints;
            onPointUpdate(envelopeType, index, -1, -1);
          }
          clickCounts = { ...clickCounts, [index]: 0 };
        }
        e.preventDefault();
      });

      pointsGroup.appendChild(circle);
    });
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (!isEnabled.val) return;

    if (isDragging.val && selectedPoint.val !== null) {
      const rect = svgElement.getBoundingClientRect();

      let time =
        ((e.clientX - rect.left) / rect.width) * maxDurationSeconds.val;

      let value = Math.max(
        0,
        Math.min(1, 1 - (e.clientY - rect.top) / rect.height)
      );

      const closestSnapY = snapToValues.y?.find(
        (v) => Math.abs(v - value) < snapThreshold
      );

      const closestSnapX = snapToValues.x?.find(
        (v) => Math.abs(v - time) < snapThreshold
      );

      if (closestSnapY) value = closestSnapY;
      if (closestSnapX) time = closestSnapX;

      // Update UI state
      const newPoints = [...points.val];

      newPoints[selectedPoint.val] = {
        ...newPoints[selectedPoint.val],
        time,
        value,
      };

      points.val = newPoints;

      // Update audio logic via callback
      onPointUpdate(envelopeType, selectedPoint.val, time, value);
    }
  };

  const handleMouseUp = () => {
    if (!isEnabled.val) return;

    isDragging.val = false;
    selectedPoint.val = null;
  };

  const handleDoubleClick = (e: MouseEvent) => {
    if (!isEnabled.val) return;
    e.stopPropagation(); // Prevent bubbling

    if (isDragging.val) return;
    const rect = svgElement.getBoundingClientRect();

    const time =
      ((e.clientX - rect.left) / rect.width) * maxDurationSeconds.val;

    const value = Math.max(
      0, // todo: if click is near the current envelope line it should likely be exactly on the line when created
      Math.min(1, 1 - (e.clientY - rect.top) / rect.height)
    );
    // Update UI state
    const newPoint = { time, value, curve: 'exponential' as const };
    const newPoints = [...points.val, newPoint].sort((a, b) => a.time - b.time);
    points.val = newPoints;

    // Update audio logic via callback
    onPointUpdate(envelopeType, -1, time, value);
  };

  // Create SVG element
  svgElement = svg({
    viewBox: `0 0 ${SVG_WIDTH} ${SVG_HEIGHT}`,
    preserveAspectRatio: 'none',
    style: `width: ${width}; height: ${height}; background: #1a1a1a; border: 1px solid #444; border-radius: 4px;`,
  }) as SVGSVGElement;

  const enabledToggleBtn = button({
    style: () => `
    position: absolute; 
    top: 4px; 
    right: 4px; 
    width: 16px; 
    height: 16px; 
    border: none; 
    border-radius: 50%; 
    cursor: pointer; 
    z-index: 10;
    background: ${isEnabled.val ? '#4ade80' : '#666'};
  `,
    title: () => (isEnabled.val ? 'Disable envelope' : 'Enable envelope'),
    onclick: () => {
      isEnabled.val = !isEnabled.val;
    },
  });

  const loopToggleBtn = button({
    style: () => `
    position: absolute; 
    top: 4px; 
    right: 24px; 
    width: 16px; 
    height: 16px; 
    border: none; 
    border-radius: 50%; 
    cursor: pointer; 
    z-index: 10;
    background: ${isLooping.val && isEnabled.val ? '#ff6b6b' : '#666'};
  `,
    title: () => (isLooping.val ? 'Disable looping' : 'Enable looping'),
    onclick: () => {
      isLooping.val = !isLooping.val;
    },
  });

  const syncToPlaybackRateToggleBtn = button({
    style: () => `
    position: absolute; 
    top: 4px; 
    right: 44px;  
    width: 16px; 
    height: 16px; 
    border: none; 
    border-radius: 50%; 
    cursor: pointer; 
    z-index: 10;
    background: ${syncToPlaybackRate.val && isEnabled.val ? '#336bcc' : '#666'};
  `,
    title: () => (syncToPlaybackRate.val ? 'Disable sync' : 'Enable sync'),
    onclick: () => {
      syncToPlaybackRate.val = !syncToPlaybackRate.val;
    },
  });

  // Create container div
  const container = div(
    {
      style: `position: relative; display: inline-block; width: ${width}; height: ${height}; `,
    },
    enabledToggleBtn,
    loopToggleBtn,
    syncToPlaybackRateToggleBtn
  );

  // Manually append the SVG element to avoid namespace issues
  container.appendChild(svgElement);

  // ! === ! TESTING TimeScale ! == (cleanup after!)
  if (setEnvelopeTimeScale !== undefined) {
    defineElement('knob-element', KnobElement);
    const knobElement: HTMLElement = document.createElement('knob-element');
    knobElement.setAttribute('min-value', '1');
    knobElement.setAttribute('max-value', '10'); // Todo: set the scaling (undo the 'curve' used for looppoints)
    knobElement.setAttribute('snap-increment', '0.1');
    knobElement.setAttribute('width', '45');
    knobElement.setAttribute('height', '45');
    knobElement.setAttribute('default-value', '1');
    knobElement.style.marginTop = '10px';
    knobElement.className = 'time-scale';

    (knobElement as HTMLElement).addEventListener(
      'knob-change',
      (e: CustomEvent) => {
        if (!knobElement) return;
        const msg: KnobChangeEventDetail = e.detail;
        setEnvelopeTimeScale(envelopeType, msg.value);
      }
    );
    container.appendChild(knobElement);
  }
  // ! === ! END TESTING TimeScale ! == (cleanup after!)

  // Add event listeners
  svgElement.addEventListener('mousemove', handleMouseMove);
  svgElement.addEventListener('mouseup', handleMouseUp);
  svgElement.addEventListener('mouseleave', handleMouseUp);
  svgElement.addEventListener('dblclick', handleDoubleClick);

  // Grid
  const gridGroup = g(
    { class: 'grid' },
    ...Array.from({ length: 6 }, (_, i) => {
      const x = (i / 5) * SVG_WIDTH;
      return line({
        x1: x,
        y1: 0,
        x2: x,
        y2: SVG_HEIGHT,
        stroke: '#333',
        'stroke-width': 1,
      });
    }),
    ...Array.from({ length: 6 }, (_, i) => {
      const y = (i / 5) * SVG_HEIGHT;
      return line({
        x1: 0,
        y1: y,
        x2: SVG_WIDTH,
        y2: y,
        stroke: '#333',
        'stroke-width': 1,
      });
    })
  );

  // Envelope path
  envelopePath = path({
    id: 'envelope-path',
    d: () => {
      maxDurationSeconds.val; // Dependency
      return generateSVGPath(points.val);
    },
    fill: 'none',
    stroke: () => (isEnabled.val ? '#4ade80' : '#666'),
    'stroke-width': 2,
  }) as SVGPathElement;

  // Control points group
  pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  pointsGroup.setAttribute('class', 'control-points');

  // Assemble SVG
  svgElement.appendChild(gridGroup);
  svgElement.appendChild(envelopePath);
  svgElement.appendChild(pointsGroup);

  // === WAVEFORM ===

  function drawWaveform(audiobuffer: AudioBuffer) {
    // Remove previous waveform path if it exists
    if (waveformPath && waveformPath.parentNode === svgElement) {
      svgElement.removeChild(waveformPath);
      waveformPath = null;
    }

    const waveformSVGData = getWaveformSVGData(
      audiobuffer,
      SVG_WIDTH,
      SVG_HEIGHT
    );

    waveformPath = path({
      id: 'waveform-path',
      d: waveformSVGData.trim(),
      fill: 'none',
      stroke: () => (isEnabled.val ? '#3467bc' : '#333'),
      'stroke-width': 1,
    }) as SVGPathElement;

    svgElement.appendChild(waveformPath);
  }

  // === ANIMATION ===

  function createTimeBasedEase(pathElement: SVGPathElement): string | null {
    if (!isEnabled.val) return null;

    const pathData = pathElement.getAttribute('d');
    if (!pathData) return null;

    const cacheKey = `ease-${pathData}`;
    if (easeCache.has(cacheKey)) return easeCache.get(cacheKey) || null;

    try {
      const pathLength = pathElement.getTotalLength();
      const numSamples = 50;
      const samples = [];

      // Sample the path by progress (0 to 1)
      for (let i = 0; i <= numSamples; i++) {
        const progress = i / numSamples;
        const distance = progress * pathLength;
        const pt = pathElement.getPointAtLength(distance);
        const time = pt.x / SVG_WIDTH; // Map x to [0,1] time
        samples.push({ progress, time });
      }

      // For each target time, find the closest sample (monotonic in x)
      const easePoints = [];
      const numEasePoints = 10;
      for (let i = 0; i <= numEasePoints; i++) {
        const targetTime = i / numEasePoints;
        let closest = samples[0];
        for (const s of samples) {
          if (
            Math.abs(s.time - targetTime) < Math.abs(closest.time - targetTime)
          ) {
            closest = s;
          }
        }
        easePoints.push({ x: targetTime, y: closest.progress });
      }

      // Build the ease path string
      let pathStr = `M${easePoints[0].x},${easePoints[0].y}`;
      for (let i = 1; i < easePoints.length; i++) {
        pathStr += ` L${easePoints[i].x},${easePoints[i].y}`;
      }

      const easeName = `timeCorrection-${Date.now()}`;
      CustomEase.create(easeName, pathStr);
      easeCache.set(cacheKey, easeName);

      return easeName;
    } catch (e) {
      console.warn('Failed to create time-based ease:', e);
      return null;
    }
  }

  function triggerPlayAnimation(msg: any) {
    if (!isEnabled.val) return;

    if (activeTweens.has(msg.voiceId)) {
      const existing = activeTweens.get(msg.voiceId);
      existing && existing.isActive() && existing.kill();
      activeTweens.delete(msg.voiceId);
    }

    if (!msg.envDurations[envelopeType]) return;

    const envDuration =
      msg.envDurations[envelopeType] ?? currentDurationSeconds.val;

    if (currentDurationSeconds.val !== envDuration)
      currentDurationSeconds.val = envDuration;

    const playhead = createPlayhead(msg.voiceId);
    svgElement.appendChild(playhead);

    const isLoopingEnv = msg.loopEnabled?.[envelopeType] ?? false;
    // const isLoopingEnv = isLooping.val;

    const easeToUse = currentEase.val ? currentEase.val : 'none';
    const color = multiColorPlayheads ? noteColor[msg.midiNote] : 'red';

    const newTween = gsap.to(playhead, {
      id: msg.voiceId,
      motionPath: {
        path: envelopePath,
        align: envelopePath,
        alignOrigin: [0.5, 0.5],
      },
      duration: envDuration,
      repeat: isLoopingEnv ? -1 : 0,
      ease: easeToUse,
      onStart: () => playhead.setAttribute('fill', color),
      onComplete: () => playhead.setAttribute('fill', 'transparent'),
    });

    playheads.set(msg.voiceId, playhead);
    activeTweens.set(msg.voiceId, newTween);
  }

  function releaseAnimation(msg: any) {
    if (!isEnabled.val) return;

    if (activeTweens.has(msg.voiceId)) {
      const existing = activeTweens.get(msg.voiceId);
      existing && existing.isActive() && existing.kill();
      activeTweens.delete(msg.voiceId);
    }
    if (playheads.has(msg.voiceId)) {
      const head = playheads.get(msg.voiceId);
      if (head && head.parentNode === svgElement) {
        svgElement.removeChild(head);
      }
      playheads.delete(msg.voiceId);
    }
  }

  function refreshPlayingAnimations() {
    if (!isEnabled.val) return;

    for (let [voiceId, tween] of activeTweens) {
      if (tween.isActive()) {
        // const progress = tween.progress();
        const totalTime = tween.time(); // <--- Capture absolute time
        const isLoopingEnv = isLooping.val;
        // tween.vars.repeat === -1;
        const tweenDuration = (tween.vars.duration as number) ?? 0;

        const currentDuration = currentDurationSeconds.val;

        // Always update path, but only update duration for loops if it changed
        const durationChanged =
          Math.abs(currentDuration - tweenDuration) > 0.001;
        const shouldUpdateDuration = isLoopingEnv && durationChanged;

        tween.kill();

        const playhead = playheads.get(voiceId);
        if (playhead) {
          const newTween = gsap.to(playhead, {
            motionPath: {
              path: envelopePath, // Always update path
              align: envelopePath,
              alignOrigin: [0.5, 0.5],
            },
            duration: shouldUpdateDuration ? currentDuration : tweenDuration,
            repeat: isLoopingEnv ? -1 : 0,
            ease: currentEase.val || 'none',
            onStart: () => playhead.setAttribute('fill', 'red'),
            onComplete: () => playhead.setAttribute('fill', 'transparent'),
          });

          // newTween.progress(progress);
          newTween.time(totalTime); // <--- Restore absolute time
          activeTweens.set(voiceId, newTween);
        }
      }
    }
  }

  const killAllTweens = () => {
    for (let [voiceId, tween] of activeTweens) {
      // Kill all active tweens
      if (tween.isActive()) tween.kill();
    }
    activeTweens.clear();

    for (let [voiceId, playhead] of playheads) {
      if (playhead && playhead.parentNode === svgElement) {
        svgElement.removeChild(playhead); // Remove all playheads
      }
    }
    playheads.clear();
  };

  const hideAllPlayheads = () => {
    for (let [voiceId, playhead] of playheads) {
      playhead.setAttribute('fill', 'transparent');
    }
  };

  const updateMaxDuration = (seconds: number) => {
    if (seconds !== maxDurationSeconds.val) maxDurationSeconds.val = seconds;
  };

  const updateEnvelopeDuration = (seconds: number) => {
    if (seconds !== currentDurationSeconds.val)
      currentDurationSeconds.val = seconds;
  };

  // 1. First derive: Update duration and points when maxDurationSeconds changes
  let previousMaxDuration = maxDurationSeconds.val; // Track previous value

  van.derive(() => {
    const newMaxDuration = maxDurationSeconds.val;
    currentDurationSeconds.val = newMaxDuration;

    // Scale existing points proportionally
    const scalingRatio = newMaxDuration / previousMaxDuration;
    const scaledPoints = points.val.map((pt) => ({
      ...pt,
      time: pt.time * scalingRatio,
    }));

    points.val = scaledPoints;
    previousMaxDuration = newMaxDuration; // Update for next time
  });

  // 2. Second derive: Update UI when points, selection, or duration changes
  van.derive(() => {
    points.val;
    selectedPoint.val;
    maxDurationSeconds.val;

    updateControlPoints();

    setTimeout(() => {
      points.val = initialPoints;
      currentEase.val = createTimeBasedEase(envelopePath);
      refreshPlayingAnimations();
    }, 0);
  });

  van.derive(() => {
    onLoopChange(envelopeType, isLooping.val);
  });

  van.derive(() => {
    onSyncChange(envelopeType, syncToPlaybackRate.val);
  });

  van.derive(() => {
    if (!isEnabled.val) {
      hideAllPlayheads();
      onDisable(envelopeType);
    } else {
      onEnable(envelopeType);
    }
  });

  return {
    element: container,
    triggerPlayAnimation,
    releaseAnimation,
    updateMaxDuration,
    updateEnvelopeDuration,
    drawWaveform,
    cleanup: () => {
      killAllTweens();
      activeTimeouts.forEach(clearTimeout);
      if (waveformPath && waveformPath.parentNode === svgElement) {
        svgElement.removeChild(waveformPath);
      }
    },
  };
};

function getWaveformSVGData(
  audiobuffer: AudioBuffer,
  width: number,
  height: number
): string {
  if (!audiobuffer.length) return '';

  const channelData = audiobuffer.getChannelData(0);
  const step = Math.ceil(channelData.length / width);
  let path = '';

  for (let i = 0; i < width; i++) {
    const idx = i * step;
    const v = channelData[idx] || 0;
    const y = (1 - (v + 1) / 2) * height;
    path += (i === 0 ? 'M' : 'L') + `${i},${y} `;
  }

  return path;
}
