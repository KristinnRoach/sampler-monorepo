// SampleControls - Vanilla TypeScript version
import { KnobElement } from '../primitives/KnobElement';

interface SampleControlsState {
  loopStart: number;
  loopEnd: number;
  startPoint: number;
  endPoint: number;
}

interface SampleControlsCallbacks {
  onLoopStartChange: (value: number) => void;
  onLoopEndChange: (value: number) => void;
  onStartPointChange: (value: number) => void;
  onEndPointChange: (value: number) => void;
}

export class SampleControlsVanilla {
  private container: HTMLElement;
  private state: SampleControlsState;
  private callbacks: SampleControlsCallbacks;

  private loopStartSlider!: HTMLInputElement;
  private loopEndSlider!: HTMLInputElement;
  private startPointSlider!: HTMLInputElement;
  private endPointSlider!: HTMLInputElement;
  private loopDurationKnob!: KnobElement;

  private readonly minLoopDurationNorm = 0.0001;

  constructor(
    container: HTMLElement,
    initialState: SampleControlsState,
    callbacks: SampleControlsCallbacks
  ) {
    this.container = container;
    this.state = { ...initialState };
    this.callbacks = callbacks;

    this.init();
  }

  private init(): void {
    // Register the knob element if not already registered
    if (!customElements.get('knob-element')) {
      customElements.define('knob-element', KnobElement);
    }

    this.render();
    this.setupEventListeners();
    this.updateDisplay();
  }

  private render(): void {
    this.container.innerHTML = `
      <div style="display: flex; flex-direction: column;">
        <!-- Loop Controls -->
        <div style="display: flex; place-items: center; column-gap: 0.5rem; margin-top: 10px;">
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <label>Loop Start</label>
            <input type="range" class="loop-start-slider" min="0" max="1" step="0.001" value="${this.state.loopStart}">
            <span class="loop-start-value">${this.state.loopStart.toFixed(3)}</span>
          </div>
          
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <label>Loop End</label>
            <input type="range" class="loop-end-slider" min="0" max="1" step="0.001" value="${this.state.loopEnd}">
            <span class="loop-end-value">${this.state.loopEnd.toFixed(3)}</span>
          </div>
          
          <div style="display: flex; flex-direction: column; gap: 0.5rem; align-items: center;">
            <label>Fine Tune</label>
            <knob-element 
              class="loop-duration-knob"
              min-value="0"
              max-value="0.1"
              snap-increment="0.0001"
              width="45"
              height="45"
              default-value="0"
              style="margin-top: 10px;">
            </knob-element>
            <span class="knob-value">0.000</span>
          </div>
        </div>

        <!-- Trim Controls -->
        <div style="display: flex; gap: 0.5rem; margin-top: 20px;">
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <label>Trim Start</label>
            <input type="range" class="start-point-slider" min="0" max="1" step="0.001" value="${this.state.startPoint}">
            <span class="start-point-value">${this.state.startPoint.toFixed(3)}</span>
          </div>
          
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <label>Trim End</label>
            <input type="range" class="end-point-slider" min="0" max="1" step="0.001" value="${this.state.endPoint}">
            <span class="end-point-value">${this.state.endPoint.toFixed(3)}</span>
          </div>
        </div>
      </div>
    `;

    // Get references to elements
    this.loopStartSlider = this.container.querySelector(
      '.loop-start-slider'
    ) as HTMLInputElement;
    this.loopEndSlider = this.container.querySelector(
      '.loop-end-slider'
    ) as HTMLInputElement;
    this.startPointSlider = this.container.querySelector(
      '.start-point-slider'
    ) as HTMLInputElement;
    this.endPointSlider = this.container.querySelector(
      '.end-point-slider'
    ) as HTMLInputElement;
    this.loopDurationKnob = this.container.querySelector(
      '.loop-duration-knob'
    ) as KnobElement;
  }

  private setupEventListeners(): void {
    // Loop Start Slider
    this.loopStartSlider.addEventListener('input', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      this.updateLoopStart(value);
    });

    // Loop End Slider
    this.loopEndSlider.addEventListener('input', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      this.updateLoopEnd(value);
    });

    // Start Point Slider
    this.startPointSlider.addEventListener('input', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      this.updateStartPoint(value);
    });

    // End Point Slider
    this.endPointSlider.addEventListener('input', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      this.updateEndPoint(value);
    });

    // Knob Element - Listen for 'change' event (not 'onchange')
    this.loopDurationKnob.addEventListener('change', (e: CustomEvent) => {
      console.log('Knob change event received:', e.detail);
      const offset = Math.max(0, e.detail.value);
      const newLoopEnd = Math.max(
        this.state.loopStart + this.minLoopDurationNorm,
        this.state.loopEnd - offset
      );
      this.updateLoopEnd(newLoopEnd);
    });

    // Alternative: Listen for the custom event name if different
    this.loopDurationKnob.addEventListener('knob-change', (e: CustomEvent) => {
      console.log('Knob-change event received:', e.detail);
      const offset = Math.max(0, e.detail.value);
      const newLoopEnd = Math.max(
        this.state.loopStart + this.minLoopDurationNorm,
        this.state.loopEnd - offset
      );
      this.updateLoopEnd(newLoopEnd);
    });
  }

  private updateLoopStart(value: number): void {
    this.state.loopStart = value;

    // Ensure loop end is always after loop start with minimum duration
    const minLoopEnd = this.state.loopStart + this.minLoopDurationNorm;
    if (this.state.loopEnd < minLoopEnd) {
      this.state.loopEnd = minLoopEnd;
      this.loopEndSlider.value = this.state.loopEnd.toString();
    }

    this.updateKnobMaxValue();
    this.updateDisplay();
    this.callbacks.onLoopStartChange(value);
  }

  private updateLoopEnd(value: number): void {
    // Ensure loop end is always after loop start with minimum duration
    const minLoopEnd = this.state.loopStart + this.minLoopDurationNorm;
    this.state.loopEnd = Math.max(value, minLoopEnd);

    this.loopEndSlider.value = this.state.loopEnd.toString();
    this.updateKnobMaxValue();
    this.updateDisplay();
    this.callbacks.onLoopEndChange(this.state.loopEnd);
  }

  private updateStartPoint(value: number): void {
    this.state.startPoint = value;
    this.updateDisplay();
    this.callbacks.onStartPointChange(value);
  }

  private updateEndPoint(value: number): void {
    this.state.endPoint = value;
    this.updateDisplay();
    this.callbacks.onEndPointChange(value);
  }

  private updateKnobMaxValue(): void {
    const thumbDistance = this.state.loopEnd - this.state.loopStart;
    this.loopDurationKnob.setAttribute('max-value', thumbDistance.toString());
  }

  private updateDisplay(): void {
    // Update value displays
    const loopStartValue = this.container.querySelector(
      '.loop-start-value'
    ) as HTMLElement;
    const loopEndValue = this.container.querySelector(
      '.loop-end-value'
    ) as HTMLElement;
    const startPointValue = this.container.querySelector(
      '.start-point-value'
    ) as HTMLElement;
    const endPointValue = this.container.querySelector(
      '.end-point-value'
    ) as HTMLElement;
    const knobValue = this.container.querySelector(
      '.knob-value'
    ) as HTMLElement;

    if (loopStartValue)
      loopStartValue.textContent = this.state.loopStart.toFixed(3);
    if (loopEndValue) loopEndValue.textContent = this.state.loopEnd.toFixed(3);
    if (startPointValue)
      startPointValue.textContent = this.state.startPoint.toFixed(3);
    if (endPointValue)
      endPointValue.textContent = this.state.endPoint.toFixed(3);
    if (knobValue)
      knobValue.textContent = this.loopDurationKnob.getValue().toFixed(3);
  }

  // Public methods to update state from external sources
  public setLoopStart(value: number): void {
    this.state.loopStart = value;
    this.loopStartSlider.value = value.toString();
    this.updateDisplay();
  }

  public setLoopEnd(value: number): void {
    this.state.loopEnd = value;
    this.loopEndSlider.value = value.toString();
    this.updateDisplay();
  }

  public setStartPoint(value: number): void {
    this.state.startPoint = value;
    this.startPointSlider.value = value.toString();
    this.updateDisplay();
  }

  public setEndPoint(value: number): void {
    this.state.endPoint = value;
    this.endPointSlider.value = value.toString();
    this.updateDisplay();
  }

  public getState(): SampleControlsState {
    return { ...this.state };
  }

  public destroy(): void {
    // Clean up event listeners if needed
    this.container.innerHTML = '';
  }
}

// Usage example:
/*
const container = document.getElementById('sample-controls-container');
const initialState = {
  loopStart: 0,
  loopEnd: 1,
  startPoint: 0,
  endPoint: 1
};

const callbacks = {
  onLoopStartChange: (value) => console.log('Loop start changed:', value),
  onLoopEndChange: (value) => console.log('Loop end changed:', value),
  onStartPointChange: (value) => console.log('Start point changed:', value),
  onEndPointChange: (value) => console.log('End point changed:', value)
};

const sampleControls = new SampleControls(container, initialState, callbacks);
*/
