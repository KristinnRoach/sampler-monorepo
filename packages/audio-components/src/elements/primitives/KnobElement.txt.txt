import { gsap } from 'gsap';
import { Draggable } from 'gsap/Draggable';

gsap.registerPlugin(Draggable);

interface KnobConfig {
  minValue: number;
  maxValue: number;
  minRotation: number;
  maxRotation: number;
  snapIncrement: number;
  initialValue?: number;
  disabled?: boolean;
  borderStyle?: 'currentState' | 'fullCircle';
}

interface KnobChangeEventDetail {
  value: number;
  rotation: number;
  percentage: number;
}

declare global {
  interface HTMLElementEventMap {
    'knob-change': CustomEvent<KnobChangeEventDetail>;
  }
}

export class KnobElement extends HTMLElement {
  private knobElement!: HTMLElement;
  private gsapDraggable!: Draggable;
  private static stylesInjected = false;

  private config: KnobConfig = {
    minValue: 0,
    maxValue: 100,
    minRotation: -170,
    maxRotation: 170,
    snapIncrement: 0.01,
    initialValue: 0,
    disabled: false,
    borderStyle: 'currentState',
  };

  private currentValue: number = 0;
  private currentRotation: number = 0;
  private rotationToValue!: (rotation: number) => number;
  private valueToRotation!: (value: number) => number;

  static get observedAttributes(): string[] {
    return [
      'min-value',
      'max-value',
      'min-rotation',
      'max-rotation',
      'snap-increment',
      'value',
      'disabled',
      'width',
      'height',
      'border-style',
    ];
  }

  constructor() {
    super();
    this.injectGlobalStyles();
  }

  connectedCallback(): void {
    this.render();
    this.updateConfigFromAttributes();
    this.init();
  }

  disconnectedCallback(): void {
    this.cleanup();
  }

  attributeChangedCallback(
    name: string,
    oldValue: string,
    newValue: string
  ): void {
    if (oldValue !== newValue) {
      this.updateConfigFromAttributes();
      if (name === 'width' || name === 'height' || name === 'border-style')
        return;
      if (this.gsapDraggable) {
        this.reinitialize();
      }
    }
  }

  private render(): void {
    this.innerHTML = `
      <div class="knob-container">
        <svg class="knob-border-svg" width="100%" height="100%" viewBox="0 0 100 100">
          <path class="knob-border" 
                fill="none" 
                stroke="var(--knob-border)" 
                stroke-width="4" 
                d="M50,50Z"/>
        </svg>

        <div class="knob" style="background: red; widht: 50px; height: 50px; ">
          <div class="center-dot"></div>
        </div>
      </div>
    `;

    this.knobElement = this.querySelector('.knob') as HTMLElement;
  }

  private init(): void {
    this.createUtilityFunctions();
    this.createDraggable();
    this.setValue(this.config.initialValue || this.config.minValue);
  }

  private reinitialize(): void {
    this.cleanup();
    this.init();
  }

  private cleanup(): void {
    if (this.gsapDraggable) {
      this.gsapDraggable.kill();
    }
  }

  private createUtilityFunctions(): void {
    this.rotationToValue = gsap.utils.mapRange(
      this.config.minRotation,
      this.config.maxRotation,
      this.config.minValue,
      this.config.maxValue
    );

    this.valueToRotation = gsap.utils.mapRange(
      this.config.minValue,
      this.config.maxValue,
      this.config.minRotation,
      this.config.maxRotation
    );
  }

  private createDraggable(): void {
    if (this.config.disabled) return;

    let startRotation = 0;
    let totalDeltaY = 0;
    let mouseMoveHandler: (e: MouseEvent) => void;

    this.gsapDraggable = Draggable.create(this.knobElement, {
      type: 'y',
      inertia: false,
      onPress: () => {
        this.knobElement.requestPointerLock();
        startRotation = this.currentRotation;
        totalDeltaY = 0;

        mouseMoveHandler = (e: MouseEvent) => {
          if (document.pointerLockElement === this.knobElement) {
            totalDeltaY += e.movementY;
            const sensitivity = 4.0;
            const newRotation = startRotation - totalDeltaY * sensitivity;

            this.currentRotation = gsap.utils.clamp(
              this.config.minRotation,
              this.config.maxRotation,
              newRotation
            );

            gsap.set(this.knobElement, {
              y: 0,
              rotation: this.currentRotation,
            });

            this.currentValue = this.rotationToValue(this.currentRotation);
            this.dispatchChangeEvent();
          }
        };
        document.addEventListener('mousemove', mouseMoveHandler);
      },
      onRelease: () => {
        document.exitPointerLock();
        if (mouseMoveHandler) {
          document.removeEventListener('mousemove', mouseMoveHandler);
        }
      },
    })[0];
  }

  private updateBorder(): void {
    const borderStyle = this.getAttribute('border-style') || 'currentState';
    const path = this.querySelector('.knob-border') as SVGPathElement;
    if (!path) {
      console.warn('Path does not exist, retrying... ');
      setTimeout(() => this.updateBorder(), 10);
    }

    if (borderStyle === 'currentState') {
      const r = 48;
      const cx = 50;
      const cy = 50;

      const startAngle = ((this.config.minRotation - 90) * Math.PI) / 180;
      const currentAngle = ((this.currentRotation - 90) * Math.PI) / 180;

      const startX = r * Math.cos(startAngle) + cx;
      const startY = r * Math.sin(startAngle) + cy;
      const endX = r * Math.cos(currentAngle) + cx;
      const endY = r * Math.sin(currentAngle) + cy;

      const totalAngle = this.currentRotation - this.config.minRotation;
      const largeArc = Math.abs(totalAngle) > 180 ? 1 : 0;

      const pathData = `M${cx},${cy} L${startX},${startY} A${r},${r},0,${largeArc},1,${endX},${endY} Z`;
      path.setAttribute('d', pathData);
    } else {
      path.setAttribute('d', `M50,2 A48,48,0,1,1,49.9,2 Z`);
    }
  }

  private dispatchChangeEvent(): void {
    this.updateBorder();

    const percentage = gsap.utils.mapRange(
      this.config.minValue,
      this.config.maxValue,
      0,
      100
    )(this.currentValue);

    const event = new CustomEvent<KnobChangeEventDetail>('knob-change', {
      detail: {
        value: this.currentValue,
        rotation: this.currentRotation,
        percentage,
      },
      bubbles: true,
    });

    this.dispatchEvent(event);
  }

  public setValue(value: number, animate: boolean = false): void {
    if (!this.valueToRotation) {
      this.config.initialValue = value;
      return;
    }

    this.currentValue = gsap.utils.clamp(
      this.config.minValue,
      this.config.maxValue,
      value
    );

    this.currentRotation = this.valueToRotation(this.currentValue);

    if (animate) {
      gsap.to(this.knobElement, {
        rotation: this.currentRotation,
        duration: 0.3,
        ease: 'power2.out',
      });
    } else {
      gsap.set(this.knobElement, { rotation: this.currentRotation });
    }

    this.dispatchChangeEvent();
  }

  public getValue(): number {
    return this.currentValue;
  }
  get value(): number {
    return this.getValue();
  }
  set value(val: number) {
    this.setValue(val, true);
  }

  private injectGlobalStyles(): void {
    // Only inject styles once globally
    if (KnobElement.stylesInjected) return;

    const styleElement = document.createElement('style');
    styleElement.id = 'knob-element-styles';
    styleElement.textContent = `
    knob-element {
      display: inline-block;
      --knob-size: 120px;
      --knob-bg: inherit;
      --knob-border: rgb(234, 234, 234);
    }
    
    knob-element[disabled] {
      opacity: 0.5;
      pointer-events: none;
    }
    
    knob-element .knob-container {
      position: relative;
      width: var(--knob-size);
      height: var(--knob-size);
    }

    knob-element .knob-border-svg {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    
    knob-element .knob {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      cursor: grab;
      transition: transform 0.1s ease;
    }
    
    knob-element .knob:hover {
      transform: scale(1.05);
    }
    
    knob-element .knob:active {
      cursor: grabbing;
      transform: scale(0.95);
    }

    
    knob-element .center-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 4px;
      background: white; 
      border-radius: 50%;
    }
  `;

    document.head.appendChild(styleElement);
    KnobElement.stylesInjected = true;
  }

  private updateDimensions(): void {
    const width = this.getAttribute('width');
    const height = this.getAttribute('height');
    if (width || height) {
      const size = width || height || '120';
      this.style.setProperty('--knob-size', `${size}px`);
      this.style.width = `${size}px`;
      this.style.height = `${size}px`;
    }
  }

  private updateConfigFromAttributes(): void {
    const getValue = (attr: string, defaultValue: number): number => {
      const value = this.getAttribute(attr);
      return value !== null ? parseFloat(value) : defaultValue;
    };

    this.config = {
      minValue: getValue('min-value', 0),
      maxValue: getValue('max-value', 100),
      minRotation: getValue('min-rotation', -150),
      maxRotation: getValue('max-rotation', 150),
      snapIncrement: getValue('snap-increment', 1),
      initialValue: getValue('value', 0),
      disabled: this.hasAttribute('disabled'),
      borderStyle:
        (this.getAttribute('border-style') as
          | 'currentState'
          | 'fullCircle'
          | undefined) || 'currentState',
    };

    this.updateBorder();
    this.updateDimensions();
  }
}
