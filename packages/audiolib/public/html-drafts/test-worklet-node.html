<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Source Processor Test with SourcePlayer</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        line-height: 1.6;
      }
      button {
        padding: 10px 15px;
        margin: 5px;
        font-size: 16px;
        cursor: pointer;
      }
      .controls {
        margin: 20px 0;
        padding: 15px;
        background: #f5f5f5;
        border-radius: 5px;
      }
      .parameter {
        margin: 10px 0;
      }
      .parameter-row {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }
      .parameter-row label {
        width: 120px;
        margin-right: 10px;
      }
      .parameter-row input[type='range'] {
        flex: 1;
        margin-right: 10px;
      }
      .parameter-row .value {
        width: 60px;
        text-align: right;
      }
      .parameter-group {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        margin-top: 15px;
      }
      .parameter-group h3 {
        margin-top: 0;
        margin-bottom: 10px;
      }
      #log {
        height: 200px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        background: #f9f9f9;
        font-family: monospace;
        margin-top: 20px;
      }
      #uploadSection {
        margin: 20px 0;
        padding: 15px;
        background: #e9f7fe;
        border-radius: 5px;
      }
      .waveform-container {
        width: 100%;
        height: 100px;
        background: #f0f0f0;
        margin: 15px 0;
        position: relative;
        border-radius: 3px;
      }
      .waveform {
        width: 100%;
        height: 100%;
      }
      .loop-marker {
        position: absolute;
        top: 0;
        height: 100%;
        width: 2px;
        background-color: red;
      }
      .loop-marker.start {
        background-color: green;
      }
      .loop-marker.end {
        background-color: red;
      }
      .loop-region {
        position: absolute;
        top: 0;
        height: 100%;
        background-color: rgba(0, 255, 0, 0.2);
      }
      #microLoopSection {
        background: #fff0f0;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
      }
      .unit-selector {
        margin-left: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Audio Source Processor Test with SourcePlayer</h1>

    <div id="uploadSection">
      <h2>Load Audio File</h2>
      <input type="file" id="audioFileInput" accept="audio/*" />
      <div>or</div>
      <button id="generateSineWave">Generate Test Sine Wave</button>
    </div>

    <div class="waveform-container">
      <canvas id="waveform" class="waveform"></canvas>
      <div id="loopRegion" class="loop-region"></div>
      <div id="loopStartMarker" class="loop-marker start"></div>
      <div id="loopEndMarker" class="loop-marker end"></div>
    </div>

    <div class="controls">
      <button id="playButton" disabled>Play</button>
      <button id="stopButton" disabled>Stop</button>

      <div class="parameter">
        <div class="parameter-row">
          <label for="loopCheckbox">Loop:</label>
          <input type="checkbox" id="loopCheckbox" />
        </div>
      </div>

      <div class="parameter">
        <div class="parameter-row">
          <label for="playbackRate">Playback Rate:</label>
          <input
            type="range"
            id="playbackRate"
            min="0.1"
            max="2"
            step="0.1"
            value="1"
          />
          <span id="rateValue" class="value">1.0</span>
        </div>
      </div>

      <div class="parameter-group">
        <h3>Loop Points</h3>

        <div class="parameter-row">
          <label for="loopStart">Loop Start:</label>
          <input
            type="range"
            id="loopStart"
            min="0"
            max="1"
            step="0.001"
            value="0"
          />
          <span id="loopStartValue" class="value">0.000</span>
        </div>

        <div class="parameter-row">
          <label for="loopEnd">Loop End:</label>
          <input
            type="range"
            id="loopEnd"
            min="0"
            max="1"
            step="0.001"
            value="1"
          />
          <span id="loopEndValue" class="value">1.000</span>
        </div>

        <div class="parameter-row">
          <label for="rampDuration">Ramp Time:</label>
          <input
            type="range"
            id="rampDuration"
            min="0"
            max="1"
            step="0.01"
            value="0"
          />
          <span id="rampDurationValue" class="value">0.00</span>
        </div>
      </div>

      <div id="microLoopSection" class="parameter-group">
        <h3>Micro-Loop Testing</h3>

        <div class="parameter-row">
          <label for="loopDuration">Loop Duration:</label>
          <input
            type="number"
            id="loopDuration"
            min="0.001"
            step="0.001"
            value="0.010"
          />
          <select id="durationUnit" class="unit-selector">
            <option value="s">seconds</option>
            <option value="ms" selected>milliseconds</option>
            <option value="samples">samples</option>
          </select>
        </div>

        <div class="parameter-row">
          <label for="loopPosition">Loop Position:</label>
          <input
            type="range"
            id="loopPosition"
            min="0"
            max="1"
            step="0.001"
            value="0.5"
          />
          <span id="loopPositionValue" class="value">0.500</span>
        </div>

        <button id="applyMicroLoop">Apply Micro-Loop</button>
      </div>
    </div>

    <div id="log"></div>

    <script src="SourcePlayer.js"></script>
    <script>
      // DOM elements
      const audioFileInput = document.getElementById('audioFileInput');
      const generateSineWaveButton =
        document.getElementById('generateSineWave');
      const playButton = document.getElementById('playButton');
      const stopButton = document.getElementById('stopButton');
      const loopCheckbox = document.getElementById('loopCheckbox');
      const playbackRateSlider = document.getElementById('playbackRate');
      const rateValueDisplay = document.getElementById('rateValue');
      const loopStartSlider = document.getElementById('loopStart');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndSlider = document.getElementById('loopEnd');
      const loopEndValue = document.getElementById('loopEndValue');
      const rampDurationSlider = document.getElementById('rampDuration');
      const rampDurationValue = document.getElementById('rampDurationValue');
      const loopDurationInput = document.getElementById('loopDuration');
      const durationUnit = document.getElementById('durationUnit');
      const loopPositionSlider = document.getElementById('loopPosition');
      const loopPositionValue = document.getElementById('loopPositionValue');
      const applyMicroLoopButton = document.getElementById('applyMicroLoop');
      const waveformCanvas = document.getElementById('waveform');
      const loopRegion = document.getElementById('loopRegion');
      const loopStartMarker = document.getElementById('loopStartMarker');
      const loopEndMarker = document.getElementById('loopEndMarker');
      const logElement = document.getElementById('log');

      // Global variables
      let audioContext;
      let player;
      let workletLoaded = false;
      let audioBuffer = null;
      let waveformData = null;
      let canvasContext = waveformCanvas.getContext('2d');

      // Logger function
      function log(message) {
        const entry = document.createElement('div');
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logElement.appendChild(entry);
        logElement.scrollTop = logElement.scrollHeight;
      }

      // Initialize audio context and worklet
      async function initializeAudio() {
        if (audioContext && workletLoaded) return true;

        try {
          // Create audio context
          audioContext = new AudioContext();

          // Load the worklet module
          log('Loading AudioWorklet module...');
          await audioContext.audioWorklet.addModule('source-processor.js');

          workletLoaded = true;
          log('AudioWorklet initialized successfully');
          return true;
        } catch (error) {
          log(`Failed to initialize audio: ${error.message}`);
          console.error('Audio initialization error:', error);
          return false;
        }
      }

      // Draw waveform on canvas
      function drawWaveform() {
        if (!audioBuffer || !waveformCanvas) return;

        // Resize canvas to match container size
        const container = waveformCanvas.parentElement;
        waveformCanvas.width = container.clientWidth;
        waveformCanvas.height = container.clientHeight;

        // Get waveform data if not already processed
        if (!waveformData) {
          const channel = audioBuffer.getChannelData(0);
          const samples = 1000; // Number of samples to display
          waveformData = new Float32Array(samples);

          // Downsample for visualization
          const blockSize = Math.floor(channel.length / samples);
          for (let i = 0; i < samples; i++) {
            const start = i * blockSize;
            let sum = 0;
            for (let j = 0; j < blockSize; j++) {
              sum += Math.abs(channel[start + j] || 0);
            }
            waveformData[i] = sum / blockSize;
          }
        }

        // Draw waveform
        const width = waveformCanvas.width;
        const height = waveformCanvas.height;
        const centerY = height / 2;

        canvasContext.clearRect(0, 0, width, height);
        canvasContext.fillStyle = '#e0e0e0';
        canvasContext.fillRect(0, 0, width, height);

        canvasContext.beginPath();
        canvasContext.moveTo(0, centerY);

        for (let i = 0; i < waveformData.length; i++) {
          const x = (i / waveformData.length) * width;
          const y = centerY - waveformData[i] * centerY * 0.8;
          canvasContext.lineTo(x, y);
        }

        for (let i = waveformData.length - 1; i >= 0; i--) {
          const x = (i / waveformData.length) * width;
          const y = centerY + waveformData[i] * centerY * 0.8;
          canvasContext.lineTo(x, y);
        }

        canvasContext.closePath();
        canvasContext.fillStyle = '#b0d0ff';
        canvasContext.fill();

        updateLoopMarkers();
      }

      // Update loop markers on waveform
      function updateLoopMarkers() {
        if (!waveformCanvas || !audioBuffer) return;

        const width = waveformCanvas.width;
        const loopStart = parseFloat(loopStartSlider.value);
        const loopEnd = parseFloat(loopEndSlider.value);

        // Position markers
        loopStartMarker.style.left = `${loopStart * width}px`;
        loopEndMarker.style.left = `${loopEnd * width}px`;

        // Update loop region
        loopRegion.style.left = `${loopStart * width}px`;
        loopRegion.style.width = `${(loopEnd - loopStart) * width}px`;
      }

      // Basic player setup function
      async function setupBasicPlayer(buffer) {
        try {
          // Store buffer for waveform display
          audioBuffer = buffer;

          // Make sure audio is initialized first
          const initialized = await initializeAudio();
          if (!initialized) {
            throw new Error('Audio system not initialized');
          }

          // Create the player instance
          player = new SourcePlayer(audioContext);

          // Connect to audio output
          player.connect(audioContext.destination);

          // Load the decoded buffer into our player
          await player.loadBuffer(audioBuffer);
          log(
            `Audio loaded: Duration ${audioBuffer.duration.toFixed(3)}s, ${
              audioBuffer.numberOfChannels
            } channel(s)`
          );

          // Draw waveform
          drawWaveform();

          // Update loop sliders max values based on duration
          loopStartSlider.max = audioBuffer.duration;
          loopEndSlider.max = audioBuffer.duration;
          loopEndSlider.value = audioBuffer.duration;
          loopEndValue.textContent = audioBuffer.duration.toFixed(3);

          // Update micro-loop position slider
          loopPositionSlider.max = audioBuffer.duration;

          // Add event listeners
          player.addEventListener('ended', () => {
            log('Playback ended');
            playButton.disabled = false;
            stopButton.disabled = true;

            setupBasicPlayer(buffer);
          });

          player.addEventListener('started', (event) => {
            log(`Playback started from offset: ${event.detail.offset}s`);
          });

          // Enable playback controls
          playButton.disabled = false;
          stopButton.disabled = true;

          return player;
        } catch (error) {
          log(`Error setting up player: ${error.message}`);
          console.error('Player setup error:', error);
        }
      }

      // Set loop parameters with optional ramping
      function setLoopParameters() {
        if (!player) return;

        const looping = loopCheckbox.checked;
        const loopStart = parseFloat(loopStartSlider.value);
        const loopEnd = parseFloat(loopEndSlider.value);
        const rampDuration = parseFloat(rampDurationSlider.value);

        if (rampDuration > 0) {
          // With ramping
          const currentTime = audioContext.currentTime;
          player.loop.setValueAtTime(looping ? 1 : 0, currentTime);

          // Ramp loop points over time
          player.loopStart.linearRampToValueAtTime(
            loopStart,
            currentTime + rampDuration
          );
          player.loopEnd.linearRampToValueAtTime(
            loopEnd,
            currentTime + rampDuration
          );

          log(
            `Ramping loop points to Start: ${loopStart.toFixed(
              3
            )}s, End: ${loopEnd.toFixed(3)}s over ${rampDuration.toFixed(2)}s`
          );
        } else {
          // Immediate change
          player.setLoop(looping, loopStart, loopEnd);
          log(
            `Loop ${
              looping ? 'enabled' : 'disabled'
            }, Start: ${loopStart.toFixed(3)}s, End: ${loopEnd.toFixed(3)}s`
          );
        }

        updateLoopMarkers();
      }

      // Set micro-loop parameters
      function setMicroLoop() {
        if (!player || !audioBuffer) return;

        // Get values from inputs
        const position = parseFloat(loopPositionSlider.value);
        const durationValue = parseFloat(loopDurationInput.value);
        let durationInSeconds;

        // Convert duration based on selected unit
        switch (durationUnit.value) {
          case 'ms':
            durationInSeconds = durationValue / 1000;
            break;
          case 'samples':
            durationInSeconds = durationValue / audioContext.sampleRate;
            break;
          default: // seconds
            durationInSeconds = durationValue;
        }

        // Calculate loop points
        const halfDuration = durationInSeconds / 2;
        let loopStart = Math.max(0, position - halfDuration);
        let loopEnd = Math.min(audioBuffer.duration, position + halfDuration);

        // Update UI to match
        loopStartSlider.value = loopStart;
        loopEndSlider.value = loopEnd;
        loopStartValue.textContent = loopStart.toFixed(3);
        loopEndValue.textContent = loopEnd.toFixed(3);

        // Enable looping
        loopCheckbox.checked = true;

        // Apply loop settings
        player.setLoop(true, loopStart, loopEnd);

        // Update visualization
        updateLoopMarkers();

        // Log details including sample count
        const sampleCount = Math.round(
          durationInSeconds * audioContext.sampleRate
        );
        log(
          `Applied micro-loop: Position ${position.toFixed(
            3
          )}s, Duration ${durationInSeconds.toFixed(
            6
          )}s (${sampleCount} samples)`
        );
      }

      // Handle file upload
      audioFileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        try {
          log(`Loading file: ${file.name}`);

          // Initialize audio if needed
          await initializeAudio();

          // Read and decode the file
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          // Setup player with the buffer
          await setupBasicPlayer(audioBuffer);
        } catch (error) {
          log(`Error loading file: ${error.message}`);
        }
      });

      // Generate a test sine wave
      generateSineWaveButton.addEventListener('click', async () => {
        try {
          log('Generating test sine wave...');

          // Initialize audio if needed
          await initializeAudio();

          // Create a 2-second sine wave at 440Hz
          const sampleRate = audioContext.sampleRate;
          const duration = 2; // seconds
          const frequency = 440; // Hz

          // Create AudioBuffer
          const audioBuffer = audioContext.createBuffer(
            1,
            duration * sampleRate,
            sampleRate
          );
          const channelData = audioBuffer.getChannelData(0);

          // Fill with sine wave
          for (let i = 0; i < channelData.length; i++) {
            channelData[i] = Math.sin(
              (2 * Math.PI * frequency * i) / sampleRate
            );
          }

          log(
            `Generated ${duration}s sine wave at ${frequency}Hz (sample rate: ${sampleRate}Hz)`
          );

          // Reset waveform data
          waveformData = null;

          // Setup player with the buffer
          await setupBasicPlayer(audioBuffer);
        } catch (error) {
          log(`Error generating sine wave: ${error.message}`);
        }
      });

      // Play button
      playButton.addEventListener('click', () => {
        if (!player) return;

        // Resume audio context if suspended
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        // Apply current settings
        const rate = parseFloat(playbackRateSlider.value);
        player.setRate(rate);

        // Apply loop settings
        setLoopParameters();

        // Start playback
        player.play();

        // Update UI
        playButton.disabled = true;
        stopButton.disabled = false;
      });

      // Stop button
      stopButton.addEventListener('click', () => {
        if (!player) return;

        player.stop();

        // Update UI
        playButton.disabled = false;
        stopButton.disabled = true;

        log('Playback stopped');
      });

      // Update rate display and apply changes
      playbackRateSlider.addEventListener('input', () => {
        const rate = playbackRateSlider.value;
        rateValueDisplay.textContent = rate;

        if (player && player.isPlaying) {
          player.setRate(parseFloat(rate));
          log(`Playback rate changed to ${rate}`);
        }
      });

      // Update loop settings when sliders change
      loopStartSlider.addEventListener('input', () => {
        const value = parseFloat(loopStartSlider.value);
        loopStartValue.textContent = value.toFixed(3);

        // Ensure loop start doesn't exceed loop end
        if (value >= parseFloat(loopEndSlider.value)) {
          loopEndSlider.value = Math.min(value + 0.001, loopEndSlider.max);
          loopEndValue.textContent = parseFloat(loopEndSlider.value).toFixed(3);
        }

        if (player && player.isPlaying && loopCheckbox.checked) {
          setLoopParameters();
        } else {
          updateLoopMarkers();
        }
      });

      loopEndSlider.addEventListener('input', () => {
        const value = parseFloat(loopEndSlider.value);
        loopEndValue.textContent = value.toFixed(3);

        // Ensure loop end doesn't go below loop start
        if (value <= parseFloat(loopStartSlider.value)) {
          loopStartSlider.value = Math.max(value - 0.001, 0);
          loopStartValue.textContent = parseFloat(
            loopStartSlider.value
          ).toFixed(3);
        }

        if (player && player.isPlaying && loopCheckbox.checked) {
          setLoopParameters();
        } else {
          updateLoopMarkers();
        }
      });

      // Update ramp duration display
      rampDurationSlider.addEventListener('input', () => {
        const value = parseFloat(rampDurationSlider.value);
        rampDurationValue.textContent = value.toFixed(2);
      });

      // Update loop when checkbox changes
      loopCheckbox.addEventListener('change', () => {
        if (player) {
          setLoopParameters();
        }
      });

      // Update micro-loop position value
      loopPositionSlider.addEventListener('input', () => {
        const value = parseFloat(loopPositionSlider.value);
        loopPositionValue.textContent = value.toFixed(3);
      });

      // Apply micro-loop button
      applyMicroLoopButton.addEventListener('click', () => {
        setMicroLoop();
      });

      // Handle window resize for canvas
      window.addEventListener('resize', drawWaveform);

      // Initial log message
      log(
        'Page loaded. Please load an audio file or generate a test sine wave.'
      );
    </script>
  </body>
</html>
