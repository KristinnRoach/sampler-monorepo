<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VoiceNode Interactive Test</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .controls {
        margin: 20px 0;
      }
      .slider-container {
        margin: 15px 0;
      }
      input[type='range'] {
        width: 100%;
      }
      label {
        display: inline-block;
        width: 150px;
      }
      button {
        margin-right: 10px;
        padding: 8px 16px;
      }
      #fileInput {
        margin-bottom: 20px;
      }
      .keyboard {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        margin-top: 20px;
      }
      .key {
        width: 40px;
        height: 80px;
        background-color: white;
        border: 1px solid black;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        cursor: pointer;
        position: relative;
        user-select: none;
      }
      .key.black {
        background-color: black;
        color: white;
        height: 50px;
        width: 30px;
        margin-left: -15px;
        margin-right: -15px;
        z-index: 1;
      }
      .error-message {
        background-color: #ffeeee;
        border: 1px solid #ffaaaa;
        color: #aa0000;
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>VoiceNode Interactive Test</h1>

    <div id="errorMessage" class="error-message"></div>

    <div>
      <input type="file" id="fileInput" accept="audio/*" />
      <p>Or select a sample:</p>
      <select id="sampleSelect">
        <option value="">-- Select a sample --</option>
        <option value="/audio-samples/BB169.wav">BB169.wav</option>
        <option value="/audio-samples/Cello1.wav">Cello1.wav</option>
        <option value="/audio-samples/Kit03-120C-04.wav">
          Kit03-120C-04.wav
        </option>
        <option value="/audio-samples/c4.mp3">c4.mp3</option>
        <option value="/audio-samples/guitar.mp3">guitar.mp3</option>
      </select>
    </div>

    <div class="controls">
      <h3>Envelope Controls</h3>
      <div class="slider-container">
        <label for="attackSlider"
          >Attack: <span id="attackValue">10</span>ms</label
        >
        <input
          type="range"
          id="attackSlider"
          min="1"
          max="2000"
          step="1"
          value="10"
        />
      </div>

      <div class="slider-container">
        <label for="releaseSlider"
          >Release: <span id="releaseValue">200</span>ms</label
        >
        <input
          type="range"
          id="releaseSlider"
          min="1"
          max="5000"
          step="1"
          value="200"
        />
      </div>

      <h3>Loop Controls</h3>
      <div>
        <label>
          <input type="checkbox" id="loopCheckbox" />
          Enable Looping
        </label>
      </div>

      <div class="slider-container">
        <label for="loopStartSlider"
          >Loop Start: <span id="loopStartValue">0.0</span>s</label
        >
        <input
          type="range"
          id="loopStartSlider"
          min="0"
          max="1"
          step="0.01"
          value="0"
        />
      </div>

      <div class="slider-container">
        <label for="loopEndSlider"
          >Loop End: <span id="loopEndValue">1.0</span>s</label
        >
        <input
          type="range"
          id="loopEndSlider"
          min="0"
          max="1"
          step="0.01"
          value="1"
        />
      </div>
    </div>

    <div>
      <h3>Keyboard Controls</h3>
      <p>Click a key to play a note (midi notes 60-84)</p>
      <div class="keyboard" id="keyboard"></div>
    </div>

    <script type="module">
      // Shared AudioWorklet processor cache to prevent duplicate registration
      window._registeredProcessors = window._registeredProcessors || new Set();

      // Import statements are processed by Vite during development
      import { VoiceNode } from '../../src/lib/voice/VoiceNode.ts';
      import { LoopWorklet } from '../../src/lib/loop/LoopWorklet.ts';
      import { isValidAudioBuffer } from '../../src/utils/validation-utils.ts';

      // UI elements
      const fileInput = document.getElementById('fileInput');
      const sampleSelect = document.getElementById('sampleSelect');
      const attackSlider = document.getElementById('attackSlider');
      const releaseSlider = document.getElementById('releaseSlider');
      const attackValue = document.getElementById('attackValue');
      const releaseValue = document.getElementById('releaseValue');
      const loopCheckbox = document.getElementById('loopCheckbox');
      const loopStartSlider = document.getElementById('loopStartSlider');
      const loopEndSlider = document.getElementById('loopEndSlider');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndValue = document.getElementById('loopEndValue');
      const keyboard = document.getElementById('keyboard');
      const errorMessage = document.getElementById('errorMessage');

      // Audio context and nodes
      let audioContext;
      let audioBuffer;
      let masterGain;
      let duration = 1;
      let activeVoices = new Map(); // Map of MIDI note to VoiceNode

      // Voice pool for polyphony
      const MAX_VOICES = 4; // Reduced from 8 to minimize issues
      let voicePool = [];

      // Flag to track if the worklet has been initialized
      let workletInitialized = false;

      // Initialize audio context
      async function initAudio() {
        if (audioContext) {
          console.warn('context already running');
          return;
        }
        try {
          audioContext = new AudioContext();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.7;
          masterGain.connect(audioContext.destination);

          console.log('AudioContext initialized');

          // Pre-initialize a single LoopWorklet to avoid multiple registrations
          if (!workletInitialized) {
            try {
              const dummyWorklet = new LoopWorklet(audioContext);
              await dummyWorklet.initialise();
              workletInitialized = true;
            } catch (error) {
              // If it fails because the processor is already registered, that's fine
              if (
                error.message &&
                error.message.includes('already registered')
              ) {
                console.warn('Loop processor already registered');
                workletInitialized = true;
              } else {
                console.error('Error initializing worklet:', error);
                showError(
                  'Error initializing audio processors. Try refreshing the page.'
                );
              }
            }
          }
        } catch (error) {
          console.error('Error initializing audio context:', error);
          showError('Failed to initialize audio context: ' + error.message);
        }
      }

      // Display error message
      function showError(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';

        // Auto-hide after 5 seconds
        setTimeout(() => {
          errorMessage.style.display = 'none';
        }, 5000);
      }

      // Load and decode audio file
      async function loadAudioFile(file) {
        try {
          const arrayBuffer = await file.arrayBuffer();
          await decodeAndSetupAudio(arrayBuffer);
        } catch (error) {
          console.error('Error loading audio file:', error);
          showError('Failed to load audio file: ' + error.message);
        }
      }

      // Load audio from URL
      async function loadAudioFromUrl(url) {
        try {
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          await decodeAndSetupAudio(arrayBuffer);
        } catch (error) {
          console.error('Error loading audio from URL:', error);
          showError('Failed to load audio: ' + error.message);
        }
      }

      // Decode audio and set up the buffer
      async function decodeAndSetupAudio(arrayBuffer) {
        try {
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          if (!isValidAudioBuffer(audioBuffer)) {
            throw new Error('Invalid audio buffer');
          }

          duration = audioBuffer.duration;
          console.log(`Audio loaded: ${duration.toFixed(2)} seconds`);

          // Update slider ranges based on audio duration
          loopStartSlider.max = duration;
          loopEndSlider.max = duration;
          loopEndSlider.value = duration;
          loopEndValue.textContent = duration.toFixed(2);

          // Initialize voice pool
          await initializeVoicePool();
        } catch (error) {
          console.error('Error setting up audio:', error);
          showError('Error setting up audio: ' + error.message);
        }
      }

      // Create a single voice with error handling
      async function createVoice() {
        try {
          // Create the voice with current settings
          const voice = new VoiceNode(audioContext, audioBuffer, masterGain, {
            type: 'AR',
            params: {
              attackMs: parseFloat(attackSlider.value),
              releaseMs: parseFloat(releaseSlider.value),
            },
          });

          // Set loop parameters
          updateVoiceLoopSettings(voice);

          voice.setVolume(0.5);
          console.log('volume set:', voice);

          return voice;
        } catch (error) {
          // Handle registration errors more gracefully
          if (
            error.name === 'NotSupportedError' &&
            error.message.includes('already registered')
          ) {
            console.warn('Processor already registered, proceeding anyway');

            // Alternative implementation that doesn't rely on the worklet registration
            // This is a simplified fallback that might not have all features
            const voice = new VoiceNode(audioContext, audioBuffer, masterGain, {
              type: 'AR',
              params: {
                attackMs: parseFloat(attackSlider.value),
                releaseMs: parseFloat(releaseSlider.value),
              },
            });

            return voice;
          }

          // For other errors, we throw
          throw error;
        }
      }

      // Initialize voice pool with sequential creation to avoid race conditions
      async function initializeVoicePool() {
        // Clean up existing voices
        for (const voice of voicePool) {
          if (voice) {
            try {
              voice.disconnect();
            } catch (e) {
              console.warn('Error disconnecting voice:', e);
            }
          }
        }

        voicePool = [];

        // Create voices one at a time with delay between
        for (let i = 0; i < MAX_VOICES; i++) {
          try {
            // Add a small delay between voice creation to avoid race conditions
            if (i > 0) {
              await new Promise((resolve) => setTimeout(resolve, 50));
            }

            const voice = await createVoice();

            if (voice) {
              voicePool.push(voice);
            }
          } catch (error) {
            console.error(`Error creating voice ${i}:`, error);

            // Show error but only once
            if (i === 0) {
              showError(
                'Error creating audio voices. Some features may not work.'
              );
            }
          }
        }

        console.log(`Voice pool initialized with ${voicePool.length} voices`);
      }

      // Get an available voice from the pool
      function getAvailableVoice() {
        if (voicePool.length === 0) return null;

        // First, check for completely available voices
        for (const voice of voicePool) {
          if (voice.isAvailable()) {
            return voice;
          }
        }

        // If no available voices, find the oldest releasing voice
        for (const voice of voicePool) {
          if (voice.isReleasing()) {
            return voice;
          }
        }

        // If no releasing voices, steal the first voice
        return voicePool[0];
      }

      // Play a note
      function playNote(midiNote) {
        if (!audioBuffer || voicePool.length === 0) {
          showError('No audio loaded or voices available');
          return;
        }

        const voice = getAvailableVoice();
        console.log('voice: ', voice);
        if (!voice) {
          showError('No voices available');
          return;
        }

        try {
          // Play the note
          voice.play(midiNote);

          // Store in active voices
          activeVoices.set(midiNote, voice);

          // Highlight the key
          const keyElement = document.querySelector(
            `.key[data-note="${midiNote}"]`
          );
          if (keyElement) {
            keyElement.classList.add('active');
            keyElement.style.backgroundColor = keyElement.classList.contains(
              'black'
            )
              ? '#444'
              : '#ccc';
          }
        } catch (error) {
          console.error('Error playing note:', error);
          showError('Error playing note: ' + error.message);
        }
      }

      // Release a note
      function releaseNote(midiNote) {
        const voice = activeVoices.get(midiNote);
        if (voice) {
          try {
            voice.release();
            activeVoices.delete(midiNote);

            // Remove highlight from key
            const keyElement = document.querySelector(
              `.key[data-note="${midiNote}"]`
            );
            if (keyElement) {
              keyElement.classList.remove('active');
              keyElement.style.backgroundColor = keyElement.classList.contains(
                'black'
              )
                ? 'black'
                : 'white';
            }
          } catch (error) {
            console.error('Error releasing note:', error);
          }
        }
      }

      // Update loop settings for a voice
      function updateVoiceLoopSettings(voice) {
        if (!voice) return;
        if (audioContext.state !== 'running') {
          audioContext.resume();
        }

        try {
          const shouldLoop = loopCheckbox.checked;
          const loopStart = parseFloat(loopStartSlider.value);
          const loopEnd = parseFloat(loopEndSlider.value);

          voice.setLoop(shouldLoop, loopStart, loopEnd);
        } catch (error) {
          console.warn('Error updating loop settings:', error);
        }
      }

      // Create virtual keyboard
      function createKeyboard() {
        const startNote = 60; // C4
        const endNote = 84; // C6

        const whiteKeys = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B offsets
        const blackKeys = [1, 3, 6, 8, 10]; // C#, D#, F#, G#, A# offsets

        // Create container for keyboard
        for (let note = startNote; note <= endNote; note++) {
          const octave = Math.floor(note / 12) - 1;
          const noteInOctave = note % 12;

          const isBlackKey = blackKeys.includes(noteInOctave);
          const keyElement = document.createElement('div');

          keyElement.className = `key ${isBlackKey ? 'black' : 'white'}`;
          keyElement.dataset.note = note;

          // Add note name
          const noteNames = [
            'C',
            'C#',
            'D',
            'D#',
            'E',
            'F',
            'F#',
            'G',
            'G#',
            'A',
            'A#',
            'B',
          ];
          keyElement.textContent = `${noteNames[noteInOctave]}${octave}`;

          // Add event listeners
          keyElement.addEventListener('mousedown', () => {
            playNote(note);
          });

          keyElement.addEventListener('mouseup', () => {
            releaseNote(note);
          });

          keyElement.addEventListener('mouseleave', () => {
            if (keyElement.classList.contains('active')) {
              releaseNote(note);
            }
          });

          // Append to keyboard
          keyboard.appendChild(keyElement);
        }
      }

      // Event listeners
      fileInput.addEventListener('change', async (e) => {
        if (!audioContext) {
          await initAudio();
        } else if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        if (e.target.files.length > 0) {
          await loadAudioFile(e.target.files[0]);
        }
      });

      sampleSelect.addEventListener('change', async (e) => {
        if (!audioContext) {
          await initAudio();
        } else if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        const selectedSample = e.target.value;
        if (selectedSample) {
          await loadAudioFromUrl(selectedSample);
        }
      });

      attackSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        attackValue.textContent = value;

        // Update existing voices
        voicePool.forEach((voice) => {
          try {
            if (voice && voice.ampEnvNode && voice.ampEnvNode.params) {
              voice.ampEnvNode.params.attackMs = value;
            }
          } catch (error) {
            console.warn('Error updating attack time:', error);
          }
        });
      });

      releaseSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        releaseValue.textContent = value;

        // Update existing voices
        voicePool.forEach((voice) => {
          try {
            if (voice && voice.ampEnvNode && voice.ampEnvNode.params) {
              voice.ampEnvNode.params.releaseMs = value;
            }
          } catch (error) {
            console.warn('Error updating release time:', error);
          }
        });
      });

      loopCheckbox.addEventListener('change', () => {
        voicePool.forEach((voice) => {
          updateVoiceLoopSettings(voice);
        });
      });

      loopStartSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        loopStartValue.textContent = value.toFixed(2);

        // Ensure loop start is less than loop end
        if (value >= loopEndSlider.value) {
          loopEndSlider.value = Math.min(value + 0.1, duration);
          loopEndValue.textContent = loopEndSlider.value.toFixed(2);
        }

        voicePool.forEach((voice) => {
          updateVoiceLoopSettings(voice);
        });
      });

      loopEndSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        loopEndValue.textContent = value.toFixed(2);

        // Ensure loop end is greater than loop start
        if (value <= loopStartSlider.value) {
          loopStartSlider.value = Math.max(value - 0.1, 0);
          loopStartValue.textContent = loopStartSlider.value.toFixed(2);
        }

        voicePool.forEach((voice) => {
          updateVoiceLoopSettings(voice);
        });
      });

      // Keyboard event handlers for computer keyboard
      document.addEventListener('keydown', (e) => {
        if (e.repeat) return; // Prevent multiple triggers when key is held

        // Map computer keyboard to musical keyboard (Z = C4, X = D4, etc.)
        const keyMap = {
          z: 60,
          s: 61,
          x: 62,
          d: 63,
          c: 64,
          v: 65,
          g: 66,
          b: 67,
          h: 68,
          n: 69,
          j: 70,
          m: 71,
          ',': 72,
          l: 73,
          '.': 74,
          ';': 75,
          '/': 76,
        };

        if (keyMap[e.key.toLowerCase()]) {
          playNote(keyMap[e.key.toLowerCase()]);
        }
      });

      document.addEventListener('keyup', (e) => {
        const keyMap = {
          z: 60,
          s: 61,
          x: 62,
          d: 63,
          c: 64,
          v: 65,
          g: 66,
          b: 67,
          h: 68,
          n: 69,
          j: 70,
          m: 71,
          ',': 72,
          l: 73,
          '.': 74,
          ';': 75,
          '/': 76,
        };

        if (keyMap[e.key.toLowerCase()]) {
          releaseNote(keyMap[e.key.toLowerCase()]);
        }
      });

      // Initialize
      window.addEventListener('load', async () => {
        createKeyboard();
        await initAudio();
      });
    </script>
  </body>
</html>
