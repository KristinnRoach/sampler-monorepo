<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimized Loop Controller</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      h1 {
        color: #333;
        border-bottom: 1px solid #ddd;
        padding-bottom: 10px;
      }

      .controls {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background: #f8f8f8;
      }

      button {
        padding: 8px 16px;
        margin: 0 10px 10px 0;
        cursor: pointer;
        background: #0066cc;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: 500;
      }

      button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      .slider-container {
        margin: 15px 0;
      }

      label {
        display: inline-block;
        width: 120px;
        font-weight: 500;
      }

      input[type='range'] {
        width: 300px;
        vertical-align: middle;
      }

      .value-display {
        display: inline-block;
        min-width: 60px;
        text-align: right;
        margin-left: 10px;
      }

      .waveform {
        width: 100%;
        height: 150px;
        background: #eee;
        margin: 20px 0;
        position: relative;
        border-radius: 4px;
      }

      .loop-region {
        position: absolute;
        height: 100%;
        background: rgba(0, 128, 255, 0.3);
        top: 0;
        border-radius: 4px;
      }

      .status {
        margin-top: 20px;
        padding: 12px;
        background-color: #f0f0f0;
        border-radius: 5px;
        border-left: 4px solid #0066cc;
      }
    </style>
  </head>
  <body>
    <h1>Optimized Loop Controller</h1>

    <div class="controls">
      <button id="loadSound">Load Sound</button>
      <button id="playSound" disabled>Play</button>
      <button id="stopSound" disabled>Stop</button>

      <div class="slider-container">
        <label for="loopStart">Loop Start:</label>
        <input
          type="range"
          id="loopStart"
          min="0"
          max="1"
          value="0"
          step="0.01"
          disabled
        />
        <span id="loopStartValue" class="value-display">0.00s</span>
      </div>

      <div class="slider-container">
        <label for="loopEnd">Loop End:</label>
        <input
          type="range"
          id="loopEnd"
          min="0"
          max="1"
          value="1"
          step="0.01"
          disabled
        />
        <span id="loopEndValue" class="value-display">0.00s</span>
      </div>

      <div class="slider-container">
        <label for="rampDuration">Ramp Duration:</label>
        <input
          type="range"
          id="rampDuration"
          min="0"
          max="1"
          value="0.1"
          step="0.01"
          disabled
        />
        <span id="rampDurationValue" class="value-display">0.10s</span>
      </div>
    </div>

    <div class="waveform" id="waveform">
      <div class="loop-region" id="loopRegion"></div>
    </div>

    <div class="status" id="status">Status: Ready to load sound</div>

    <script type="module">
      import { OptimizedLoopWorkletNode } from './OptimizedLoopWorkletNode.js';

      // State variables
      let audioContext = null;
      let sourceNode = null;
      let loopWorklet = null;
      let audioBuffer = null;
      let duration = 0;
      let currentRampDuration = 0.1;

      // UI Elements
      const loadButton = document.getElementById('loadSound');
      const playButton = document.getElementById('playSound');
      const stopButton = document.getElementById('stopSound');
      const loopStartSlider = document.getElementById('loopStart');
      const loopEndSlider = document.getElementById('loopEnd');
      const rampDurationSlider = document.getElementById('rampDuration');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndValue = document.getElementById('loopEndValue');
      const rampDurationValue = document.getElementById('rampDurationValue');
      const statusDisplay = document.getElementById('status');
      const loopRegion = document.getElementById('loopRegion');

      // Add visualization updates during playback
      let visualizationInterval = null;

      // Status logging helper
      function logStatus(message) {
        statusDisplay.textContent = 'Status: ' + message;
        console.log(message);
      }

      // Update loop visualization
      function updateLoopVisualization() {
        if (!duration) return;

        const startPercent =
          (parseFloat(loopStartSlider.value) / duration) * 100;
        const endPercent = (parseFloat(loopEndSlider.value) / duration) * 100;

        loopRegion.style.left = startPercent + '%';
        loopRegion.style.width = endPercent - startPercent + '%';
      }

      // Initialize audio context and loop controller
      async function initAudio() {
        try {
          audioContext = new AudioContext();
          loopWorklet = await OptimizedLoopWorkletNode.create(audioContext);

          logStatus('Audio system initialized');
          return true;
        } catch (error) {
          logStatus('Error initializing audio: ' + error.message);
          console.error(error);
          return false;
        }
      }

      // Load a sample sound
      async function loadSampleSound() {
        try {
          // Initialize audio system if needed
          if (!audioContext) {
            if (!(await initAudio())) {
              return;
            }
          }

          // Load a sample sound
          const response = await fetch('../audio-samples/trimmed.wav');
          const arrayBuffer = await response.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          duration = audioBuffer.duration;

          // Update UI
          loopStartSlider.max = duration;
          loopEndSlider.max = duration;
          loopEndSlider.value = duration;
          loopEndValue.textContent = duration.toFixed(2) + 's';

          // Enable controls
          playButton.disabled = false;
          loopStartSlider.disabled = false;
          loopEndSlider.disabled = false;
          rampDurationSlider.disabled = false;

          updateLoopVisualization();
          logStatus(`Sound loaded: ${duration.toFixed(2)} seconds`);
        } catch (error) {
          logStatus('Error loading sound: ' + error.message);
          console.error(error);
        }
      }

      // Set up audio for playback
      function setupAudio() {
        if (!audioBuffer) return false;

        try {
          // Create source node
          sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.loop = true;

          // Set initial loop points
          sourceNode.loopStart = parseFloat(loopStartSlider.value);
          sourceNode.loopEnd = parseFloat(loopEndSlider.value);

          // Connect worklet to source for control (no audio routing)
          loopWorklet.connectToSource(sourceNode);

          // Connect source directly to output for minimal latency
          sourceNode.connect(audioContext.destination);

          return true;
        } catch (error) {
          logStatus('Error setting up audio: ' + error.message);
          console.error(error);
          return false;
        }
      }

      // Play the sound
      async function playSound() {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        if (sourceNode && sourceNode.context.state === 'running') {
          // Already playing
          return;
        }

        if (setupAudio()) {
          sourceNode.start();
          playButton.disabled = true;
          stopButton.disabled = false;
          logStatus('Playing sound');

          // Start visualization updates
          if (visualizationInterval) clearInterval(visualizationInterval);
          visualizationInterval = setInterval(() => {
            if (sourceNode && loopWorklet && loopWorklet.sourceNode) {
              // Log current playback position occasionally
              if (Math.random() < 0.01) {
                console.log(
                  `Playback at: ${audioContext.currentTime.toFixed(2)}s`
                );
                console.log(
                  `Loop points: ${sourceNode.loopStart.toFixed(2)}s - ${sourceNode.loopEnd.toFixed(2)}s`
                );
              }
            }
          }, 100);
        }
      }

      // Stop the sound
      function stopSound() {
        if (sourceNode) {
          try {
            sourceNode.stop();
          } catch (error) {
            // Ignore errors when stopping (might already be stopped)
          }
          sourceNode = null;
          playButton.disabled = false;
          stopButton.disabled = true;
          logStatus('Stopped sound');

          if (visualizationInterval) {
            clearInterval(visualizationInterval);
            visualizationInterval = null;
          }
        }
      }

      // Load button click
      loadButton.addEventListener('click', loadSampleSound);

      // Play button click
      playButton.addEventListener('click', playSound);

      // Stop button click
      stopButton.addEventListener('click', stopSound);

      // Loop start slider
      loopStartSlider.addEventListener('input', () => {
        const value = parseFloat(loopStartSlider.value);
        loopStartValue.textContent = value.toFixed(2) + 's';

        // Ensure loop start doesn't exceed loop end
        if (value >= parseFloat(loopEndSlider.value)) {
          loopStartSlider.value = parseFloat(loopEndSlider.value) - 0.01;
        }

        if (loopWorklet) {
          loopWorklet.setLoopStart(
            parseFloat(loopStartSlider.value),
            currentRampDuration
          );
        }

        updateLoopVisualization();
      });

      // Loop end slider
      loopEndSlider.addEventListener('input', () => {
        const value = parseFloat(loopEndSlider.value);
        loopEndValue.textContent = value.toFixed(2) + 's';

        // Ensure loop end doesn't go below loop start
        if (value <= parseFloat(loopStartSlider.value)) {
          loopEndSlider.value = parseFloat(loopStartSlider.value) + 0.01;
        }

        if (loopWorklet) {
          loopWorklet.setLoopEnd(
            parseFloat(loopEndSlider.value),
            currentRampDuration
          );
        }

        updateLoopVisualization();
      });

      // Ramp duration slider
      rampDurationSlider.addEventListener('input', () => {
        currentRampDuration = parseFloat(rampDurationSlider.value);
        rampDurationValue.textContent = currentRampDuration.toFixed(2) + 's';
      });

      // Initial status
      logStatus('Ready - Click "Load Sound" to begin');
    </script>
  </body>
</html>
