App Skeleton

// App.jsx
import React, { useState } from 'react';
import CreateNode from './components/CreateNode';
import SelectedNodeSettingsSidebar from './components/SelectedNodeSettingsSidebar';
import Node from './components/Node';

// Basic styles for dark theme and responsive layout
const appStyles = {
display: 'flex',
height: '100vh',
backgroundColor: '#121212',
color: '#e0e0e0',
fontFamily: 'Arial, sans-serif',
};

const graphAreaStyles = {
flex: 1,
position: 'relative',
overflow: 'auto',
padding: '1rem',
};

const nodeContainerStyles = {
position: 'relative',
width: '100%',
height: '100%',
};

const sidebarStyles = {
width: '300px',
backgroundColor: '#1e1e1e',
borderLeft: '1px solid #333',
padding: '1rem',
overflowY: 'auto',
boxSizing: 'border-box',
};

const initialNodeTypes = ['TypeA', 'TypeB', 'TypeC'];

function App() {
// State for nodes, edges, selected node, and creation menu
const [nodes, setNodes] = useState([]);
const [edges, setEdges] = useState([]); // edges as { fromNodeId, fromOutput, toNodeId, toInput }
const [selectedNodeId, setSelectedNodeId] = useState(null);
const [showCreateMenu, setShowCreateMenu] = useState(false);

// Position counter to place new nodes with some offset
const [nextPosition, setNextPosition] = useState({ x: 50, y: 50 });

// Add a new node to the graph
const addNode = (nodeType) => {
const newNode = {
id: `node-${Date.now()}`,
type: nodeType,
position: { ...nextPosition },
inputs: ['input1'], // Could be dynamic per nodeType
outputs: ['output1'],
data: {}, // Custom data for node settings
};
setNodes((prev) => [...prev, newNode]);
setSelectedNodeId(newNode.id);
setNextPosition((pos) => ({ x: pos.x + 40, y: pos.y + 40 }));
setShowCreateMenu(false);
};

// Update node position on drag
const updateNodePosition = (id, newPos) => {
setNodes((prev) =>
prev.map((node) =>
node.id === id ? { ...node, position: newPos } : node
)
);
};

// Update node data (settings)
const updateNodeData = (id, newData) => {
setNodes((prev) =>
prev.map((node) => (node.id === id ? { ...node, data: newData } : node))
);
};

// Basic connection handler from output to input
// For demo, we connect first output to first input of another node on click
const connectNodes = (fromNodeId, toNodeId) => {
if (fromNodeId === toNodeId) return; // prevent self connection
const exists = edges.some(
(e) => e.fromNodeId === fromNodeId && e.toNodeId === toNodeId
);
if (!exists) {
setEdges((prev) => [
...prev,
{
fromNodeId,
fromOutput: 'output1',
toNodeId,
toInput: 'input1',
},
]);
}
};

// Find selected node object
const selectedNode = nodes.find((n) => n.id === selectedNodeId) || null;

return (

<div style={appStyles}>
<div style={graphAreaStyles}>
{/_ Create Node Button and Menu _/}
<div style={{ marginBottom: '1rem' }}>
<button
onClick={() => setShowCreateMenu((v) => !v)}
style={{
              backgroundColor: '#333',
              color: '#e0e0e0',
              border: 'none',
              padding: '0.5rem 1rem',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
aria-label="Create node" > + Create Node
</button>
{showCreateMenu && (
<CreateNode
nodeTypes={initialNodeTypes}
onSelect={addNode}
onCancel={() => setShowCreateMenu(false)}
/>
)}
</div>

        {/* Nodes container */}
        <div style={nodeContainerStyles}>
          {nodes.map((node) => (
            <Node
              key={node.id}
              node={node}
              isSelected={node.id === selectedNodeId}
              onSelect={() => setSelectedNodeId(node.id)}
              onDrag={(pos) => updateNodePosition(node.id, pos)}
              onConnectTo={(targetNodeId) => connectNodes(node.id, targetNodeId)}
            />
          ))}

          {/* Simple SVG edges rendering */}
          <svg
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              pointerEvents: 'none',
              overflow: 'visible',
            }}
          >
            {edges.map(({ fromNodeId, toNodeId }, i) => {
              const fromNode = nodes.find((n) => n.id === fromNodeId);
              const toNode = nodes.find((n) => n.id === toNodeId);
              if (!fromNode || !toNode) return null;
              // Calculate points (simple: center of node outputs/inputs)
              const fromX = fromNode.position.x + 150; // node width approx
              const fromY = fromNode.position.y + 30;
              const toX = toNode.position.x;
              const toY = toNode.position.y + 30;
              const path = `M${fromX},${fromY} C${fromX + 50},${fromY} ${toX - 50},${toY} ${toX},${toY}`;
              return (
                <path
                  key={i}
                  d={path}
                  stroke="#61dafb"
                  strokeWidth="2"
                  fill="none"
                  markerEnd="url(#arrowhead)"
                />
              );
            })}
            <defs>
              <marker
                id="arrowhead"
                markerWidth="10"
                markerHeight="7"
                refX="10"
                refY="3.5"
                orient="auto"
              >
                <polygon points="0 0, 10 3.5, 0 7" fill="#61dafb" />
              </marker>
            </defs>
          </svg>
        </div>
      </div>

      {/* Sidebar for selected node settings */}
      <aside style={sidebarStyles}>
        {selectedNode ? (
          <SelectedNodeSettingsSidebar
            node={selectedNode}
            onChange={(newData) => updateNodeData(selectedNode.id, newData)}
          />
        ) : (
          <p>Select a node to edit its settings</p>
        )}
      </aside>
    </div>

);
}

export default App;
jsx
copyCopy code
// components/CreateNode.jsx
import React from 'react';

const menuStyles = {
marginTop: '0.5rem',
backgroundColor: '#222',
border: '1px solid #555',
borderRadius: '4px',
padding: '0.5rem',
maxWidth: '200px',
color: '#e0e0e0',
userSelect: 'none',
};

const buttonStyles = {
display: 'block',
width: '100%',
backgroundColor: '#333',
color: '#e0e0e0',
border: 'none',
padding: '0.4rem 0.5rem',
margin: '0.2rem 0',
borderRadius: '3px',
cursor: 'pointer',
textAlign: 'left',
};

export default function CreateNode({ nodeTypes, onSelect, onCancel }) {
return (

<div style={menuStyles} role="menu" aria-label="Select node type to create">
{nodeTypes.map((type) => (
<button
key={type}
style={buttonStyles}
onClick={() => onSelect(type)}
role="menuitem"
tabIndex={0} >
{type}
</button>
))}
<button
style={{ ...buttonStyles, backgroundColor: '#550000' }}
onClick={onCancel}
aria-label="Cancel node creation" >
Cancel
</button>
</div>
);
}
jsx
copyCopy code
// components/Node.jsx
import React, { useRef, useState, useEffect } from 'react';

// Node box styles
const nodeStyles = (isSelected) => ({
position: 'absolute',
width: 150,
padding: '0.5rem',
backgroundColor: isSelected ? '#333' : '#222',
border: isSelected ? '2px solid #61dafb' : '2px solid transparent',
borderRadius: 6,
color: '#e0e0e0',
userSelect: 'none',
cursor: 'grab',
boxShadow: isSelected ? '0 0 8px #61dafb' : 'none',
});

// Simple input/output port styles
const portStyles = {
width: 12,
height: 12,
borderRadius: '50%',
backgroundColor: '#61dafb',
display: 'inline-block',
cursor: 'pointer',
};

const inputPortContainer = {
display: 'flex',
justifyContent: 'flex-start',
marginBottom: 6,
};

const outputPortContainer = {
display: 'flex',
justifyContent: 'flex-end',
marginTop: 6,
};

export default function Node({ node, isSelected, onSelect, onDrag, onConnectTo }) {
const nodeRef = useRef(null);
const [dragging, setDragging] = useState(false);
const [relPos, setRelPos] = useState({ x: 0, y: 0 });

// Handle mouse down for drag start
const onMouseDown = (e) => {
e.stopPropagation();
const rect = nodeRef.current.getBoundingClientRect();
setRelPos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
setDragging(true);
onSelect();
};

// Handle mouse move for dragging
const onMouseMove = (e) => {
if (!dragging) return;
e.preventDefault();
const newX = e.clientX - relPos.x;
const newY = e.clientY - relPos.y;
onDrag({ x: newX, y: newY });
};

// Handle mouse up to stop dragging
const onMouseUp = () => {
setDragging(false);
};

// Attach and detach global mouse event listeners during drag
useEffect(() => {
if (dragging) {
window.addEventListener('mousemove', onMouseMove);
window.addEventListener('mouseup', onMouseUp);
return () => {
window.removeEventListener('mousemove', onMouseMove);
window.removeEventListener('mouseup', onMouseUp);
};
}
}, [dragging]);

// Connect on output port click - for demo, connect to first other node on click
const handleOutputClick = () => {
onConnectTo(node.id);
};

return (

<div
ref={nodeRef}
onMouseDown={onMouseDown}
style={{
        ...nodeStyles(isSelected),
        left: node.position.x,
        top: node.position.y,
      }}
role="button"
tabIndex={0}
aria-pressed={isSelected}
aria-label={`Node ${node.id} of type ${node.type}`}
onClick={(e) => {
e.stopPropagation();
onSelect();
}} >
<div style={{ fontWeight: 'bold', marginBottom: '0.3rem' }}>{node.type}</div>

      {/* Inputs */}
      <div style={inputPortContainer}>
        {node.inputs.map((input) => (
          <span
            key={input}
            style={{ ...portStyles, backgroundColor: '#ff5555' }}
            aria-label={`Input port ${input}`}
          />
        ))}
      </div>

      {/* Outputs */}
      <div style={outputPortContainer}>
        {node.outputs.map((output) => (
          <span
            key={output}
            style={portStyles}
            onClick={(e) => {
              e.stopPropagation();
              handleOutputClick();
            }}
            aria-label={`Output port ${output}, click to connect`}
            role="button"
            tabIndex={0}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleOutputClick();
              }
            }}
          />
        ))}
      </div>
    </div>

);
}
jsx
copyCopy code
// components/SelectedNodeSettingsSidebar.jsx
import React, { useState, useEffect } from 'react';

const labelStyles = {
display: 'block',
marginBottom: '0.25rem',
fontSize: '0.9rem',
color: '#ccc',
};

const inputStyles = {
width: '100%',
padding: '0.4rem',
borderRadius: '4px',
border: '1px solid #555',
backgroundColor: '#222',
color: '#e0e0e0',
marginBottom: '1rem',
boxSizing: 'border-box',
};

export default function SelectedNodeSettingsSidebar({ node, onChange }) {
// Local state for editable fields (for demo, we allow editing a "label")
const [label, setLabel] = useState(node.data.label || '');

useEffect(() => {
setLabel(node.data.label || '');
}, [node]);

// Update parent on changes
const handleLabelChange = (e) => {
setLabel(e.target.value);
onChange({ ...node.data, label: e.target.value });
};

return (

<section aria-label={`Settings for node ${node.id}`}>
<h2 style={{ color: '#61dafb' }}>Node Settings</h2>

      <label htmlFor="node-label" style={labelStyles}>
        Label
      </label>
      <input
        id="node-label"
        type="text"
        value={label}
        onChange={handleLabelChange}
        style={inputStyles}
        placeholder="Node label"
        autoComplete="off"
      />
    </section>

);
}
This React application skeleton includes:

A dark-themed, responsive layout with a main graph area and a sidebar.
A
CreateNode
component showing a menu to pick node types.
Nodes are draggable and selectable in the
Node
component.
Outputs on nodes can be clicked to connect to other nodes (simple connect logic demo).
The
SelectedNodeSettingsSidebar
allows editing a single
label
property for the selected node.
Edges are drawn as SVG cubic Bezier curves with arrowheads.
Accessibility considerations with ARIA roles and keyboard handlers.
Comments and styling included inline for clarity and maintainability.
You can expand node inputs/outputs, connection logic, and node settings as needed. This skeleton supports the core functionality you requested.
