import { PlaybackTiming } from '../shared/PlaybackTiming';
import { MIN_ABS_AMPLITUDE } from '../shared/constants';

class SamplePlayerProcessor extends AudioWorkletProcessor {
  constructor() {
    super();

    /* STATE */

    // Data
    this.buffer = null;
    this.playbackPosition = 0;
    this.loopCount = 0;
    this.timing = new PlaybackTiming();

    // FLAGS
    this.isReleasing = false;
    this.loopEnabled = false;
    this.usePlaybackPosition = false;

    /* Message handling */
    this.port.onmessage = this.#handleMessage.bind(this);
  }

  #handleMessage(event) {
    const { type, value, buffer, startOffset, duration, when } = event.data;

    switch (type) {
      case 'voice:init':
        this.#resetState();
        break;

      case 'voice:set_buffer':
        this.#resetState();
        this.buffer = buffer;
        break;

      case 'voice:start':
        this.isReleasing = false;
        this.timing.start(when, startOffset || 0, duration);
        this.playbackPosition = (startOffset || 0) * sampleRate;

        this.port.postMessage({
          type: 'voice:started',
          time: currentTime,
        });
        break;

      case 'voice:release':
        this.isReleasing = true;
        break;

      case 'voice:stop':
        this.timing.stop(currentTime);
        break;

      case 'setLoopEnabled':
        this.loopEnabled = value;
        break;

      case 'voice:usePlaybackPosition':
        this.usePlaybackPosition = value;
        break;
    }
  }

  #resetState() {
    this.timing.clear();
    this.playbackPosition = 0;
    this.loopCount = 0;
    this.isReleasing = false;
  }

  static get parameterDescriptors() {
    return [
      {
        name: 'playbackPosition',
        defaultValue: 0,
        minValue: 0,
        automationRate: 'k-rate',
      },
      {
        name: 'envGain',
        defaultValue: 0,
        minValue: 0,
        maxValue: 1,
        automationRate: 'k-rate',
      },
      {
        name: 'velocity',
        defaultValue: 100,
        minValue: 0,
        maxValue: 127,
        automationRate: 'k-rate',
      },
      {
        name: 'playbackRate',
        defaultValue: 1,
        minValue: -4,
        maxValue: 4,
        automationRate: 'a-rate',
      },
      {
        name: 'loopStart',
        defaultValue: 0,
        minValue: 0,
        automationRate: 'k-rate',
      },
      {
        name: 'loopEnd',
        defaultValue: 0,
        minValue: 0,
        automationRate: 'k-rate',
      },
    ];
  }

  #fillWithSilence(output) {
    for (let channel = 0; channel < output.length; channel++) {
      output[channel].fill(0);
    }
  }

  #onended(output) {
    this.isReleasing = false;
    if (this.timing) this.timing.clear();

    this.playbackPosition = 0;
    this.port.postMessage({ type: 'voice:ended' });
  }

  #shouldEnd(parameters) {
    return (
      !this.buffer ||
      !this.buffer.length ||
      !this.timing.isActive(currentTime) ||
      // this.timing.shouldStop(currentTime) ||
      (this.isReleasing && parameters.envGain[0] <= MIN_ABS_AMPLITUDE)
    );
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];

    // ? re-design flags to be set by input events and listen for them here
    if (!output || this.#shouldEnd(parameters)) {
      this.#onended(output);
      return true; // AudioWorklet will zero-fill automatically
    }

    const pbRate = parameters.playbackRate[0];
    const loopStart = parameters.loopStart[0] * sampleRate;
    const loopEnd = parameters.loopEnd[0] * sampleRate;
    const envelopeGain = parameters.envGain[0];
    const velocityGain = parameters.velocity[0]; // ? already normalized from midi ?

    const numChannels = Math.min(output.length, this.buffer.length);
    const bufferLength = this.buffer[0].length;

    if (!this.timing.isActive(currentTime)) {
      console.error('timing not active');
      this.#onended(output);
      return true;
    }

    // Process samples
    for (let i = 0; i < output[0].length; i++) {
      // Handle looping
      if (this.loopEnabled && this.playbackPosition >= loopEnd) {
        this.playbackPosition = loopStart;
        this.loopCount++;
        this.port.postMessage({
          type: 'voice:looped',
          loopCount: this.loopCount,
        });
      }

      // Check for end of buffer
      if (this.playbackPosition >= bufferLength) {
        this.#onended(output);
        return true;
      }

      // Read and interpolate samples
      const position = Math.floor(this.playbackPosition);
      const fraction = this.playbackPosition - position;
      const nextPosition = Math.min(position + 1, bufferLength - 1);

      for (let c = 0; c < numChannels; c++) {
        const bufferChannel = this.buffer[Math.min(c, this.buffer.length - 1)];
        const current = bufferChannel[position];
        const next = bufferChannel[nextPosition];

        output[c][i] =
          (current + fraction * (next - current)) * velocityGain * envelopeGain;
      }

      // Advance playback position
      this.playbackPosition += pbRate;
    }

    if (this.usePlaybackPosition) {
      this.port.postMessage({
        type: 'voice:position',
        position: this.playbackPosition / sampleRate,
      });
    }

    return true;
  }
}

registerProcessor('sample-player-processor', SamplePlayerProcessor);
