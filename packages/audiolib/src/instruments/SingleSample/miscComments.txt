
/* Old multi processor support initialization

const DEFAULT_SSPLAYER_PROCESSORS = ['loop-processor'];

export async function createSingleSamplePlayer(
  id: string,
  sampleBuffer: AudioBuffer,
  options?: {
    polyphony?: number;
    rootNote?: number;
  },
  processorNamesChain: string[] = DEFAULT_SSPLAYER_PROCESSORS,
  outputDestination?: AudioNode
): Promise<SingleSamplePlayer> {
  const audioContext = await getAudioContext();

  outputDestination = outputDestination || audioContext.destination;

  let processorNodes: BaseWorkletNode[] = [];

  // create worklet nodes for each processor
  processorNamesChain.forEach((name) => {
    if (!registry.hasRegistered(name)) {
      throw new Error(`Processor: ${name} not registered!`);
    }
    const node: BaseWorkletNode = createWorkletNode(audioContext, name);
    if (!node) throw new Error('Could not create processor node', node);
    processorNodes.push(node);
  });

  const player = new SingleSamplePlayer(
    id,
    audioContext,
    sampleBuffer,
    options
  );

  player.init(outputDestination, processorNodes);

  console.log(
    'SingleSamplePlayer initialized with worklet processor nodes: ',
    processorNodes,
    'provided processorNames: ',
    processorNamesChain,
    'sampleBuffer: ',
    sampleBuffer,
    'audio context: ',
    audioContext,
    'output: ',
    outputDestination
  );

  return player;
}


export class SingleSamplePlayer extends EventTarget {

  ...

  #outputGain: GainNode;
  #processorChain: BaseWorkletNode[] = [];

  ...

  init(
    destinationNode: AudioNode = this.#context.destination,
    processorChain: BaseWorkletNode[] = []
  ): boolean {
    // TEMP
    if (!this.#context.audioWorklet) {
      throw new Error('AudioWorklet is not supported in this context');
    }

    // Initialize the voice pool and connect to first processor
    for (let i = 0; i < this.#polyphony; i++) {
      const voice = new VoiceNode(this.#context, this.#buffer, this.#rootNote);
      voice.connect(processorChain[0] || this.#outputGain);

      this.#voices.push(voice);
    }

    let numProcessors = processorChain.length;
    let prevNode = processorChain[0];
    for (let i = 1; i < numProcessors + 1; i++) {
      // internally connect the processor chain if more than one provided
      let nextNode = processorChain[i];
      if (prevNode && nextNode) {
        prevNode.connect(nextNode);
        console.log('connecting node: ', prevNode, 'to: ', nextNode);

        prevNode = nextNode;
        nextNode = processorChain[++i];
      }
    }
    processorChain[numProcessors - 1].connect(this.#outputGain);

    this.#processorChain = processorChain;
    this.#outputGain.connect(destinationNode);

    this.isInitialized = true;

    return true;
  }

  play(midiNote: number, velocity: number = 1.0, startTime?: number): boolean {
    const voice = this.#allocateVoice();
    if (!voice) {
      console.warn('No available voices to play the note');
      return false;
    }
    if (voice.play(midiNote, velocity, startTime)) {
      // send event to processors
      this.#processorChain.forEach((processor) => {
        processor.port?.postMessage({
          type: 'play',
          id: this.id,
          note: midiNote,
          velocity: velocity,
        });
      });
      console.log('Playing note:', midiNote, 'on voice:', voice);
      return true;
    }

    return false;
  }
*/

/* OLD POSITION TRACKING CODE 

export async function createSingleSamplePlayer(
  id: string,
  sampleBuffer: AudioBuffer,
  options?: {
    polyphony?: number;
    rootNote?: number;
  },
  onPositionUpdate?: (position: number, normalized: number) => void,
  outputDestination?: AudioNode
): Promise<SingleSamplePlayer> {
  const audioContext = await getAudioContext();
  ...

  const shouldTrackPosition = onPositionUpdate !== undefined || false;

  await player.init(outputDestination, shouldTrackPosition);
  
  if (onPositionUpdate && player.isInitialized) {
    player.onPositionUpdate(onPositionUpdate);
  }

  // const shouldTrackPosition = onPositionUpdate !== undefined || false;
  onPositionUpdate(callback: (position: number, normalized: number) => void) {
    this.#voices.forEach((voice) => {
      voice.setPositionCallback(callback);
    });
  }

  */

/* Old loop-processor code:
// Check if the processor is already registered (DEFINED?)
const processorName = 'loop-processor';
if (!registry.hasRegistered(processorName)) {
  // Register the processor
  await this.#context.audioWorklet.addModule(
    new URL(`./processors/${processorName}.js`, import.meta.url)
  );
}

// Create the loop processor
this.#loopProcessor = createWorkletNode(this.#context, 'loop-processor');

if (!this.#loopProcessor) {
  throw new Error('Failed to create loop processor');
}

if (this.#loopProcessor.port) {
  this.#loopProcessor.port.postMessage({
    type: 'init',
    buffer: this.#buffer,
    trackPlayPosition,
  });
}

*/
