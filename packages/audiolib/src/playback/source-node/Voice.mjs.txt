export class Voice {
  constructor(audioContext) {
    this.audioContext = audioContext;
    this.sourceNode = null;
    this.buffer = null;
    this.isPlaying = false;
    this.baseNote = 60; // Middle C
    this.isSetup = false;
  }

  async setup() {
    if (this.isSetup) return;
    await this.audioContext.audioWorklet.addModule('./source-processor.js');
    this.isSetup = true;
  }

  async loadSample(path) {
    try {
      const response = await fetch(path);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
      this.loadBuffer(audioBuffer);
    } catch (error) {
      console.error('Error loading sample:', error);
    }
  }

  loadBuffer(audioBuffer) {
    // Extract channel data for worklet
    const channelData = [];
    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
      channelData.push(audioBuffer.getChannelData(i));
    }
    this.buffer = {
      channels: channelData,
      sampleRate: audioBuffer.sampleRate,
    };
  }

  play(midiNote, velocity = 1.0, destination = this.audioContext.destination) {
    if (!this.isSetup || !this.buffer) return;

    // Stop previous note if still playing
    this.stop();

    // Create new source node
    this.sourceNode = new AudioWorkletNode(
      this.audioContext,
      'source-processor',
      {
        outputChannelCount: [this.buffer.channels.length],
      }
    );

    // Send buffer to worklet
    this.sourceNode.port.postMessage({
      type: 'setBuffer',
      buffer: this.buffer.channels,
      sampleRate: this.buffer.sampleRate,
    });

    // Calculate playback rate based on semitone difference
    const semitones = midiNote - this.baseNote;
    const playbackRate = Math.pow(2, semitones / 12);

    // Set playback rate
    this.sourceNode.parameters.get('targetPlaybackRate').value = playbackRate;

    // Apply velocity (gain)
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = velocity;

    // Connect nodes
    this.sourceNode.connect(gainNode);
    gainNode.connect(destination);

    // Start playback
    this.sourceNode.port.postMessage({ type: 'play' });
    this.isPlaying = true;

    // Listen for playback end
    this.sourceNode.port.onmessage = (event) => {
      if (event.data.type === 'ended') {
        this.isPlaying = false;
      }
    };

    return this;
  }

  stop() {
    if (this.sourceNode && this.isPlaying) {
      this.sourceNode.port.postMessage({ type: 'stop' });
      this.sourceNode.port.postMessage({ type: 'release' });
      this.isPlaying = false;
    }
    return this;
  }

  setBaseNote(midiNote) {
    this.baseNote = midiNote;
    return this;
  }
}
