class Voice {
  private audioContext: AudioContext;
  private sourceNode: AudioBufferSourceNode | null;
  private buffer: AudioBuffer | null;
  private currentLoopStart: number;
  private currentLoopEnd: number;
  private targetLoopStart: number;
  private targetLoopEnd: number;
  private interpolationTime: number;
  private isInterpolating: boolean;
  private interpolationStartTime: number;
  private updateIntervalId: number | null;

  public isPlaying: boolean;

  constructor(audioContext: AudioContext) {
    this.audioContext = audioContext;
    this.sourceNode = null;
    this.buffer = null;
    this.isPlaying = false;
    this.currentLoopStart = 0;
    this.currentLoopEnd = 0;
    this.targetLoopStart = 0;
    this.targetLoopEnd = 0;
    this.interpolationTime = 1.0;
    this.isInterpolating = false;
    this.interpolationStartTime = 0;
    this.updateIntervalId = null;
  }

  setBuffer(buffer: AudioBuffer): number {
    this.buffer = buffer;
    this.currentLoopEnd = buffer.duration;
    this.targetLoopEnd = buffer.duration;
    return buffer.duration;
  }

  setLoopPoints(
    loopStart: number,
    loopEnd: number,
    interpolationTime: number | null = null
  ): void {
    if (interpolationTime !== null) {
      this.interpolationTime = interpolationTime;
    }

    this.targetLoopStart = loopStart;
    this.targetLoopEnd = loopEnd;

    if (this.isPlaying && this._isLooping) {
      this.startInterpolation();
    } else {
      this.currentLoopStart = loopStart;
      this.currentLoopEnd = loopEnd;

      if (this.sourceNode) {
        this.sourceNode.loopStart = loopStart;
        this.sourceNode.loopEnd = loopEnd;
      }
    }
  }

  private startInterpolation(): void {
    if (this.updateIntervalId) {
      clearInterval(this.updateIntervalId);
    }

    this.isInterpolating = true;
    this.interpolationStartTime = this.audioContext.currentTime;

    const startLoopStart = this.currentLoopStart;
    const startLoopEnd = this.currentLoopEnd;

    this.updateIntervalId = setInterval(() => {
      const now = this.audioContext.currentTime;
      const elapsed = now - this.interpolationStartTime;
      const progress = Math.min(elapsed / this.interpolationTime, 1.0);

      this.currentLoopStart =
        startLoopStart + (this.targetLoopStart - startLoopStart) * progress;
      this.currentLoopEnd =
        startLoopEnd + (this.targetLoopEnd - startLoopEnd) * progress;

      if (this.sourceNode) {
        this.sourceNode.loopStart = this.currentLoopStart;
        this.sourceNode.loopEnd = this.currentLoopEnd;
      }

      const event = new CustomEvent('loopPointsInterpolated', {
        detail: {
          currentLoopStart: this.currentLoopStart,
          currentLoopEnd: this.currentLoopEnd,
          progress,
        },
      });
      document.dispatchEvent(event);

      if (progress >= 1.0) {
        this.isInterpolating = false;
        clearInterval(this.updateIntervalId);
        this.updateIntervalId = null;
      }
    }, 16.7);
  }

  play(): void {
    if (!this.buffer || this.isPlaying) return;

    this.sourceNode = this.audioContext.createBufferSource();
    this.sourceNode.buffer = this.buffer;
    this.sourceNode.loop = true;
    this.sourceNode.loopStart = this.currentLoopStart;
    this.sourceNode.loopEnd = this.currentLoopEnd;

    this.sourceNode.connect(this.audioContext.destination);
    this.sourceNode.start(0);
    this.isPlaying = true;

    this.sourceNode.onended = () => {
      this.isPlaying = false;
    };
  }

  stop(): void {
    if (!this.isPlaying) return;

    if (this.sourceNode) {
      this.sourceNode.stop();
      this.sourceNode.disconnect();
      this.sourceNode = null;
    }

    if (this.updateIntervalId) {
      clearInterval(this.updateIntervalId);
      this.updateIntervalId = null;
    }

    this.isPlaying = false;
  }
}

export { Voice };
