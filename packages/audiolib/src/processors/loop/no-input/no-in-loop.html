<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Loop Controller</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f7;
        color: #333;
      }
      h1 {
        color: #333;
      }
      .container {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .upload-section {
        margin-bottom: 20px;
        padding: 15px;
        border: 2px dashed #ccc;
        border-radius: 5px;
        text-align: center;
      }
      .upload-section.active {
        border-color: #007aff;
        background-color: rgba(0, 122, 255, 0.05);
      }
      .controls {
        display: none;
        margin-top: 30px;
      }
      .slider-group {
        margin-bottom: 20px;
      }
      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
      }
      .slider-container {
        display: flex;
        align-items: center;
      }
      input[type='range'] {
        flex: 1;
        margin-right: 10px;
      }
      .value-display {
        min-width: 60px;
        text-align: right;
        font-family: monospace;
      }
      .playback-info {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
        font-size: 14px;
      }
      .button {
        background-color: #007aff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.2s;
      }
      .button:hover {
        background-color: #0055cc;
      }
      .button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      .status {
        margin-top: 10px;
        padding: 10px;
        border-radius: 5px;
        display: none;
      }
      .status.success {
        display: block;
        background-color: #e8f5e9;
        color: #2e7d32;
      }
      .status.error {
        display: block;
        background-color: #ffebee;
        color: #c62828;
      }
      .keyboard-hint {
        margin-top: 20px;
        text-align: center;
        font-size: 14px;
        color: #666;
      }
      .waveform {
        margin-top: 20px;
        width: 100%;
        height: 100px;
        background-color: #f0f0f0;
        border-radius: 5px;
        overflow: hidden;
        position: relative;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Audio Loop Controller</h1>

      <div id="uploadSection" class="upload-section">
        <p>Drag & drop an audio file here or</p>
        <input
          type="file"
          id="audioFileInput"
          accept="audio/*"
          style="display: none"
        />
        <button id="browseButton" class="button">Browse Files</button>
        <p>Supported formats: WAV, MP3, OGG, FLAC</p>
      </div>

      <div id="statusMessage" class="status"></div>

      <div id="controls" class="controls">
        <div class="waveform" id="waveform"></div>

        <div class="slider-group">
          <label for="loopStartSlider">Loop Start (seconds)</label>
          <div class="slider-container">
            <input
              type="range"
              id="loopStartSlider"
              min="0"
              max="100"
              step="0.001"
              value="0"
            />
            <span id="loopStartValue" class="value-display">0.00</span>
          </div>
        </div>

        <div class="slider-group">
          <label for="loopEndSlider">Loop End (seconds)</label>
          <div class="slider-container">
            <input
              type="range"
              id="loopEndSlider"
              min="0.001"
              max="100"
              step="0.001"
              value="1"
            />
            <span id="loopEndValue" class="value-display">1.00</span>
          </div>
        </div>

        <div class="slider-group">
          <label for="rampTimeSlider">Ramp Time (seconds)</label>
          <div class="slider-container">
            <input
              type="range"
              id="rampTimeSlider"
              min="0"
              max="5"
              step="0.1"
              value="0"
            />
            <span id="rampTimeValue" class="value-display">0.00</span>
          </div>
        </div>

        <div class="playback-info">
          <span id="fileInfo">No file loaded</span>
          <span id="playbackStatus">Stopped</span>
        </div>

        <div class="keyboard-hint">
          Press <strong>SPACE</strong> to start/stop playback
        </div>
      </div>
    </div>

    <script type="module">
      import { createLoopController } from './NoInLoopNode.js';

      // Audio context and nodes
      let audioContext;
      let sourceNode;
      let loopController;
      let audioBuffer;
      let isPlaying = false;
      let startTime = 0;
      let pauseTime = 0;

      // DOM Elements
      const uploadSection = document.getElementById('uploadSection');
      const browseButton = document.getElementById('browseButton');
      const audioFileInput = document.getElementById('audioFileInput');
      const controls = document.getElementById('controls');
      const statusMessage = document.getElementById('statusMessage');
      const fileInfo = document.getElementById('fileInfo');
      const playbackStatus = document.getElementById('playbackStatus');

      const loopStartSlider = document.getElementById('loopStartSlider');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndSlider = document.getElementById('loopEndSlider');
      const loopEndValue = document.getElementById('loopEndValue');
      const rampTimeSlider = document.getElementById('rampTimeSlider');
      const rampTimeValue = document.getElementById('rampTimeValue');

      // Initialize audio context on user gesture
      function initAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          return true;
        }
        return false;
      }

      // Handle file upload
      async function handleFileUpload(file) {
        initAudioContext();

        try {
          showStatus('Loading audio file...', 'loading');

          // Read file
          const arrayBuffer = await file.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          // Update UI
          controls.style.display = 'block';
          fileInfo.textContent = `${file.name} (${formatTime(audioBuffer.duration)})`;
          updateSliderRanges();

          showStatus('Audio file loaded successfully!', 'success');

          // Initialize loop controller
          await setupLoopController();
        } catch (error) {
          console.error('Error loading audio file:', error);
          showStatus(
            'Error loading audio file. Please try another file.',
            'error'
          );
        }
      }

      // Set up loop controller
      async function setupLoopController() {
        try {
          loopController = await createLoopController(audioContext);
        } catch (error) {
          console.error('Error setting up loop controller:', error);
          showStatus('Error initializing audio processing.', 'error');
        }
      }

      // Update slider ranges based on audio duration
      function updateSliderRanges() {
        if (!audioBuffer) return;

        const duration = audioBuffer.duration;

        loopStartSlider.max = duration.toFixed(2);
        loopStartSlider.value = 0;
        loopStartValue.textContent = '0.00';

        loopEndSlider.max = duration.toFixed(2);
        loopEndSlider.value = duration.toFixed(2);
        loopEndValue.textContent = duration.toFixed(2);
      }

      // Start or stop playback
      function togglePlayback() {
        if (!audioBuffer) return;

        initAudioContext();

        if (isPlaying) {
          stopPlayback();
        } else {
          startPlayback();
        }
      }

      // Start playback
      async function startPlayback() {
        if (isPlaying || !audioBuffer) return;

        try {
          // Resume audio context if suspended
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }

          // Create source node
          sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.loop = true;

          // Set up loop controller
          if (!loopController) {
            await setupLoopController();
          }

          loopController.connectToSource(sourceNode);

          // Get current slider values
          const loopStart = parseFloat(loopStartSlider.value);
          const loopEnd = parseFloat(loopEndSlider.value);

          // Apply loop points
          loopController.setLoopPoint('loopStart', loopStart);
          loopController.setLoopPoint('loopEnd', loopEnd);

          // Connect and start
          sourceNode.connect(audioContext.destination);

          // Resume from pause position or start from beginning
          if (pauseTime > 0) {
            sourceNode.start(0, pauseTime);
          } else {
            sourceNode.start();
          }

          startTime = audioContext.currentTime - pauseTime;
          isPlaying = true;
          playbackStatus.textContent = 'Playing';
        } catch (error) {
          console.error('Error starting playback:', error);
          showStatus('Error starting playback.', 'error');
        }
      }

      // Stop playback
      function stopPlayback() {
        if (!isPlaying || !sourceNode) return;

        try {
          pauseTime = audioContext.currentTime - startTime;
          sourceNode.stop();
          isPlaying = false;
          playbackStatus.textContent = 'Paused';
        } catch (error) {
          console.error('Error stopping playback:', error);
        }
      }

      // Format time in seconds to MM:SS format
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }

      // Show status message
      function showStatus(message, type) {
        statusMessage.textContent = message;
        statusMessage.className = 'status';

        if (type === 'success') {
          statusMessage.classList.add('success');
        } else if (type === 'error') {
          statusMessage.classList.add('error');
        } else {
          statusMessage.style.display = 'block';
        }

        if (type !== 'loading') {
          setTimeout(() => {
            statusMessage.style.display = 'none';
          }, 3000);
        }
      }

      // Event Listeners
      browseButton.addEventListener('click', () => {
        audioFileInput.click();
      });

      audioFileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFileUpload(e.target.files[0]);
        }
      });

      // Drag and drop functionality
      uploadSection.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadSection.classList.add('active');
      });

      uploadSection.addEventListener('dragleave', () => {
        uploadSection.classList.remove('active');
      });

      uploadSection.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadSection.classList.remove('active');

        if (e.dataTransfer.files.length > 0) {
          const file = e.dataTransfer.files[0];
          if (file.type.startsWith('audio/')) {
            handleFileUpload(file);
          } else {
            showStatus('Please upload an audio file.', 'error');
          }
        }
      });

      // Slider event listeners
      loopStartSlider.addEventListener('input', (e) => {
        loopStartValue.textContent = parseFloat(e.target.value).toFixed(2);
        const rampTime = parseFloat(rampTimeSlider.value);

        // Ensure loopStart is always less than loopEnd
        if (
          parseFloat(loopStartSlider.value) >= parseFloat(loopEndSlider.value) // todo: add min as C6hz in ms
        ) {
          loopEndSlider.value = parseFloat(loopStartSlider.value) + 0.01;
          loopEndValue.textContent = parseFloat(loopEndSlider.value).toFixed(2);
        }
        loopController.setLoopPoint(
          'loopStart',
          parseFloat(e.target.value),
          rampTime
        );
      });

      loopEndSlider.addEventListener('input', (e) => {
        loopEndValue.textContent = parseFloat(e.target.value).toFixed(2);
        const rampTime = parseFloat(rampTimeSlider.value);

        // Ensure loopEnd is always greater than loopStart
        if (
          parseFloat(loopEndSlider.value) <= parseFloat(loopStartSlider.value)
        ) {
          loopStartSlider.value = parseFloat(loopEndSlider.value) - 0.01;
          loopStartValue.textContent = parseFloat(
            loopStartSlider.value
          ).toFixed(2);
        }
        loopController.setLoopPoint(
          'loopEnd',
          parseFloat(e.target.value),
          rampTime
        );
      });

      rampTimeSlider.addEventListener('input', (e) => {
        rampTimeValue.textContent = parseFloat(e.target.value).toFixed(2);
        // Currently does not affect ramps already happening
      });

      // Space bar to toggle playback
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && audioBuffer) {
          e.preventDefault(); // Prevent page scrolling
          togglePlayback();
        }
      });

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', () => {
        loopStartValue.textContent = loopStartSlider.value;
        loopEndValue.textContent = loopEndSlider.value;
        rampTimeValue.textContent = rampTimeSlider.value;
      });
    </script>
  </body>
</html>
