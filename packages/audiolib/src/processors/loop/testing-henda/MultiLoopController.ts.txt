import { BaseWorkletNode } from '@/abstract/nodes/baseClasses/BaseWorkletNode';
import { AudioParamDescriptor } from '@/types/global';
import MultiLoopProcessorRaw from './multi-loop-processor?raw';

interface ProcessorMessage {
  type: string;
  significantChange?: number;
}

class MultiLoopController extends BaseWorkletNode {
  static params: AudioParamDescriptor[] = [
    {
      name: 'loopStart',
      defaultValue: 0,
      minValue: 0,
      automationRate: 'a-rate',
    },
    {
      name: 'loopEnd',
      defaultValue: 0,
      minValue: 0,
      automationRate: 'a-rate',
    },
  ];
  sourceNodes: AudioBufferSourceNode[];

  constructor(context: BaseAudioContext, options: Record<string, any> = {}) {
    super(context, 'multi-loop-processor', {
      numberOfInputs: 0,
      numberOfOutputs: 1, // dummy output (can't be zero)
      processorOptions: options.processorOptions || {},
    });

    // Store reference to source node
    this.sourceNodes = [];

    // Configure the significant change threshold (optional)
    const significantChange = options.significantChange || 0.001;
    this.port.postMessage({
      type: 'config',
      significantChange,
    } as ProcessorMessage);

    // Set up message handling from the processor
    this.port.onmessage = this.handleProcessorMessage.bind(this);
  }

  addSourceNode(src: AudioBufferSourceNode) {
    if (!(src instanceof AudioBufferSourceNode)) {
      throw new Error('The provided node must be an AudioBufferSourceNode');
    }
    this.getParam('loopStart').value = src.loopStart;
    this.getParam('loopEnd').value = src.loopEnd;

    this.sourceNodes.push(src);
    return this; // For chaining
  }

  removeSourceNode(src: AudioBufferSourceNode) {
    const index = this.sourceNodes.indexOf(src);
    if (index !== -1) {
      this.sourceNodes.splice(index, 1);
    }
    return this;
  }

  clearSourceNodes() {
    this.sourceNodes = [];
    return this;
  }

  setLoopPoint(
    param: 'loopStart' | 'loopEnd',
    value: number,
    rampDuration = 0
  ) {
    // For small values, use linearRampToValueAtTime which can handle zero
    if (value < 0.01) {
      this.getParam(param).linearRampToValueAtTime(value, rampDuration);
    } else {
      this.getParam(param).exponentialRampToValueAtTime(value, rampDuration);
    }

    return this;
  }

  // Handle messages from the processor
  handleProcessorMessage(event: MessageEvent) {
    switch (event.data.type) {
      case 'update-loop-start':
        this.sourceNodes.forEach(
          (src) => (src.loopStart = event.data.loopStart)
        );
        break;
      case 'update-loop-end':
        this.sourceNodes.forEach((src) => (src.loopEnd = event.data.loopEnd));
        break;
      default:
        console.warn('Unknown message type:', event.data.type);
        break;
    }
  }
}

// Helper function to load the worklet processor
async function createMultiLoopController(audioContext: BaseAudioContext) {
  if (!audioContext.audioWorklet) {
    throw new Error('AudioWorklet not supported in this browser');
  }

  try {
    const blob = new Blob([MultiLoopProcessorRaw], {
      type: 'application/javascript',
    });
    await audioContext.audioWorklet.addModule(URL.createObjectURL(blob));
    return new MultiLoopController(audioContext);
  } catch (error) {
    console.error('Failed to load loop processor worklet:', error);
    throw error;
  }
}

export { MultiLoopController, createMultiLoopController };

// // example-usage.js
// import { createLoopController } from './loop-worklet-node.js';

// // Set up the audio context
// const audioContext = new AudioContext();

// async function setupLoopingExample() {
//   try {
//     // Load audio sample
//     const response = await fetch('sample.wav');
//     const arrayBuffer = await response.arrayBuffer();
//     const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

//     // Create and configure source node
//     const sourceNode = audioContext.createBufferSource();
//     sourceNode.buffer = audioBuffer;
//     sourceNode.loop = true; // Enable looping

//     // Create the loop controller and connect it to the source
//     const loopController = await createLoopController(audioContext);
//     loopController.connectToSource(sourceNode);

//     // Connect the source to the output and start playback
//     sourceNode.connect(audioContext.destination);
//     sourceNode.start();

//     // Set initial loop points
//     loopController.setLoopStart(1.0);
//     loopController.setLoopEnd(3.0);

//     // Example: Gradually change loop points after 2 seconds
//     setTimeout(() => {
//       console.log('Changing loop points gradually...');

//       // Smoothly change loop start over 1 second
//       loopController.setLoopStart(1.5, 1);

//       // Smoothly change loop end over 2 seconds
//       loopController.setLoopEnd(2.5, 2);
//     }, 2000);

//     // Example: Instantly change loop points after 6 seconds
//     setTimeout(() => {
//       console.log('Changing loop points instantly...');
//       loopController.setLoopStart(0.5);
//       loopController.setLoopEnd(4.0);
//     }, 6000);

//     return {
//       sourceNode,
//       loopController,
//       // Return a function that allows for external control
//       changeLoopPoints: (start, end, interpolationTime = 0) => {
//         loopController.setLoopStart(start, interpolationTime);
//         loopController.setLoopEnd(end, interpolationTime);
//       }
//     };

//   } catch (error) {
//     console.error('Error setting up loop example:', error);
//   }
// }

// // Run the example when document is ready
// document.addEventListener('DOMContentLoaded', () => {
//   // Create UI controls or start the example directly
//   setupLoopingExample().then(controller => {
//     window.loopController = controller; // Make available for console testing
//   });
// });
