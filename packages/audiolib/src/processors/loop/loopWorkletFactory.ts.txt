// loopWorkletFactory.ts

import {
  createWorkletNode,
  WorkletNode,
} from '@/nodes/worklet/base/WorkletNode';
import { AudioParamDescriptor } from '@/types/types';

/* basic template for a bypass processor. */

// Process function that will be converted to string and run in audio thread
function loopProcessFunction(
  inputs: Float32Array[][],
  outputs: Float32Array[][],
  _parameters: Record<string, Float32Array>
): boolean {
  const input = inputs[0];
  const output = outputs[0];

  // Get parameter values
  const targetLoopStart = _parameters.loopStart[0];
  const targetLoopEnd = _parameters.loopEnd[0];
  const interpolationSpeed = _parameters.interpolationSpeed[0];

  // Smoothly interpolate loop points
  this.currentLoopStart +=
    (targetLoopStart - this.currentLoopStart) * interpolationSpeed;
  this.currentLoopEnd +=
    (targetLoopEnd - this.currentLoopEnd) * interpolationSpeed;

  // Send updated loop points to main thread to update the AudioBufferSourceNode
  this.port.postMessage({
    type: 'update',
    loopStart: this.currentLoopStart,
    loopEnd: this.currentLoopEnd,
  });

  // If we have input data, copy it to output
  if (input && input.length > 0) {
    for (let channel = 0; channel < input.length; channel++) {
      const inputChannel = input[channel];
      const outputChannel = output[channel];

      // Copy samples directly (pass-through)
      for (let i = 0; i < inputChannel.length; i++) {
        outputChannel[i] = inputChannel[i];
      }
    }
  }

  // Return true to keep the processor alive
  return true;
}

export async function createLoopWorklet(
  context: BaseAudioContext,
  processorName: string,
  params: AudioParamDescriptor[] = [],
  nodeOptions: AudioWorkletNodeOptions = {}
): Promise<WorkletNode> {
  return createWorkletNode(
    context,
    processorName,
    loopProcessFunction,
    params,
    nodeOptions
  );
}
