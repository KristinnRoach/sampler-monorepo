// src/core/AudioRecorder.ts
export class AudioRecorder {
  private mediaRecorder: MediaRecorder | null = null;
  private audioChunks: Blob[] = [];
  private isRecording: boolean = false;

  constructor(
    private onRecordingComplete: (
      audioData: ArrayBuffer,
      blob: Blob
    ) => Promise<void>
  ) {}

  async startRecording(): Promise<void> {
    if (this.isRecording) return;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      if (!stream) {
        throw new Error('Could not get audio stream');
      }
      this.audioChunks = [];
      this.mediaRecorder = new MediaRecorder(stream);

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = async () => {
        // Stop all tracks to release the microphone
        stream.getTracks().forEach((track) => track.stop());
      };

      this.mediaRecorder.start();
      this.isRecording = true;
    } catch (error) {
      console.error('Error starting recording:', error);
      throw error;
    }
  }

  stopRecording(): Promise<void> {
    return new Promise((resolve) => {
      if (this.mediaRecorder && this.isRecording) {
        // Create a one-time listener for the 'stop' event
        const onStop = async () => {
          // Wait for the recording to be processed
          const blob = new Blob(this.audioChunks, { type: 'audio/wav' });
          const arrayBuffer = await blob.arrayBuffer();
          await this.onRecordingComplete(arrayBuffer, blob);

          // Clean up
          this.mediaRecorder?.stream
            .getTracks()
            .forEach((track) => track.stop());
          this.isRecording = false;
          resolve();
        };

        this.mediaRecorder.addEventListener('stop', onStop, { once: true });
        this.mediaRecorder.stop();
      } else {
        resolve();
      }
    });
  }

  isCurrentlyRecording(): boolean {
    return this.isRecording;
  }
}
