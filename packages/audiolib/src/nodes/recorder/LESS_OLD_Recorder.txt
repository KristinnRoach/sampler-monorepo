import { LibNode, SampleLoader } from '@/LibNode';
import { NodeID, createNodeId, deleteNodeId } from '@/nodes/node-store';
import {
  Message,
  MessageBus,
  MessageHandler,
  createMessageBus,
} from '@/events';
import { getMicrophone } from '@/io/devices/devices';
import { assert } from '@/utils';

export const AudioRecorderState = {
  IDLE: 'IDLE',
  ARMED: 'ARMED',
  RECORDING: 'RECORDING',
  STOPPED: 'STOPPED',
} as const;

export type AudioRecorderState =
  (typeof AudioRecorderState)[keyof typeof AudioRecorderState];

// todo: standardize params for all the methods to avoid confusing multiple params
export const DEFAULT_RECORDER_OPTIONS = {
  useThreshold: true, // Start recording when audio exceeds threshold
  startThreshold: -30, // dB threshold to start recording (-60 to 0)
  autoStop: false, // Stop when silence detected
  stopThreshold: -40, // dB threshold to consider silence (-60 to 0)
  silenceTimeoutMs: 1000, // Time in ms to wait before stopping
} as const;

export type RecorderOptions = typeof DEFAULT_RECORDER_OPTIONS;

// Optional extended options for internal methods
interface ExtendedRecorderOptions extends RecorderOptions {
  mode?: 'threshold' | 'silence';
  onThresholdReached?: () => void;
  onError?: (error: Error) => void;
}

export class Recorder implements LibNode {
  readonly nodeId: NodeID;
  readonly nodeType = 'recorder';

  #context: AudioContext;
  #stream: MediaStream | null = null;
  #recorder: MediaRecorder | null = null;
  #armedThreshold: number | null = null;
  #messages: MessageBus<Message>;
  #destination: (LibNode & SampleLoader) | null = null;
  #state: AudioRecorderState = AudioRecorderState.IDLE;

  // Threshold detection resources
  #thresholdSource: MediaStreamAudioSourceNode | null = null;
  #thresholdAnalyser: AnalyserNode | null = null;
  #animationFrame: number | null = null;

  constructor(context: AudioContext) {
    this.nodeId = createNodeId(this.nodeType);
    this.#context = context;
    this.#messages = createMessageBus<Message>(this.nodeId);
  }

  async init(): Promise<Recorder> {
    try {
      this.#stream = await getMicrophone();
      this.#recorder = new MediaRecorder(this.#stream, {
        mimeType: 'audio/webm',
      });
      return this;
    } catch (error) {
      throw new Error(`Failed to get microphone: ${error}`);
    }
  }

  #isReasonableThreshold = (threshold: number) =>
    threshold > -60 && threshold < 0;

  // Single method to start recording with options
  async start(options?: Partial<RecorderOptions>): Promise<this> {
    if (!this.#recorder) throw new Error('Recorder not initialized');
    if (this.#state === AudioRecorderState.RECORDING) return this;

    // Merge with default options
    const config = { ...DEFAULT_RECORDER_OPTIONS, ...options };

    console.info('Recording with options:', config);

    try {
      if (!config.useThreshold) {
        return this.#startRecordingImmediate(config);
      } else {
        // Armed recording - wait for threshold
        await this.#startThresholdRecording(config);
        return this;
      }
    } catch (error) {
      console.error('Error starting recording:', error);
      throw error;
    }
  }

  // // Update the #startThresholdRecording method to use the unified approach
  // async #startThresholdRecording(config: RecorderOptions): Promise<this> {
  //   assert(config.startThreshold, 'start threshold must be provided');

  //   if (!this.#isReasonableThreshold(config.startThreshold)) {
  //     console.warn(
  //       `Threshold ${config.startThreshold}dB out of range (-60 to 0)`
  //     );
  //     return this;
  //   }

  //   try {
  //     await new Promise<void>((resolve, reject) => {
  //       this.#state = AudioRecorderState.ARMED;
  //       this.#armedThreshold = config.startThreshold;
  //       this.sendMessage('record:armed', {
  //         threshold: config.startThreshold,
  //         destination: this.#destination,
  //       });

  //       // Use the unified method for audio monitoring
  //       this.#setupAudioMonitoring({
  //         ...config,
  //         mode: 'threshold',
  //         onThresholdReached: () => {
  //           this.#startRecordingImmediate(config);
  //           resolve();
  //         },
  //         onError: reject,
  //       });
  //     });

  //     return this;
  //   } catch (error) {
  //     console.error('Error in threshold recording:', error);
  //     return this;
  //   }
  // }

  // Update the #startRecordingImmediate method to use the unified approach
  #startRecordingImmediate(config: RecorderOptions): this {
    this.#recorder!.start();
    this.#state = AudioRecorderState.RECORDING;
    this.sendMessage('record:start', { destination: this.#destination });

    if (config.autoStop) {
      // Use the unified method for silence detection
      this.#setupAudioMonitoring({
        ...config,
        mode: 'silence',
      });
    }

    return this;
  }

  // // Clear handling of threshold start - modified to return this
  // async #startThresholdRecording(config: RecorderOptions): Promise<this> {
  //   assert(config.startThreshold, 'start threshold must be provided');

  //   if (!this.#isReasonableThreshold(config.startThreshold)) {
  //     console.warn(
  //       `Threshold ${config.startThreshold}dB out of range (-60 to 0)`
  //     );
  //     return this;
  //   }

  //   try {
  //     await new Promise<void>((resolve, reject) => {
  //       this.#state = AudioRecorderState.ARMED;
  //       this.#armedThreshold = config.startThreshold || null;
  //       this.sendMessage('record:armed', {
  //         threshold: config.startThreshold,
  //         destination: this.#destination,
  //       });

  //       // Setup a single analyzer for sound detection
  //       const analyzer = this.#setupAnalyzer();
  //       const dataArray = new Float32Array(analyzer.fftSize);

  //       // Use a clear callback for threshold detection
  //       const checkStartLevel = () => {
  //         if (this.#state !== AudioRecorderState.ARMED) {
  //           this.#cleanupAnalyzer(analyzer);
  //           reject(new Error('Armed state changed before threshold reached'));
  //           return;
  //         }

  //         analyzer.getFloatTimeDomainData(dataArray);
  //         const peak = Math.max(...dataArray.map(Math.abs));
  //         const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -100;

  //         if (peakDB >= config.startThreshold!) {
  //           // Threshold reached, start recording
  //           this.#cleanupAnalyzer(analyzer);
  //           this.#startRecordingImmediate(config);
  //           resolve();
  //         } else {
  //           this.#animationFrame = requestAnimationFrame(checkStartLevel);
  //         }
  //       };

  //       this.#animationFrame = requestAnimationFrame(checkStartLevel);
  //     });

  //     return this;
  //   } catch (error) {
  //     // Log error but still return this for chaining
  //     console.error('Error in threshold recording:', error);
  //     return this;
  //   }
  // }

  #startRecording(options: Partial<RecorderOptions> = {}): this {
    // Merge with defaults
    const config = { ...DEFAULT_RECORDER_OPTIONS, ...options };

    if (this.#recorder!.state === 'inactive') {
      this.#recorder!.start();
    }
    this.#state = AudioRecorderState.RECORDING;
    this.sendMessage('record:start', { destination: this.#destination });

    if (config.autoStop) {
      // Use the standardized silence detection method
      this.#startSilenceDetection(config);
    }

    return this;
  }

  // Remove the separate #startSilenceDetection method and use a unified approach
  #setupAudioMonitoring(
    options: Partial<RecorderOptions> & {
      mode: 'threshold' | 'silence'; // What are we monitoring for?
    }
  ): this {
    const config = { ...DEFAULT_RECORDER_OPTIONS, ...options };
    const mode = options.mode || 'threshold';

    const analyzer = this.#setupAnalyzer();
    const dataArray = new Float32Array(analyzer.fftSize);

    let silenceStartTime: number | null = null;

    const checkAudio = () => {
      if (
        (mode === 'threshold' && this.#state !== AudioRecorderState.ARMED) ||
        (mode === 'silence' && this.#state !== AudioRecorderState.RECORDING)
      ) {
        this.#cleanupAnalyzer(analyzer);
        return;
      }

      analyzer.getFloatTimeDomainData(dataArray);
      const peak = Math.max(...dataArray.map(Math.abs));
      const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -100;

      if (mode === 'threshold') {
        // Check if threshold exceeded to start recording
        if (peakDB >= config.startThreshold!) {
          this.#cleanupAnalyzer(analyzer);
          this.#startRecordingImmediate(config);
          return;
        }
      } else if (mode === 'silence') {
        // Check for silence to stop recording
        const now = performance.now();

        if (peakDB < config.stopThreshold!) {
          if (silenceStartTime === null) {
            silenceStartTime = now;
          } else if (now - silenceStartTime >= config.silenceTimeoutMs!) {
            this.#cleanupAnalyzer(analyzer);

            // Send a pre-stop notification
            this.sendMessage('record:stopping', {});

            this.stop().catch((err) => {
              console.error('Error auto-stopping recording:', err);
            });
            return;
          }
        } else {
          silenceStartTime = null;
        }
      }

      this.#animationFrame = requestAnimationFrame(checkAudio);
    };

    this.#animationFrame = requestAnimationFrame(checkAudio);

    return this;
  }

  // Helper to setup analyzer consistently - modified to return this
  #setupAnalyzer(): AnalyserNode {
    const source = this.#context.createMediaStreamSource(this.#stream!);
    const analyzer = this.#context.createAnalyser();
    analyzer.fftSize = 1024;
    source.connect(analyzer);

    // Store for cleanup
    this.#thresholdSource = source;
    this.#thresholdAnalyser = analyzer;

    return analyzer;
  }

  // Helper to cleanup analyzer consistently - modified to return this
  #cleanupAnalyzer(analyzer: AnalyserNode): this {
    if (this.#animationFrame !== null) {
      cancelAnimationFrame(this.#animationFrame);
      this.#animationFrame = null;
    }

    if (this.#thresholdSource) {
      this.#thresholdSource.disconnect();
      this.#thresholdSource = null;
    }

    if (this.#thresholdAnalyser) {
      this.#thresholdAnalyser.disconnect();
      this.#thresholdAnalyser = null;
    }

    return this;
  }

  // Update the #setupThresholdDetection method
  #setupThresholdDetection(
    options: Partial<RecorderOptions> & { isForSilenceDetection?: boolean } = {}
  ): this {
    // Merge with defaults
    const config = { ...DEFAULT_RECORDER_OPTIONS, ...options };
    const isForSilenceDetection = options.isForSilenceDetection ?? false;

    // Set state only if this is for initial armed detection, not for silence detection
    if (!isForSilenceDetection) {
      this.#state = AudioRecorderState.ARMED;
      this.#armedThreshold = config.startThreshold;
      this.sendMessage('record:armed', {
        threshold: config.startThreshold,
        destination: this.#destination,
      });
    }

    // Set up threshold detection
    this.#thresholdSource = this.#context.createMediaStreamSource(
      this.#stream!
    );
    this.#thresholdAnalyser = this.#context.createAnalyser();
    this.#thresholdAnalyser.fftSize = 1024;

    this.#thresholdSource.connect(this.#thresholdAnalyser);
    const dataArray = new Float32Array(this.#thresholdAnalyser.fftSize);

    // For silence detection
    let silenceStartTime: number | null = null;

    const checkLevel = () => {
      // Already cleaned up
      if (!this.#thresholdAnalyser) return;

      if (this.#state === AudioRecorderState.ARMED) {
        // ARMED state logic
        this.#thresholdAnalyser.getFloatTimeDomainData(dataArray);
        const peak = Math.max(...dataArray.map(Math.abs));
        const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -100;

        if (peakDB >= config.startThreshold) {
          // Threshold reached, start recording
          this.#armedThreshold = null; // Clear armed state

          if (!config.autoStop) {
            // If we're not doing auto-stop, clean up threshold detection
            this.#cleanupThresholdDetection();
          }

          // Start recording with a clean config object
          this.#startRecording({
            autoStop: config.autoStop,
            stopThreshold: config.stopThreshold,
            silenceTimeoutMs: config.silenceTimeoutMs,
          });
        } else {
          this.#animationFrame = requestAnimationFrame(checkLevel);
        }
      } else if (
        this.#state === AudioRecorderState.RECORDING &&
        config.autoStop
      ) {
        // RECORDING state logic for silence detection
        this.#thresholdAnalyser.getFloatTimeDomainData(dataArray);
        const peak = Math.max(...dataArray.map(Math.abs));
        const peakDB = peak > 0.0000001 ? 20 * Math.log10(peak) : -100;

        const now = performance.now();

        if (peakDB < config.stopThreshold) {
          // Below threshold - potential silence
          if (silenceStartTime === null) {
            silenceStartTime = now;
          } else if (now - silenceStartTime >= config.silenceTimeoutMs) {
            // Silence duration exceeded timeout - stop recording
            this.#cleanupThresholdDetection();

            // Send a pre-stop notification before actual stopping
            this.sendMessage('record:stopping', {});

            // Handle the promise properly
            this.stop().catch((err) => {
              console.error('Error auto-stopping recording:', err);
            });

            return;
          }
        } else {
          // Above threshold - reset silence timer
          silenceStartTime = null;
        }

        this.#animationFrame = requestAnimationFrame(checkLevel);
      } else {
        // Any other state: stop monitoring
        this.#cleanupThresholdDetection();
      }
    };

    this.#animationFrame = requestAnimationFrame(checkLevel);

    return this;
  }

  // Update cleanupThresholdDetection to return this
  #cleanupThresholdDetection(): this {
    if (this.#animationFrame !== null) {
      cancelAnimationFrame(this.#animationFrame);
      this.#animationFrame = null;
    }

    if (this.#thresholdSource) {
      this.#thresholdSource.disconnect();
      this.#thresholdSource = null;
    }

    if (this.#thresholdAnalyser) {
      this.#thresholdAnalyser.disconnect();
      this.#thresholdAnalyser = null;
    }

    return this;
  }

  async stop(): Promise<AudioBuffer> {
    if (!this.#recorder) throw new Error('Recorder not initialized');

    // Handle armed state - user cancelled before threshold was reached
    if (this.#state === AudioRecorderState.ARMED) {
      this.#cleanupThresholdDetection();
      this.#armedThreshold = null;
      this.#state = AudioRecorderState.STOPPED;
      this.sendMessage('record:cancelled', {});
      throw new Error('Recording was armed but never triggered');
    }

    if (this.#state !== AudioRecorderState.RECORDING)
      throw new Error('Not recording');

    const blob = await this.#stopRecording();
    const buffer = await this.#blobToAudioBuffer(blob);

    this.#state = AudioRecorderState.STOPPED;
    this.sendMessage('record:stop', { duration: buffer.duration });

    if (this.#destination) {
      await this.#destination.loadSample(buffer);
    }

    return buffer;
  }

  #stopRecording(): Promise<Blob> {
    return new Promise((resolve) => {
      if (this.#recorder!.state !== 'inactive') {
        this.#recorder!.addEventListener(
          'dataavailable',
          (e) => {
            resolve(e.data);
          },
          { once: true }
        );
        this.#recorder!.stop();
      }
    });
  }

  async #blobToAudioBuffer(blob: Blob): Promise<AudioBuffer> {
    const arrayBuffer = await blob.arrayBuffer();
    return await this.#context.decodeAudioData(arrayBuffer);
  }

  // LibNode interface implementation
  onMessage(type: string, handler: MessageHandler<Message>): () => void {
    return this.#messages.onMessage(type, handler);
  }

  protected sendMessage(type: string, data: any) {
    this.#messages.sendMessage(type, data);
  }

  connect(destination: LibNode & SampleLoader): this {
    if (destination) {
      this.#destination = destination;
    }
    return this;
  }

  disconnect(): void {
    this.#destination = null;
  }

  dispose(): void {
    this.#cleanupThresholdDetection();
    this.#armedThreshold = null;
    this.#stream?.getTracks().forEach((track) => track.stop());
    this.#stream = null;
    this.#recorder = null;
    this.#state = AudioRecorderState.IDLE;
    deleteNodeId(this.nodeId);
  }

  set recordStartThreshold(db: number) {
    this.#armedThreshold = db;
  }

  get armedThreshold() {
    return this.#armedThreshold;
  }

  /**
   * Returns whether the recorder is armed and waiting for threshold
   */
  get isArmed(): boolean {
    return this.#state === AudioRecorderState.ARMED;
  }

  get now(): number {
    return this.#context.currentTime;
  }

  get isRecording(): boolean {
    return this.#state === AudioRecorderState.RECORDING;
  }

  /**
   * Returns the current state of the recorder
   */
  get state(): AudioRecorderState {
    return this.#state;
  }

  /**
   * Returns whether the recorder has been properly initialized with access to the microphone
   * and is ready to start recording.
   */
  get isReady(): boolean {
    return this.#recorder !== null && this.#stream !== null;
  }
}
