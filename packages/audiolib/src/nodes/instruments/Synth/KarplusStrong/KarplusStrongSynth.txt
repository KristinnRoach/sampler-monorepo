// import { LibInstrument } from '@/nodes/instruments/LibInstrument';
// import { LibParamDescriptor } from '@/nodes/params';
// import { InstrumentMasterBus } from '@/nodes/master/InstrumentMasterBus';
// import { KarplusVoicePool } from './KarplusVoicePool';
// import { getAudioContext } from '@/context';
// import { Message, MessageHandler } from '@/events';
// import { MidiController, PressedModifiers } from '@/io';
// import { Debouncer } from '@/utils/Debouncer';
// import { normalizeRange, cancelScheduledParamValues, clamp } from '@/utils';
// import { KARPLUS_DEFAULTS } from './defaults';

// type ActiveNoteId = number; // todo: update to use same system as sampler

// export class KarplusStrongSynth extends LibInstrument {
//   // KarplusStrongSynth-specific private # fields
//   #masterOut: GainNode;
//   #midiNoteToId = new Map<number, number>(); // Track active notes by midiNote
//   #debouncer: Debouncer = new Debouncer();
//   #isReady: boolean = false;

//   voicePool: KarplusVoicePool;

//   constructor(
//     polyphony: number = 8,
//     context: AudioContext = getAudioContext(),
//     options: Record<string, number> = {}
//   ) {
//     super('synth', context || getAudioContext(), polyphony);

//     // Initialize voice pool
//     this.voicePool = new KarplusVoicePool(
//       this.audioContext,
//       polyphony,
//       this.outBus.input
//     );

//     this.#masterOut = new GainNode(context, { gain: 0.5 });
//     this.outBus.connect(this.#masterOut);
//     this.#masterOut.connect(context.destination);

//     // Load stored parameter values
//     this.setParameterValue(
//       'volume',
//       this.getStoredParamValue('volume', KARPLUS_DEFAULTS.volume)
//     );
//     this.setParameterValue(
//       'attack',
//       this.getStoredParamValue('attack', KARPLUS_DEFAULTS.attack)
//     );
//     this.setParameterValue(
//       'decay',
//       this.getStoredParamValue('decay', KARPLUS_DEFAULTS.decay)
//     );
//     this.setParameterValue(
//       'noiseTime',
//       this.getStoredParamValue('noiseTime', KARPLUS_DEFAULTS.noiseTime)
//     );

//     this.#isReady = true;
//   }

//   onMessage(type: string, handler: MessageHandler<Message>): () => void {
//     return this.messages.onMessage(type, handler);
//   }

//   play(
//     // returns noteId, which is currently just the midi note
//     midiNote: MidiValue,
//     velocity: number = 100,
//     modifiers: Partial<PressedModifiers> = {}
//   ): ActiveNoteId {
//     // ActiveNoteId vs MidiValue / midiNote
//     // Release any existing note with same midiNote
//     if (this.#midiNoteToId.has(midiNote)) {
//       const oldNoteId = this.#midiNoteToId.get(midiNote)!;
//       this.voicePool.noteOff(oldNoteId, 0); // Quick release
//     }

//     // Assign a voice and play the note
//     const noteId = this.voicePool.noteOn(midiNote, velocity);

//     // Store the noteId for this midiNote
//     this.#midiNoteToId.set(midiNote, noteId);

//     this.sendUpstreamMessage('note:on', { midiNote, velocity, noteId });

//     return noteId;
//   }

//   release(midiNote: number, modifiers: Partial<PressedModifiers> = {}): this {
//     const noteId = this.#midiNoteToId.get(midiNote);
//     if (noteId === undefined) {
//       console.warn(`Could not release note ${midiNote}`);
//       return this;
//     }

//     this.voicePool.noteOff(noteId, this.decaySeconds);
//     this.#midiNoteToId.delete(midiNote);

//     this.sendUpstreamMessage('note:off', { midiNote });
//     return this;
//   }

//   panic = (fadeOut_sec?: number) => this.releaseAll(fadeOut_sec);

//   releaseAll(fadeOut_sec?: number): this {
//     // todo: implement fade out in seconds
//     console.debug(
//       `todo: implement fade out.
//       Current fadeout value is ${fadeOut_sec} seconds`
//     );
//     this.stopAll();
//     return this;
//   }

//   stopAll(): this {
//     this.voicePool.allNotesOff();
//     this.#midiNoteToId.clear();
//     return this;
//   }

//   // setParameterValue(name: string, value: number, debounceMs = 20): this {
//   setParameterValue(name: string, value: number): this {
//     const executeSet = () => {
//       switch (name) {
//         case 'volume':
//           this.volume = value;
//           this.storeParamValue('volume', value);
//           break;

//         case 'attack':
//           this.voicePool.allVoices.forEach((voice) => {
//             voice.attack = value;
//           });
//           const clamped = clamp(value, 0.001, 2);
//           this.storeParamValue('attack', clamped);
//           break;

//         case 'decay':
//           this.voicePool.allVoices.forEach((voice) => voice.setDecay(value));
//           this.storeParamValue('decay', value);
//           break;

//         case 'noiseTime':
//           this.voicePool.allVoices.forEach((voice) =>
//             voice.setNoiseTime(value)
//           );
//           this.storeParamValue('noiseTime', value);
//           break;

//         case 'noiseGain':
//           this.voicePool.allVoices.forEach((voice) =>
//             voice.setNoiseGain(value)
//           );
//           this.storeParamValue('noiseGain', value);
//           break;

//         default:
//           console.warn(`Unknown parameter: ${name}`);
//       }
//     };

//     // if (debounceMs <= 0) {
//     //   executeSet();
//     // } else {
//     //   const debounced = this.#debouncer.debounce(name, executeSet, debounceMs);
//     //   debounced();
//     // }
//     // todo: remove comment above or make debouncing of params consistent for all LibInstruments
//     // for now let's just:
//     executeSet();

//     return this;
//   }

//   getParameterValue(name: string): number | undefined {
//     switch (name) {
//       case 'volume':
//         return this.volume;
//       case 'attack':
//         return this.getStoredParamValue('attack', KARPLUS_DEFAULTS.attack);
//       case 'decay':
//         return this.getStoredParamValue('decay', KARPLUS_DEFAULTS.decay);
//       case 'noiseTime':
//         return this.getStoredParamValue(
//           'noiseTime',
//           KARPLUS_DEFAULTS.noiseTime
//         );
//       default:
//         console.warn(`Unknown parameter: ${name}`);
//         return undefined;
//     }
//   }

//   // could also be simplified to something like:
//   // getParamValue(paramId: string): any {
//   //   return this.getStoredParamValue(paramId, NaN);
//   // }

//   getParameterDescriptors(): Record<string, LibParamDescriptor> {
//     return {
//       volume: {
//         nodeId: `${this.nodeId}-volume`,
//         name: 'Volume',
//         dataType: 'number',
//         defaultValue: KARPLUS_DEFAULTS.volume,
//         minValue: 0,
//         maxValue: 1,
//         group: 'output',
//         automationRate: 'k-rate',
//       },
//       attack: {
//         nodeId: `${this.nodeId}-attack`,
//         name: 'Attack',
//         dataType: 'number',
//         defaultValue: KARPLUS_DEFAULTS.attack,
//         minValue: 0,
//         maxValue: 2, // 2 seconds max attack
//         group: 'envelope',
//         automationRate: 'k-rate',
//       },
//       decay: {
//         nodeId: `${this.nodeId}-decay`,
//         name: 'Decay',
//         dataType: 'number',
//         defaultValue: KARPLUS_DEFAULTS.decay,
//         minValue: 0.001,
//         maxValue: 1.5, // set's fb-gain
//         group: 'envelope',
//         automationRate: 'k-rate',
//       },
//       noiseTime: {
//         nodeId: `${this.nodeId}-noiseTime`,
//         name: 'Noise Time',
//         dataType: 'number',
//         defaultValue: KARPLUS_DEFAULTS.noiseTime,
//         minValue: 0.001,
//         maxValue: 1, // 1 second max noise time
//         group: 'synthesis',
//         automationRate: 'k-rate',
//       },
//     };
//   }

//   // enableKeyboard(): this {
//   //   if (!this.keyboardHandler) {
//   //     this.keyboardHandler = {
//   //       onNoteOn: this.play.bind(this),
//   //       onNoteOff: this.release.bind(this),
//   //       onBlur: this.#onBlur.bind(this),
//   //       onModifierChange: this.#handleModifierKeys.bind(this),
//   //     };
//   //     globalKeyboardInput.addHandler(this.keyboardHandler);
//   //   }
//   //   console.info(`Karplus-strong synth: keyboard enabled`);
//   //   return this;
//   // }

//   // disableKeyboard(): this {
//   //   if (this.keyboardHandler) {
//   //     globalKeyboardInput.removeHandler(this.keyboardHandler);
//   //     this.keyboardHandler = null;
//   //   }
//   //   console.info(`Karplus-strong synth: keyboard disabled`);
//   //   return this;
//   // }

//   async enableMIDI(
//     midiController = this.midiController,
//     channel: number = 0
//   ): Promise<this> {
//     if (!midiController) {
//       midiController = new MidiController();
//       await midiController.initialize();
//     }
//     if (midiController.isInitialized) {
//       midiController.connectInstrument(this, channel);
//       console.info(`Karplus-strong synth: MIDI enabled`);
//     }
//     return this;
//   }

//   disableMIDI(midiController?: MidiController, channel: number = 0): this {
//     midiController?.disconnectInstrument(channel);
//     this.midiController?.disconnectInstrument(channel);
//     console.info(`Karplus-strong synth: MIDI disabled`);
//     return this;
//   }

//   #onBlur(): this {
//     console.debug('Blur occurred');
//     this.stopAll();
//     return this;
//   }

//   #handleModifierKeys(modifiers: PressedModifiers): this {
//     // todo: add any modifier key handling here
//     return this;
//   }

//   dispose(): void {
//     this.stopAll();
//     this.disconnect();

//     // if (this.keyboardHandler) {
//     //   globalKeyboardInput.removeHandler(this.keyboardHandler);
//     //   this.keyboardHandler = null;
//     // }

//     this.voicePool.dispose();
//     this.#midiNoteToId.clear();
//     this.outBus.dispose();
//     this.outBus = null as unknown as InstrumentMasterBus;
//     this.audioContext = null as unknown as AudioContext;
//   }

//   /** SETTERS */
//   set volume(value: number) {
//     this.#masterOut.gain.setValueAtTime(value, this.now);
//   }

//   set attackTime(seconds: number) {
//     // Remove /1000 conversion
//     this.storeParamValue('attack', seconds);
//   }

//   // todo: align with samplePlayer's param getters / setters naming convention // make default const in one place
//   get attackSeconds(): number {
//     return this.getStoredParamValue('attack', KARPLUS_DEFAULTS.attack);
//   }

//   get decaySeconds(): number {
//     return this.getStoredParamValue('decay', KARPLUS_DEFAULTS.decay);
//   }

//   // TODO: Standardize filters
//   // todo: test optimal safe values and move to constants
//   SET_TARGET_TIMECONSTANT = 0.05; // in seconds
//   #lastHpfUpdateTime = 0;
//   #lastLpfUpdateTime = 0;
//   #minFilterUpdateInterval = 0.05; // in seconds

//   setHpfCutoff(hz: number): this {
//     // if (!this.#pool.filtersEnabled) return this;
//     if (isNaN(hz) || !isFinite(hz)) {
//       console.warn(`Invalid LPF frequency: ${hz}`);
//       return this;
//     }

//     const currentTime = this.now;
//     if (currentTime - this.#lastHpfUpdateTime < this.#minFilterUpdateInterval) {
//       return this;
//     }

//     this.storeParamValue('karplus:hpfCutoff', hz);
//     this.voicePool.applyToAllVoices((voice) => voice.setParam('hpf', hz));

//     this.#lastHpfUpdateTime = currentTime;

//     return this;
//   }

//   setLpfCutoff(hz: number): this {
//     // if (!this.#pool.filtersEnabled) return this;
//     const maxFilterFreq = this.audioContext.sampleRate / 1 - 100;

//     // Ensure the frequency is a valid number and within safe range
//     if (isNaN(hz) || !isFinite(hz)) {
//       console.warn(`Invalid LPF frequency: ${hz}`);
//       return this;
//     }

//     const safeValue = Math.max(20, Math.min(hz, maxFilterFreq));
//     this.storeParamValue('karplus:lpfCutoff', safeValue);

//     const currentTime = this.now;
//     if (currentTime - this.#lastLpfUpdateTime < this.#minFilterUpdateInterval) {
//       return this;
//     }

//     this.voicePool.applyToAllVoices((voice) => {
//       if (!voice.lpf) return;

//       cancelScheduledParamValues(voice.lpf.frequency, currentTime);
//       // voice.lpf.frequency.cancelScheduledValues(currentTime);
//       // const currentValue = voice.lpf.frequency.defaultValue;
//       // voice.lpf.frequency.setValueAtTime(
//       //   voice.lpf.frequency.value,
//       //   currentTime
//       // );
//       voice.lpf.frequency.setTargetAtTime(
//         safeValue,
//         currentTime,
//         this.SET_TARGET_TIMECONSTANT
//       );
//     });

//     this.#lastLpfUpdateTime = currentTime;

//     return this;
//   }

//   // connect(destination: Destination): Destination {
//   //   this.outBus.connect(destination);
//   //   this.destination = destination;
//   //   return destination;
//   // }

//   // disconnect() {
//   //   this.outBus.disconnect();
//   //   this.destination = null;
//   //   return this;
//   // }

//   /** GETTERS */
//   get context() {
//     return this.audioContext;
//   }

//   get initialized() {
//     return this.#isReady;
//   }

//   get now() {
//     return this.audioContext.currentTime;
//   }

//   get volume(): number {
//     return this.#masterOut.gain.value;
//   }

//   get isPlaying(): boolean {
//     return this.#midiNoteToId.size > 0;
//   }

//   get activeVoices(): number {
//     return this.#midiNoteToId.size;
//   }

//   get maxVoices(): number {
//     return this.voicePool.allVoices.length;
//   }
// }

// // Register parameters
// // this.#registerParameters();
// // #registerParameters(): void {
// //   // Register common parameters
// //   // For KarplusStrongSynth, we might need to create LibParam wrappers
// //   // for parameters that are currently handled differently

// //   // Example of registering a parameter with a custom descriptor
// //   const decayDescriptor: ParamDescriptor = {
// //     nodeId: 'decay',
// //     name: 'decay',
// //     valueType: 'number',
// //     minValue: 0.01,
// //     maxValue: 0.99,
// //     defaultValue: 0.5,
// //     group: 'envelope',
// //   };

// //   // Create a LibParam for decay
// //   const decayParam: LibParam = {
// //     nodeId: 'decay',
// //     nodeType: 'param',
// //     isReady: true,
// //     descriptor: decayDescriptor,
// //     getValue: () => this.getStoredParamValue('decay', 0.5),
// //     setValue: (value: number) => {
// //       this.#voicePool.allVoices.forEach((voice) => {
// //         const param = voice.getParam('decay');
// //         if (param) {
// //           param.setValueAtTime(value, this.context.currentTime);
// //         }
// //       });
// //       this.storeParamValue('decay', value);
// //     },
// //     onMessage: () => () => {}, // No-op implementation
// //     dispose: () => {},
// //   };

// //   this.params.register(decayParam);

// //   // Similarly register other parameters
// //   // ...
// // }

// // #getLocalStorageKey(paramName: string) {
// //   return `${paramName}-${this.nodeId}`;
// // }

// // setParamValue(paramId: string, value: number, debounceMs = 20): this {
// //   // Special case for volume, which is a property of the synth
// //   if (paramId === 'volume') {
// //     this.volume = value;
// //     return this;
// //   }

// //   // Use the base class implementation with debouncing
// //   if (debounceMs <= 0) {
// //     super.setParamValue(paramId, value, 0);
// //   } else {
// //     const debounced = this.#debouncer.debounce(
// //       paramId,
// //       (val: number) => super.setParamValue(paramId, val, 0),
// //       debounceMs
// //     );
// //     debounced(value);
// //   }

// //   return this;
// // }
