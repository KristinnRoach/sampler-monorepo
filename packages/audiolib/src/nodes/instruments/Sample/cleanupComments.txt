SampleVoicePool: 


// Old version below:
// const freeVoice = this.#allVoices.find(
//   (v) => v.state === VoiceState.STOPPED || v.state === VoiceState.IDLE
// );
// if (freeVoice) return { voice: freeVoice, forceStopped: false };

// console.info(`
//   Active: ${this.activeVoicesCount}
//   Available: ${this.availableVoicesCount}
//   `);

// const noteId = this.#nextNoteId++; // increments for next note

// const voiceResult = this.findVoice();
// if (!voiceResult?.voice) return midiNote;

// const { voice, forceStopped } = voiceResult;

// if (forceStopped) {
//   console.info(`pool.noteOn(): Force Stopped a voice: ${voice}`);
//   // 8ms when voice was stopped to avoid scheduling conflict
//   secondsFromNow = Math.max(secondsFromNow, 0.008);
// }
// // ! Fade out existing.. temp solution
// if (this.#activeVoices.has(midiNote)) {
//   // this.noteOff(midiNote);
// }
// this.#activeVoices.set(midiNote, voice);

// findVoice() {
//   // First priority: find an inactive voice
//   if (this.#available.size > 0) {
//     const availableVoice = pop(this.#available);
//     return { voice: availableVoice, forceStopped: false };
//   }

//   // Second priority: find a releasing voice
//   const releasingVoice = this.#allVoices.find(
//     (v) => v.state === VoiceState.RELEASING
//   );

//   if (releasingVoice) {
//     releasingVoice.stop();
//     this.#available.delete(releasingVoice);
//     console.info('Had to resort to stopping a releasing voice: ', {
//       releasingVoice,
//     });
//     return { voice: releasingVoice, forceStopped: true };
//   }

//   // Third priority: find the oldest playing voice
//   const oldestVoice = this.#allVoices.reduce(
//     (oldest, voice) =>
//       !oldest || voice.startTime < oldest.startTime ? voice : oldest,
//     null as SampleVoice | null
//   );

//   if (oldestVoice) {
//     oldestVoice.stop();
//     this.#available.delete(oldestVoice);
//     console.info('Had to resort to stopping the oldest playing voice: ', {
//       oldestVoice,
//     });
//     return { voice: oldestVoice, forceStopped: true };
//   }

//   return null;
// }


SampleVoice:


// // normalizeParam is currently not used
// private normalizeParam(paramName: string, actualValue: number): number {
//   switch (paramName) {
//     case 'startPoint':
//     case 'endPoint':
//     case 'loopStart':
//     case 'loopEnd':
//       return actualValue / this.#sampleDuration; // seconds → 0-1

//     case 'velocity':
//       return actualValue / 127; // MIDI → 0-1

//     default:
//       return actualValue; // Already normalized
//   }
// }

// setEndPoint = (point: number, timestamp = this.now) => {
//   console.trace(point);

//   console.log(`setEndPoint called with: ${point}`);
//   console.log(`Sample duration: ${this.#sampleDuration}`);
//   console.log(`Will denormalize to: ${point * this.#sampleDuration}`);

//   this.setParam('endPoint', point, timestamp);

//   // Skip all the param reading - just calculate duration directly
//   // const startSeconds = this.denormalizeParam('startPoint', 0); // Assume start is 0 for now
//   // const endSeconds = this.denormalizeParam('endPoint', point);
//   // const duration = endSeconds - startSeconds;

//   // this.#ampEnvelope.duration = duration;
// };

// setStartPoint = (point: number, timestamp = this.now) => {
//   this.setParam('startPoint', point, timestamp);

//   // Same direct calculation
//   // const startSeconds = this.denormalizeParam('startPoint', point);
//   // const endSeconds = this.denormalizeParam('endPoint', 1); // Assume end is 1 for now
//   // const duration = endSeconds - startSeconds;

//   // this.#ampEnvelope.duration = duration;
// };

// refreshPlaybackDuration() {
//   const startParam = this.getParam('startPoint');
//   const endParam = this.getParam('endPoint');

//   if (!startParam || !endParam) {
//     throw new Error(`startPoint or endPoint not defined!`);
//   }

//   const durationInSeconds = endParam.value - startParam.value;
//   this.#playbackDuration = durationInSeconds;

//   // Set envelope to match playback duration
//   this.#ampEnvelope.duration = durationInSeconds;
//   // this.setAmpEnvDuration(durationInSeconds);

//   return durationInSeconds;
// }

// setAmpEnvDuration = (duration = this.#playbackDuration, divideBy = 1) => {
//   this.#ampEnvelope.duration = duration / divideBy;
// };

// static readonly paramDescriptors = SAMPLE_VOICE_PARAM_DESCRIPTORS;
// // Converts descriptors to AudioWorkletNode format
// static getAudioParamDescriptors(): AudioParamDescriptor[] {
//   return Object.values(SAMPLE_VOICE_PARAM_DESCRIPTORS).map(
//     toAudioParamDescriptor
//   );
// }

// /**  Convert from normalized values (0 to 1) to actual values,
//  * based on the current sample duration
//  */
// private denormalizeParam(paramName: string, normalizedValue: number): number {
//   switch (paramName) {
//     case 'startPoint':
//     case 'endPoint':
//     case 'loopStart':
//     case 'loopEnd':
//       return normalizedValue * this.#sampleDuration; // 0-1 → 0-sampleDuration seconds

//     // Filters use Hz, velocity uses midi values (normalized by processor)
//     // playbackRate & envGain are already normalized

//     default:
//       return normalizedValue;
//   }
// }

  // #sanitizeParamValue(paramName: string, value: number): number {
  //   // Guard against NaN, Infinity, and extreme values
  //   if (!isFinite(value) || isNaN(value)) {
  //     console.warn(`Invalid ${paramName} value: ${value}, using default`);
  //     console.trace(value);
  //     return SAMPLE_VOICE_PARAM_DESCRIPTORS[paramName]?.defaultValue ?? 0;
  //   }
  //   return value;
  // }

  SamplePlayer: 


// let noteId: ActiveNoteId;
// let midiNote: MidiValue | undefined;

// if (note >= 0 && note <= 127) {
//   midiNote = note as MidiValue;
//   noteId = this.#midiNoteToId.get(midiNote) ?? -1;
//   if (noteId !== -1) {
//     this.#midiNoteToId.delete(midiNote);
//   } else {
//     // No matching noteId found
//     return this;
//   }
// } else {
//   // It's already a noteId
//   noteId = note as ActiveNoteId;

//   // Find and remove from midiNoteToId if present
//   for (const [midi, id] of this.#midiNoteToId.entries()) {
//     if (id === noteId) {
//       midiNote = midi;
//       this.#midiNoteToId.delete(midi);
//       break;
//     }
//   }
// }

// reset start and end offset is handled by SampleVoice
// todo: use firstZero, lastZero in samplevoice

// const storedStart = this.getStoredParamValue('startPoint', 0);
// console.warn({ storedStart });
// this.setParameterValue('startPoint', storedStart ?? zeroes[0]);
// const storedEndPoint = this.getStoredParamValue('endPoint', 0);
// console.warn({ storedEndPoint });
// const lastZero = zeroes[zeroes.length - 1] || buffer.duration;
// this.setParameterValue('endPoint', storedEndPoint || lastZero);

// this.setParameterValue('startPoint', zeroes[0]);
// const lastZero = zeroes[zeroes.length - 1] || buffer.duration;
// this.setParameterValue('endPoint', lastZero);


  // private syncEnvelopesToAllVoices() {
  //   const masterAmpEnv = this.getAmpEnvelope();
  //   const masterPitchEnv = this.getPitchEnvelope();

  //   masterAmpEnv.onChange(() => {
  //     const points = masterAmpEnv.getPoints();
  //     this.voicePool.allVoices.slice(1).forEach((voice) => {
  //       voice.getAmpEnvelope().setPoints(points);
  //     });
  //   });

  //   masterPitchEnv.onChange(() => {
  //     const points = masterPitchEnv.getPoints();
  //     this.voicePool.allVoices.slice(1).forEach((voice) => {
  //       voice.getPitchEnvelope().setPoints(points);
  //     });
  //   });
  // }

Envelope: 


//   applyEnvelopeToParam(audioParam: AudioParam, envelopeData, duration) {
//   const curve = envelopeData.loop
//     ? this.generateLoopedCurve(envelopeData.points, duration)
//     : this.generateCurveFromPoints(envelopeData.points, duration);

//   audioParam.setValueCurveAtTime(curve, this.context.currentTime, duration);
// }

// generateLoopedCurve(points, totalDuration) {
//   const sampleRate = 1000;
//   const totalSamples = Math.floor(totalDuration * sampleRate);

//   // Generate one cycle of the envelope
//   const cycleLength = 500; // 0.5 seconds per cycle (adjust as needed)
//   const oneCycle = new Float32Array(cycleLength);

//   for (let i = 0; i < cycleLength; i++) {
//     const normalizedTime = i / (cycleLength - 1);
//     oneCycle[i] = this.interpolateValueAtTime(points, normalizedTime);
//   }

//   // Repeat the cycle to fill total duration
//   const curve = new Float32Array(totalSamples);
//   for (let i = 0; i < totalSamples; i++) {
//     curve[i] = oneCycle[i % cycleLength];
//   }

//   return curve;
// }

// applyToAudioParam(
//   audioParam: AudioParam,
//   startTime: number,
//   loop: boolean,
//   duration = this.envelopeDuration,
//   minValue: number = 0.001
// ) {
//   // Generate curve array
//   const sampleRate = 1000; // 1000 samples per second
//   const numSamples = Math.max(2, Math.floor(duration * sampleRate));
//   const curve = new Float32Array(numSamples);

//   // Fill the curve array by sampling the envelope
//   for (let i = 0; i < numSamples; i++) {
//     const normalizedTime = loop
//       ? (i / (numSamples - 1)) % 1 // Wraps 0→1→0→1→0...
//       : i / (numSamples - 1); // Normal 0→1

//     const value = this.interpolateValueAtTime(normalizedTime);
//     curve[i] = Math.max(value, minValue);
//   } // const now = this.context.currentTime;
//   audioParam.cancelScheduledValues(startTime);

//   // todo: delete cancelScheduledParamValues or fix and test
//   // audioParam.setValueAtTime(audioParam.value, startTime);
//   // cancelScheduledParamValues(audioParam, startTime);
//   audioParam.setValueCurveAtTime(curve, startTime, duration);
// }


  // #startContinuousLoop(
  //   audioParam: AudioParam,
  //   startTime: number,
  //   minValue: number
  // ) {
  //   let isLooping = true;
  //   let currentCycleStart = startTime;

  //   const scheduleNextCycle = () => {
  //     if (!isLooping) return;

  //     audioParam.cancelScheduledValues(currentCycleStart);

  //     // Generate and apply one cycle
  //     const sampleRate = 1000;
  //     const numSamples = Math.max(
  //       2,
  //       Math.floor(this.durationSeconds * sampleRate)
  //     );
  //     const curve = new Float32Array(numSamples);

  //     for (let i = 0; i < numSamples; i++) {
  //       const normalizedTime = i / (numSamples - 1);
  //       const value = this.interpolateValueAtTime(normalizedTime);
  //       curve[i] = Math.max(value, minValue);
  //     }

  //     audioParam.setValueCurveAtTime(
  //       curve,
  //       currentCycleStart,
  //       this.durationSeconds
  //     );

  //     // Schedule next cycle
  //     currentCycleStart += this.durationSeconds;
  //     const timeUntilNext =
  //       (currentCycleStart - this.context.currentTime) * 1000;

  //     if (timeUntilNext > 0) {
  //       setTimeout(scheduleNextCycle, Math.max(timeUntilNext - 50, 0));
  //     } else {
  //       scheduleNextCycle(); // Immediate if we're behind
  //     }
  //   };

  //   scheduleNextCycle();
  //   this.#loopStopFunction = () => {
  //     isLooping = false;
  //   };
  // }
