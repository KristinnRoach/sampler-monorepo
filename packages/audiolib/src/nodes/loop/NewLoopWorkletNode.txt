// LoopWorkletNode
// Extends WorkletNode with loop functionality

import { WorkletNode } from '../worklet/WorkletNode';
import { WorkletManager } from '../worklet/WorkletManager';

export class LoopWorkletNode extends WorkletNode {
  sourceNode: AudioBufferSourceNode | null = null;
  stable: boolean = false;

  /**
   * Connect the loop processor to a source node and set up message handling
   * @param sourceNode - The AudioBufferSourceNode to control loop points for
   * @returns Success status
   */
  connectToSource(sourceNode: AudioBufferSourceNode): boolean {
    this.sourceNode = sourceNode;
    sourceNode.connect(this);
    this.connect(this.context.destination);

    // Initialize the processor with current loop points
    this.port.postMessage({
      type: 'init',
      loopStart: sourceNode.loopStart,
      loopEnd: sourceNode.loopEnd,
    });

    return true;
  }

  /**
   * Set loop start point with optional scheduling
   * @param value - Loop start position in seconds
   * @param time - When to schedule the change (defaults to now)
   */
  setLoopStart(value: number, time?: number): void {
    this.setParam('loopStart', value, time);
  }

  /**
   * Set loop end point with optional scheduling
   * @param value - Loop end position in seconds
   * @param time - When to schedule the change (defaults to now)
   */
  setLoopEnd(value: number, time?: number): void {
    this.setParam('loopEnd', value, time);
  }

  /**
   * Set interpolation speed for smooth transitions
   * @param value - Interpolation speed (0.001 to 1.0)
   * @param time - When to schedule the change (defaults to now)
   */
  setInterpolationSpeed(value: number, time?: number): void {
    this.setParam('interpolationSpeed', value, time);
  }

  /**
   * Factory method to create a LoopWorkletNode
   * @param context - Audio context
   * @param manager - Worklet manager instance
   * @returns The created node
   */
  static async create(
    context: BaseAudioContext,
    manager: WorkletManager
  ): Promise<LoopWorkletNode> {
    // Define parameters
    const params = [
      {
        name: 'loopStart',
        defaultValue: 0,
        minValue: 0,
        maxValue: 1000,
      },
      {
        name: 'loopEnd',
        defaultValue: 1,
        minValue: 0,
        maxValue: 1000,
      },
      {
        name: 'interpolationSpeed',
        defaultValue: 0.05,
        minValue: 0.001,
        maxValue: 1.0,
      },
    ];

    // Custom message handler for the processor
    const messageHandler = function (event: MessageEvent): void {
      if (event.data.type === 'init') {
        // Initialize with source node's current settings if needed
        this.currentLoopStart = event.data.loopStart || 0;
        this.currentLoopEnd = event.data.loopEnd || 1;
      }
    };

    // Define process function - based on loop-processor.js
    const processFunction = function (
      inputs: Float32Array[][],
      outputs: Float32Array[][],
      parameters: Record<string, Float32Array>
    ): boolean {
      // Pass through audio unmodified
      const input = inputs[0];
      const output = outputs[0];

      // Get parameter values
      const targetLoopStart = parameters.loopStart[0];
      const targetLoopEnd = parameters.loopEnd[0];
      const interpolationSpeed = parameters.interpolationSpeed[0];

      // Track if anything has changed
      const minChange = 0.00005; // Small threshold
      const hasChanges =
        Math.abs(targetLoopStart - this.currentLoopStart) > minChange ||
        Math.abs(targetLoopEnd - this.currentLoopEnd) > minChange;

      // Only do interpolation and send messages if there are changes
      if (hasChanges) {
        // Smoothly interpolate loop points
        this.currentLoopStart +=
          (targetLoopStart - this.currentLoopStart) * interpolationSpeed;
        this.currentLoopEnd +=
          (targetLoopEnd - this.currentLoopEnd) * interpolationSpeed;

        // Send updated loop points while interpolating to main thread
        this.port.postMessage({
          type: 'update',
          loopStart: this.currentLoopStart,
          loopEnd: this.currentLoopEnd,
        });
      }

      // Pass audio through unchanged
      for (
        let channel = 0;
        channel < input?.length && channel < output?.length;
        channel++
      ) {
        const inputChannel = input[channel];
        const outputChannel = output[channel];
        for (let i = 0; i < inputChannel.length; i++) {
          outputChannel[i] = inputChannel[i];
        }
      }

      return true;
    };

    // Create the node with initial state variables
    const node = await WorkletNode.create(context, manager, {
      processorName: 'loop',
      processFunction,
      params,
      nodeOptions: { numberOfInputs: 1, numberOfOutputs: 1 },
      processorOptions: {
        state: {
          currentLoopStart: 0,
          currentLoopEnd: 1,
        },
        messageHandler,
      },
    });

    // Convert to our specialized class
    Object.setPrototypeOf(node, LoopWorkletNode.prototype);

    // Set up port message handling on the node
    node.port.onmessage = (event: MessageEvent) => {
      if (event.data.type === 'update' && node.sourceNode) {
        node.sourceNode.loopStart = event.data.loopStart;
        node.sourceNode.loopEnd = event.data.loopEnd;
      }
    };

    return node as LoopWorkletNode;
  }
}
