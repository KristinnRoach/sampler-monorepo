// VoicePool.ts
import { VoiceNode, createVoice } from './VoiceNode';
import { midiToDetune } from './midiUtils';

export async function createVoicePool(
  context: BaseAudioContext,
  buffer: AudioBuffer,
  instrumentId: string,
  voiceCount: number = 8
): Promise<VoicePool> {
  const pool = new VoicePool(context, instrumentId);
  await pool.init(buffer, voiceCount);
  return pool;
}

class VoicePool {
  private instrumentId: string;
  private context: BaseAudioContext;
  // private voices: Set<VoiceNode> = new Set();
  private voices: VoiceNode[] = [];

  constructor(context: BaseAudioContext, instrumentId: string) {
    this.context = context;
    this.instrumentId = instrumentId;
    this.voices = [];
  }

  async init(buffer: AudioBuffer, voiceCount: number = 8): Promise<void[]> {
    for (let i = 0; i < voiceCount; i++) {
      await this.addVoice(buffer);
    }
    return Promise.all(this.voices.map((voice) => voice.init()));
  }

  get voiceCount(): number {
    return this.voices.length;
  }

  activeVoiceCount(): number {
    return this.voices.filter((v) => !v.isAvailable()).length;
  }

  /**
   * Create a new voice and add it to the pool
   */
  private async addVoice(
    buffer: AudioBuffer,
    rootNote: number = 60
  ): Promise<VoiceNode> {
    const voice = await createVoice(this.context, buffer, rootNote);
    this.voices.push(voice);
    return voice;
  }

  /**
   * Get the first available voice
   * @returns The first available voice, or null if no voices are available
   */
  getAvailableVoice(): VoiceNode | null {
    const voice = this.voices.find((v) => v.isAvailable());
    if (voice) {
      // Move this voice to the end of the array (newest used)
      const index = this.voices.indexOf(voice);
      if (index > -1) {
        this.voices.splice(index, 1);
        this.voices.push(voice);
      }
      return voice;
    }
    return null;
  }

  /**
   * Play a buffer on the next available voice
   * @returns The voice being used for playback, or null if no voices are available
   */
  play(
    midiNote: number,
    velocity?: number,
    startTime?: number
  ): VoiceNode | null {
    // Find an inactive voice
    let voice = this.voices.find((v) => v.isAvailable());

    // If no inactive voice is found, steal the oldest one
    if (!voice && this.voices.length > 0) {
      voice = this.voices[0];
    }

    const detune = midiToDetune(midiNote);

    if (voice) {
      voice.play(detune, velocity, startTime);

      // Move this voice to the end of the array (newest used)
      const index = this.voices.indexOf(voice);
      if (index > -1) {
        this.voices.splice(index, 1);
        this.voices.push(voice);
      }

      return voice;
    }

    return null;
  }

  /**
   * Release all voices and clear the pool
   */
  clear(): void {
    this.voices.forEach((voice) => {
      voice.triggerRelease();
    });
    this.voices = [];
  }
}

export type { VoicePool };
