<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Audio API vs GSAP experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- Add CustomEase and CustomWiggle -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/CustomEase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/CustomWiggle.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: #f5f5f5;
      }

      .container {
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 30px;
      }

      .controls {
        display: flex;
        gap: 20px;
        align-items: center;
        margin: 30px 0;
        flex-wrap: wrap;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      label {
        font-weight: bold;
        color: #555;
      }

      input,
      select,
      button {
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
      }

      button {
        background: #007acc;
        color: white;
        border: none;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.2s;
        min-width: 140px;
      }

      button:hover {
        background: #005a9e;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .experiment {
        background: #f9f9f9;
        padding: 20px;
        border-radius: 6px;
        margin: 20px 0;
        border-left: 4px solid #007acc;
      }

      .status {
        font-weight: bold;
        padding: 15px;
        border-radius: 4px;
        margin: 15px 0;
        text-align: center;
      }

      .status.playing {
        background: #d4edda;
        color: #155724;
      }

      .status.stopped {
        background: #f8d7da;
        color: #721c24;
      }

      .comparison {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
        padding: 15px;
        border-radius: 4px;
        margin: 15px 0;
      }

      .improvements {
        background: #d1ecf1;
        border: 1px solid #b6d4da;
        color: #0c5460;
        padding: 15px;
        border-radius: 4px;
        margin: 15px 0;
      }

      .visualizer {
        background: #f9f9f9;
        padding: 20px;
        border-radius: 6px;
        margin: 20px 0;
        border-left: 4px solid #28a745;
      }

      .freq-bar {
        width: 100%;
        height: 40px;
        background: linear-gradient(to right, #007acc, #00d4ff);
        border-radius: 4px;
        margin: 10px 0;
        transform-origin: left;
        transform: scaleX(0.5);
        transition: none;
      }

      .freq-display {
        font-family: 'Courier New', monospace;
        font-size: 18px;
        font-weight: bold;
        color: currentColor;
        text-align: center;
        margin: 10px 0;
      }

      .waveform-container {
        background: transparent;
        border-radius: 4px;
        margin: 15px 0;
        padding: 10px;
        height: 120px;
        position: relative;
        overflow: hidden;
      }

      .waveform-canvas {
        background: transparent;
        width: 100%;
        height: 100%;
        display: block;
      }

      .automation-container {
        background: transparent;
        border-radius: 4px;
        margin: 15px 0;
        padding: 10px;
        height: 120px;
        position: relative;
        overflow: hidden;
      }

      .automation-canvas {
        background: transparent;
        width: 100%;
        height: 100%;
        display: block;
      }

      .wiggle-test {
        background: #e8f5e8;
        border: 1px solid #28a745;
        color: #155724;
        padding: 15px;
        border-radius: 4px;
        margin: 15px 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Web Audio API vs GSAP Timing Experiment</h1>

      <div class="experiment">
        <p>
          <strong>üéØ Experiment Goal:</strong>
        </p>
        <p>
          Compare Web Audio API's "setValueCurveAtTime" with GSAP's native
          interpolation capabilities + CustomWiggle test
        </p>
      </div>

      <!-- Add minimal CustomWiggle test -->
      <div class="wiggle-test">
        <p><strong>üîß CustomWiggle Test:</strong></p>
        <button id="testWiggleBtn">Test CustomWiggle</button>
        <div id="wiggleStatus">Ready to test</div>
      </div>

      <div class="controls">
        <div class="control-group">
          <label for="curveType">Curve Type</label>
          <select id="curveType">
            <option value="linear">Linear Sweep</option>
            <option value="exponential">Exponential</option>
            <option value="sine">Sine Wave</option>
            <option value="wiggle">Wiggle (Test)</option>
          </select>
        </div>

        <div class="control-group">
          <label for="duration">Duration</label>
          <input
            type="range"
            id="duration"
            min="1"
            max="4"
            value="2"
            step="0.5"
          />
          <span id="durationValue">2.0s</span>
        </div>
      </div>

      <div class="controls">
        <button id="playWebAudioBtn">üéµ Web Audio API</button>
        <button id="playGsapBtn">üé® GSAP Keyframes</button>
        <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
      </div>

      <div id="status" class="status stopped">Ready</div>

      <div class="visualizer">
        <div class="freq-display" id="freqDisplay">440 Hz</div>
        <div class="freq-bar" id="freqBar"></div>

        <div class="waveform-container">
          <canvas
            class="waveform-canvas"
            id="waveformCanvas"
            width="800"
            height="100"
          ></canvas>
        </div>

        <div class="automation-container">
          <canvas
            class="automation-canvas"
            id="automationCanvas"
            width="800"
            height="100"
          ></canvas>
        </div>
      </div>

    <script>
      class TimingComparison {
        constructor() {
          this.audioContext = null;
          this.oscillator = null;
          this.gainNode = null;
          this.gsapTween = null;
          this.visualTween = null;
          this.isPlaying = false;

          this.freqBar = null;
          this.freqDisplay = null;
          this.currentPhase = 0;
          this.automationPoints = [];

          setTimeout(() => {
            this.setupEventListeners();
            this.setupVisualizer();
            this.initCustomWiggle();
          }, 0);
        }

        initCustomWiggle() {
          // Test if CustomWiggle is available
          try {
            // Try registering just CustomWiggle first
            if (typeof CustomWiggle !== 'undefined') {
              gsap.registerPlugin(CustomWiggle);
              
              CustomWiggle.create("testWiggle", {wiggles: 5, type: "easeOut"});
              
              document.getElementById('wiggleStatus').textContent = '‚úÖ CustomWiggle working (no CustomEase needed)!';
              console.log('CustomWiggle initialized successfully');
            } else {
              throw new Error('CustomWiggle not available');
            }
          } catch (error) {
            // Try using built-in GSAP wiggle syntax as fallback
            try {
              gsap.to({}, {duration: 0.1, ease: "wiggle(5)"});
              document.getElementById('wiggleStatus').textContent = '‚úÖ Built-in wiggle syntax available!';
              console.log('Using built-in GSAP wiggle syntax');
            } catch (wiggleError) {
              document.getElementById('wiggleStatus').textContent = '‚ùå No wiggle functionality available';
              console.error('No wiggle functionality found:', error, wiggleError);
            }
          }
        }

        setupVisualizer() {
          this.freqBar = document.getElementById('freqBar');
          this.freqDisplay = document.getElementById('freqDisplay');

          this.waveformCanvas = document.getElementById('waveformCanvas');
          this.waveformCtx = this.waveformCanvas.getContext('2d');

          this.automationCanvas = document.getElementById('automationCanvas');
          this.automationCtx = this.automationCanvas.getContext('2d');
          this.indicatorPos = { x: 0, y: this.automationCanvas.height / 2 };

          this.clearWaveform();
          this.clearAutomation();
        }

        async initAudio() {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }

          if (this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
          }
        }

        setupEventListeners() {
          document
            .getElementById('playWebAudioBtn')
            .addEventListener('click', () => this.playWebAudio());
          document
            .getElementById('playGsapBtn')
            .addEventListener('click', () => this.playGsap());
          document
            .getElementById('stopBtn')
            .addEventListener('click', () => this.stop());

          // Add wiggle test button
          document
            .getElementById('testWiggleBtn')
            .addEventListener('click', () => this.testCustomWiggle());

          document.getElementById('duration').addEventListener('input', (e) => {
            document.getElementById('durationValue').textContent =
              e.target.value + 's';
          });
        }

        testCustomWiggle() {
          try {
            // Test both CustomWiggle.create and built-in wiggle syntax
            let wiggleWorked = false;
            
            // Try CustomWiggle.create first
            if (typeof CustomWiggle !== 'undefined') {
              gsap.to(this.freqBar, {
                duration: 2,
                scaleX: 1.5,
                ease: "testWiggle",
                onComplete: () => {
                  gsap.set(this.freqBar, { scaleX: 0.5 });
                }
              });
              wiggleWorked = true;
            } else {
              // Fallback to built-in wiggle syntax
              gsap.to(this.freqBar, {
                duration: 2,
                scaleX: 1.5,
                ease: "wiggle(5)",
                onComplete: () => {
                  gsap.set(this.freqBar, { scaleX: 0.5 });
                }
              });
              wiggleWorked = true;
            }
            
            if (wiggleWorked) {
              document.getElementById('wiggleStatus').textContent = 'üîÑ Running wiggle test...';
              setTimeout(() => {
                document.getElementById('wiggleStatus').textContent = '‚úÖ CustomWiggle visual test passed!';
              }, 2100);
            }
            
          } catch (error) {
            document.getElementById('wiggleStatus').textContent = '‚ùå Wiggle test failed: ' + error.message;
            console.error('Wiggle test failed:', error);
          }
        }

        backgroundColor = '#ffffff';

        clearAutomation() {
          if (!this.automationCtx) return;

          const canvas = this.automationCanvas;
          const ctx = this.automationCtx;

          ctx.fillStyle = this.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;

          this.automationPoints = [];
          this.indicatorPos = { x: 0, y: canvas.height / 2 };
        }

        drawAutomationCurve() {
          if (!this.automationCtx || this.automationPoints.length < 2) return;

          const ctx = this.automationCtx;

          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          ctx.beginPath();
          ctx.moveTo(this.automationPoints[0].x, this.automationPoints[0].y);

          for (let i = 1; i < this.automationPoints.length; i++) {
            ctx.lineTo(this.automationPoints[i].x, this.automationPoints[i].y);
          }

          ctx.stroke();
        }

        drawCurrentIndicator() {
          if (!this.automationCtx || !this.indicatorPos) return;

          const ctx = this.automationCtx;

          ctx.fillStyle = '#ff4444';
          ctx.beginPath();
          ctx.arc(this.indicatorPos.x, this.indicatorPos.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        updateAutomation(frequency, progress) {
          if (!this.automationCtx) return;

          const canvas = this.automationCanvas;
          const ctx = this.automationCtx;
          const minFreq = 200;
          const maxFreq = 1100;
          const normalizedFreq = gsap.utils.mapRange(
            minFreq,
            maxFreq,
            0,
            1,
            frequency
          );
          const y = canvas.height - normalizedFreq * canvas.height;
          const x = progress * canvas.width;

          // Add point to curve
          this.automationPoints.push({ x, y, frequency });

          // Clear canvas
          ctx.fillStyle = this.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Redraw curve
          this.drawAutomationCurve();

          // Update indicator position with GSAP
          gsap.set(this.indicatorPos, { x, y });
          this.drawCurrentIndicator();
        }

        clearWaveform() {
          if (!this.waveformCtx) return;

          this.waveformCtx.fillStyle = this.backgroundColor;
          this.waveformCtx.fillRect(
            0,
            0,
            this.waveformCanvas.width,
            this.waveformCanvas.height
          );
        }

        drawWaveform(frequency) {
          if (!this.waveformCtx) return;

          const canvas = this.waveformCanvas;
          const ctx = this.waveformCtx;
          const width = canvas.width;
          const height = canvas.height;
          const centerY = height / 2;
          const amplitude = height * 0.3;

          const imageData = ctx.getImageData(2, 0, width - 2, height);
          ctx.fillStyle = this.backgroundColor;
          ctx.fillRect(0, 0, width, height);
          ctx.putImageData(imageData, 0, 0);

          const phaseIncrement = (frequency / 440) * 0.1;
          this.currentPhase += phaseIncrement;

          const x = width - 2;
          const y1 = centerY + Math.sin(this.currentPhase) * amplitude;
          const y2 =
            centerY + Math.sin(this.currentPhase + phaseIncrement) * amplitude;

          ctx.strokeStyle = `hsl(${180 + (frequency - 440) / 10}, 70%, 60%)`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y1);
          ctx.lineTo(x + 2, y2);
          ctx.stroke();
        }

        updateVisualization(frequency) {
          if (!this.freqBar || !this.freqDisplay) return;

          const scale = Math.min(frequency / 880, 2.0);
          this.freqBar.style.transform = `scaleX(${scale})`;

          this.freqDisplay.textContent = `${Math.round(frequency)} Hz`;

          const hue = Math.min(((frequency - 440) / 440) * 120, 240);
          this.freqBar.style.background = `linear-gradient(to right, hsl(${200 + hue}, 70%, 50%), hsl(${200 + hue}, 80%, 70%))`;

          this.drawWaveform(frequency);
        }

        getCurveValue(progress, curveType) {
          const baseFreq = 440;

          switch (curveType) {
            case 'linear':
              return baseFreq + baseFreq * progress;
            case 'exponential':
              return baseFreq * Math.pow(2, progress * 2);
            case 'sine':
              return (
                baseFreq + baseFreq * 0.5 * Math.sin(progress * Math.PI * 4)
              );
            case 'wiggle':
              // Simple wiggle test - basic oscillation
              return baseFreq + baseFreq * 0.3 * Math.sin(progress * Math.PI * 10) * (1 - progress);
            default:
              return baseFreq;
          }
        }

        generateCurve() {
          const curveType = document.getElementById('curveType').value;
          const numPoints = 200;
          const curve = new Float32Array(numPoints);

          for (let i = 0; i < numPoints; i++) {
            const progress = gsap.utils.mapRange(0, numPoints - 1, 0, 1, i);
            curve[i] = this.getCurveValue(progress, curveType);
          }

          return curve;
        }

        createGsapKeyframes(duration) {
          const curveType = document.getElementById('curveType').value;
          const numKeyframes = 60; 
          const keyframes = [];

          for (let i = 0; i < numKeyframes; i++) {
            const progress = gsap.utils.mapRange(0, numKeyframes - 1, 0, 1, i);
            const frequency = this.getCurveValue(progress, curveType);

            keyframes.push({
              frequency: frequency,
              duration: duration / numKeyframes,
            });
          }

          return keyframes;
        }

        async playWebAudio() {
          try {
            await this.initAudio();
            this.stop();

            this.oscillator = this.audioContext.createOscillator();
            this.gainNode = this.audioContext.createGain();

            this.oscillator.connect(this.gainNode);
            this.gainNode.connect(this.audioContext.destination);

            const duration = parseFloat(
              document.getElementById('duration').value
            );
            const curve = this.generateCurve();

            this.oscillator.frequency.value = 440;
            this.gainNode.gain.value = 0.2;

            const startTime = this.audioContext.currentTime + 0.01;
            this.oscillator.frequency.setValueCurveAtTime(
              curve,
              startTime,
              duration
            );

            this.oscillator.start(startTime);
            this.oscillator.stop(startTime + duration + 0.1);

            // Visualize with GSAP for consistency
            const syncDelay = Math.max(
              0,
              (startTime - this.audioContext.currentTime) * 1000
            );
            this.animateVisualization(curve, duration, syncDelay);

            this.updateUI('Web Audio API', duration);

            setTimeout(() => this.stop(), (duration + 0.1) * 1000);
          } catch (error) {
            console.error('Web Audio error:', error);
          }
        }

        async playGsap() {
          try {
            await this.initAudio();
            this.stop();

            this.oscillator = this.audioContext.createOscillator();
            this.gainNode = this.audioContext.createGain();

            this.oscillator.connect(this.gainNode);
            this.gainNode.connect(this.audioContext.destination);

            const duration = parseFloat(
              document.getElementById('duration').value
            );

            this.oscillator.frequency.value = 440;
            this.gainNode.gain.value = 0.2;

            const startTime = this.audioContext.currentTime + 0.01;
            this.oscillator.start(startTime);

            const syncDelay = Math.max(
              0,
              (startTime - this.audioContext.currentTime) * 1000
            );

            // Clear automation display
            this.clearAutomation();

            // Create frequency object for GSAP to animate
            const freqObj = { frequency: 440 };

            // Generate keyframes using GSAP utilities
            const keyframes = this.createGsapKeyframes(duration);

            // Create timeline with defaults
            this.gsapTween = gsap.timeline({
              delay: syncDelay / 1000,
              defaults: {
                ease: 'none',
              },
            });

            // Use GSAP's keyframes feature for smooth interpolation
            this.gsapTween.to(freqObj, {
              keyframes: keyframes,
              onUpdate: () => {
                if (this.oscillator && this.oscillator.frequency) {
                  this.oscillator.frequency.value = freqObj.frequency;
                  this.updateVisualization(freqObj.frequency);

                  // Calculate progress for automation display
                  const currentTime = this.gsapTween.time();
                  const progress = gsap.utils.mapRange(
                    0,
                    duration,
                    0,
                    1,
                    currentTime
                  );
                  this.updateAutomation(
                    freqObj.frequency,
                    Math.max(0, Math.min(1, progress))
                  );
                }
              },
              onComplete: () => this.stop(),
            });

            this.updateUI('GSAP Keyframes', duration);
          } catch (error) {
            console.error('GSAP error:', error);
          }
        }

        animateVisualization(curve, duration, delay = 0) {
          if (!this.freqBar) return;

          this.clearAutomation();

          // Use GSAP keyframes for visualization too
          const visualKeyframes = [];
          const sampleRate = 60;
          const totalSamples = Math.floor(duration * sampleRate);

          for (let i = 0; i <= totalSamples; i++) {
            const progress = gsap.utils.mapRange(0, totalSamples, 0, 1, i);
            const curveIndex = Math.floor(progress * (curve.length - 1));
            const frequency = curve[curveIndex];

            visualKeyframes.push({
              duration: duration / totalSamples,
              onStart: () => {
                this.updateVisualization(frequency);
                this.updateAutomation(frequency, progress);
              },
            });
          }

          this.visualTween = gsap.timeline({
            delay: delay / 1000,
            defaults: { ease: 'none' },
          });

          this.visualTween.to({}, { keyframes: visualKeyframes });

          this.visualTween.call(
            () => this.updateVisualization(440),
            [],
            duration
          );
        }

        updateUI(method, duration) {
          this.isPlaying = true;
          document.getElementById('playWebAudioBtn').disabled = true;
          document.getElementById('playGsapBtn').disabled = true;
          document.getElementById('stopBtn').disabled = false;
          document.getElementById('status').textContent =
            `Playing ${method} for ${duration}s`;
          document.getElementById('status').className = 'status playing';
        }

        stop() {
          if (this.gsapTween) {
            this.gsapTween.kill();
            this.gsapTween = null;
          }

          if (this.visualTween) {
            this.visualTween.kill();
            this.visualTween = null;
          }

          if (this.oscillator) {
            try {
              this.oscillator.stop();
            } catch (e) {
              // Already stopped
            }
            this.oscillator = null;
          }

          this.updateVisualization(440);
          this.clearWaveform();
          this.clearAutomation();
          this.currentPhase = 0;

          this.isPlaying = false;
          document.getElementById('playWebAudioBtn').disabled = false;
          document.getElementById('playGsapBtn').disabled = false;
          document.getElementById('stopBtn').disabled = true;
          document.getElementById('status').textContent = 'Ready to compare';
          document.getElementById('status').className = 'status stopped';
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        new TimingComparison();
      });
    </script>
  </body>
</html>