<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Ease Viz</title>
    <style>
      body {
        background: #1d1d1d;
        font-family: sans-serif;
        color: #e8f5e9;
        display: flex;
        align-items: center;
        flex-direction: column;
      }
      svg {
        width: clamp(360px, 60vw, 600px);
        overflow: visible;
      }
      .nav {
        width: clamp(375px, 60vw, 600px);
      }
      line {
        stroke: #ccc;
        opacity: 0.5;
      }
      select {
        margin: 10px 0 18px 0;
        outline: none;
        cursor: pointer;
        background-color: #eee;
        border-radius: 5px;
        padding: 10px;
        box-shadow: 5px 5px 20px rgba(0, 0, 0, 0.4);
        font-size: 16px;
        font-weight: bold;
        text-align: center;
      }
      .debug {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        font-size: 12px;
        font-family: monospace;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomEase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MorphSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/DrawSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathHelper.min.js"></script>
  </head>
  <body>
    <div class="nav">
      <label for="easeSelect">Choose an Ease</label>
      <select id="easeSelect">
        <option value="linear">Linear</option>
        <option value="easeOut">Ease Out</option>
        <option value="easeInOut">Ease In-Out</option>
        <option value="bounce">Bounce</option>
        <option value="elastic">Elastic</option>
        <option value="power1">power1</option>
        <option value="power4">power4</option>
        <option value="circ">circ</option>
        <option value="back">back</option>
      </select>
    </div>

    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500" width="500">
      <path id="motionPath" d="M 0 500 L 500 0" fill="none" stroke="green" />
      <g id="dummy-g"></g>

      <!-- Grid lines -->
      <g>
        <line x1="1" y1="1" x2="1" y2="500"></line>
        <line x1="100" y1="0" x2="100" y2="500"></line>
        <line x1="200" y1="0" x2="200" y2="500"></line>
        <line x1="300" y1="0" x2="300" y2="500"></line>
        <line x1="400" y1="0" x2="400" y2="500"></line>
        <line x1="499" y1="0" x2="499" y2="500"></line>
      </g>

      <!-- Horizontal grid -->
      <g transform="matrix(0, 1, -1, 0, 500, 0)">
        <line x1="1" y1="1" x2="1" y2="500"></line>
        <line x1="100" y1="0" x2="100" y2="500"></line>
        <line x1="200" y1="0" x2="200" y2="500"></line>
        <line x1="300" y1="0" x2="300" y2="500"></line>
        <line x1="400" y1="0" x2="400" y2="500"></line>
        <line x1="499" y1="0" x2="499" y2="500"></line>
      </g>
    </svg>

    <button id="startBtn">Start</button>
    <div class="debug" id="debugInfo">Ready</div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        gsap.registerPlugin(
          CustomEase,
          MorphSVGPlugin,
          DrawSVGPlugin,
          MotionPathPlugin
        );

        const btnEl = document.getElementById('startBtn');
        const motionPathEl = document.getElementById('motionPath');
        const easeSelect = document.getElementById('easeSelect');
        const debugInfo = document.getElementById('debugInfo');

        let duration = 1;
        let currentEaseName = 'linear';
        let currentCustomEase = null;
        let isPathModified = false;
        let motionTween;
        let helper;
        let audioContext;
        let isPlaying = false;

        const simpleEases = {
          linear: 'M0,0 L1,1',
          easeOut: 'M0,0 C0,0 0.2,1 1,1',
          easeInOut: 'M0,0 C0.4,0 0.6,1 1,1',
          bounce: 'M0,0 C0.3,0 0.3,1.4 0.5,1 C0.7,0.6 0.7,1.2 1,1',
          elastic: 'M0,0 C0.2,0 0.2,1.6 0.4,1 C0.6,0.4 0.8,1.4 1,1',
        };

        function resetMotionPath() {
          motionTween = gsap.to('#dummy-g', {
            motionPath: {
              path: '#motionPath',
              align: '#motionPath',
              alignOrigin: [0.5, 0.5],
            },
          });
          helper = MotionPathHelper.create('#dummy-g');
        }

        let lastPathData = motionPathEl.getAttribute('d');
        const pathObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (
              mutation.type === 'attributes' &&
              mutation.attributeName === 'd'
            ) {
              const currentPathData = motionPathEl.getAttribute('d');
              if (currentPathData !== lastPathData) {
                lastPathData = currentPathData;
                isPathModified = true;
                try {
                  const normalizedPath =
                    normalizePathForEasing(currentPathData);
                  currentCustomEase = CustomEase.create(
                    'pathEase',
                    normalizedPath
                  );
                  debugInfo.textContent = 'Using custom path ease';
                } catch (e) {
                  debugInfo.textContent = `Path error: ${e.message}`;
                }
              }
            }
          });
        });

        pathObserver.observe(motionPathEl, {
          attributes: true,
          attributeFilter: ['d'],
        });

        function normalizePathForEasing(pathData) {
          const coordMatches = pathData.match(/[\d.]+/g);
          if (!coordMatches || coordMatches.length < 4) {
            throw new Error('Invalid path data');
          }

          const coords = coordMatches.map(Number);
          let minX = Math.min(...coords.filter((_, i) => i % 2 === 0));
          let maxX = Math.max(...coords.filter((_, i) => i % 2 === 0));
          let minY = Math.min(...coords.filter((_, i) => i % 2 === 1));
          let maxY = Math.max(...coords.filter((_, i) => i % 2 === 1));

          if (maxX - minX === 0) maxX = minX + 1;
          if (maxY - minY === 0) maxY = minY + 1;

          let normalizedPath = pathData.replace(
            /[\d.]+/g,
            (match, offset, string) => {
              const index =
                string.substring(0, offset).match(/[\d.]+/g)?.length || 0;
              const isX = index % 2 === 0;
              const value = Number(match);

              if (isX) {
                return ((value - minX) / (maxX - minX)).toFixed(3);
              } else {
                return (1 - (value - minY) / (maxY - minY)).toFixed(3);
              }
            }
          );

          return normalizedPath;
        }

        easeSelect.addEventListener('change', () => {
          currentEaseName = easeSelect.value;
          isPathModified = false;
          currentCustomEase = null;

          if (simpleEases[currentEaseName]) {
            const simplePath = simpleEases[currentEaseName]
              .replace(/([ML]?)([0-9.]+),([0-9.]+)/g, (match, cmd, x, y) => {
                const newX = parseFloat(x) * 500;
                const newY = 500 - parseFloat(y) * 500;
                return `${cmd || 'L'}${newX},${newY}`;
              })
              .replace(/C([0-9.,\s]+)/g, (match, coords) => {
                const numbers = coords
                  .split(/[,\s]+/)
                  .map((n) => parseFloat(n));
                const converted = [];
                for (let i = 0; i < numbers.length; i += 2) {
                  converted.push(numbers[i] * 500);
                  converted.push(500 - numbers[i + 1] * 500);
                }
                return `C${converted.join(',')}`;
              });

            debugInfo.textContent = `Simple ease: ${currentEaseName}`;
            motionPathEl.setAttribute('d', simplePath);
            if (motionTween) motionTween.kill();
            if (helper) helper.kill();
            resetMotionPath();
          } else {
            const svgPath = CustomEase.getSVGData(currentEaseName, {
              width: 500,
              height: 500,
            });
            debugInfo.textContent = `Built-in ease: ${currentEaseName}`;

            if (motionTween) motionTween.kill();
            if (helper) helper.kill();

            motionTween = gsap.to('#motionPath', {
              morphSVG: svgPath,
              duration: 0.1,
              onComplete: () => resetMotionPath(),
            });
          }
        });

        btnEl.addEventListener('click', () => {
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          if (audioContext.state !== 'running') audioContext.resume();

          gsap.fromTo(
            '#motionPath',
            { drawSVG: '0% 0%' },
            { duration: duration, drawSVG: '0% 100%' }
          );

          const easingSource = isPathModified
            ? currentCustomEase
            : currentEaseName;
          playWithEasing(easingSource);
        });

        function getEasingValues(
          easingSource,
          duration = 1,
          sampleRate = 1000
        ) {
          const audioValues = [];
          const timeStep = duration / sampleRate;

          let easingFunction;
          if (typeof easingSource === 'string') {
            const dummyTween = gsap.to({}, { duration: 1, ease: easingSource });
            easingFunction = dummyTween._ease;
            dummyTween.kill();
          } else if (easingSource && typeof easingSource === 'function') {
            easingFunction = easingSource;
          } else {
            easingFunction = (t) => t;
          }

          for (let i = 0; i < sampleRate; i++) {
            const time = i * timeStep;
            const normalizedTime = time / duration;
            const easedProgress = easingFunction(normalizedTime);
            const clampedProgress = Math.max(0, Math.min(1, easedProgress));
            const frequency = 200 + clampedProgress * 1000;

            audioValues.push({ time: time, value: frequency });
          }

          return audioValues;
        }

        function playWithEasing(easingSource) {
          if (isPlaying) return;
          isPlaying = true;

          const startTime = audioContext.currentTime;
          const audioValues = getEasingValues(easingSource, duration);

          const oscillator = audioContext.createOscillator();
          const filter = audioContext.createBiquadFilter();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(audioValues[0].value, startTime);

          filter.type = 'lowpass';
          filter.Q.setValueAtTime(1, startTime);
          filter.frequency.setValueAtTime(2000, startTime);

          audioValues.forEach((point) => {
            oscillator.frequency.setValueAtTime(
              point.value,
              startTime + point.time
            );
          });

          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
          gainNode.gain.setValueAtTime(0.1, startTime + duration - 0.1);
          gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

          oscillator.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.start(startTime);
          oscillator.stop(startTime + duration);

          oscillator.onended = () => {
            isPlaying = false;
          };
        }

        resetMotionPath();
      });
    </script>
  </body>
</html>
