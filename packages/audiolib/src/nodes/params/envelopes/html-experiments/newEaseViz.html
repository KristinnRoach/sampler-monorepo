<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Ease Viz - Fixed with Path Detection</title>

    <style>
      body {
        background: #1d1d1d;
        font-family: sans-serif;
        color: #e8f5e9;
      }

      :root {
        --stroke: #ccc;
      }

      .wrapper {
        width: 100%;
        display: flex;
        align-items: center;
        flex-direction: column;
      }

      svg {
        width: clamp(360px, 60vw, 600px);
        overflow: visible;
      }

      .nav {
        width: clamp(375px, 60vw, 600px);
      }

      line {
        stroke: var(--stroke);
        opacity: 0.5;
      }

      #ease {
        stroke: #0ae448;
        stroke-width: 4;
      }

      select {
        margin: 10px 0 18px 0;
        outline: none;
        cursor: pointer;

        background-color: #eee;

        border-radius: 5px;
        padding: 10px;

        box-shadow: 5px 5px 20px rgba(0, 0, 0, 0.4);

        font-size: 16px;
        font-weight: bold;
        text-align: center;
      }

      #motionPath {
        overflow: visible;
        height: 100%;
        max-width: 100%;
      }

      #motionPath path {
        stroke-width: 2;
        stroke: gray;
      }

      #motionPath .astronaut {
        visibility: hidden;
      }

      .debug {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        font-size: 12px;
        font-family: monospace;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomEase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomWiggle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MorphSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/DrawSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomBounce.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathHelper.min.js"></script>
  </head>

  <body>
    <div class="wrapper">
      <div class="nav">
        <label for="easeSelect">Choose an Ease</label>
        <div class="select">
          <select id="easeSelect">
            <option value="linear">Linear (simple)</option>
            <option value="easeOut">Ease Out (simple)</option>
            <option value="easeInOut">Ease In-Out (simple)</option>
            <option value="bounce">Bounce (simple)</option>
            <option value="elastic">Elastic (simple)</option>
            <option value="power1">power1</option>
            <option value="power1.in">power1.in</option>
            <option value="power1.inOut">power1.inOut</option>
            <option value="power4">power4</option>
            <option value="power4.in">power4.in</option>
            <option value="power4.inOut">power4.inOut</option>
            <option value="circ">circ</option>
            <option value="circ.in">circ.in</option>
            <option value="circ.inOut">circ.inOut</option>
            <option value="back">back</option>
            <option value="bounce">bounce</option>
          </select>
        </div>
      </div>
      <div class="graph">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 500 500"
          xmlns:bx="https://boxy-svg.com"
          width="500"
          id="svg"
        >
          <path
            id="motionPath"
            d="M 0 500 L 500 0"
            fill="none"
            stroke="green"
          />

          <g id="dummy-g"></g>

          <line x1="1" y1="1" x2="1" y2="500"></line>
          <line x1="200" y1="0" x2="200" y2="500"></line>
          <line x1="250" y1="0" x2="250" y2="500"></line>
          <line x1="300" y1="0" x2="300" y2="500"></line>
          <line x1="350" y1="0" x2="350" y2="500"></line>
          <line x1="400" y1="0" x2="400" y2="500"></line>
          <line x1="450" y1="0" x2="450" y2="500"></line>
          <line x1="150" y1="0" x2="150" y2="500"></line>
          <line x1="100" y1="0" x2="100" y2="500"></line>
          <line x1="50" y1="0" x2="50" y2="500"></line>
          <line x1="499" y1="0" x2="499" y2="500"></line>

          <g
            transform="matrix(0, 1.000003576, -0.999996483, 0, -0.000004137, 0.000002552)"
            style="transform-origin: 250px 250px"
          >
            <line x1="1" y1="1" x2="1" y2="500"></line>
            <line x1="200" y1="0" x2="200" y2="500"></line>
            <line x1="250" y1="0" x2="250" y2="500"></line>
            <line x1="300" y1="0" x2="300" y2="500"></line>
            <line x1="350" y1="0" x2="350" y2="500"></line>
            <line x1="400" y1="0" x2="400" y2="500"></line>
            <line x1="450" y1="0" x2="450" y2="500"></line>
            <line x1="150" y1="0" x2="150" y2="500"></line>
            <line x1="100" y1="0" x2="100" y2="500"></line>
            <line x1="50" y1="0" x2="50" y2="500"></line>
            <line x1="499" y1="0" x2="499" y2="500"></line>
          </g>
        </svg>
      </div>
      <button id="startBtn">Start</button>
      <div class="debug" id="debugInfo">Path unchanged</div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        gsap.registerPlugin(CustomEase);
        gsap.registerPlugin(CustomWiggle);
        gsap.registerPlugin(MorphSVGPlugin);
        gsap.registerPlugin(DrawSVGPlugin);
        gsap.registerPlugin(CustomBounce);
        gsap.registerPlugin(MotionPathPlugin);

        const btnEl = document.getElementById('startBtn');
        const motionPathEl = document.getElementById('motionPath');
        const easeSelect = document.getElementById('easeSelect');
        const debugInfo = document.getElementById('debugInfo');
        const dEl = document.querySelector('#motionPath').getAttribute('d');

        let duration = 1;
        let currentEaseName = 'linear';
        let currentCustomEase = null;
        let isPathModified = false;

        // Define simple, editable custom eases with minimal control points
        const simpleEases = {
          linear: 'M0,0 L1,1',
          easeOut: 'M0,0 C0,0 0.2,1 1,1',
          easeInOut: 'M0,0 C0.4,0 0.6,1 1,1',
          bounce: 'M0,0 C0.3,0 0.3,1.4 0.5,1 C0.7,0.6 0.7,1.2 1,1',
          elastic: 'M0,0 C0.2,0 0.2,1.6 0.4,1 C0.6,0.4 0.8,1.4 1,1',
        };

        let motionTween;
        let helper;
        let svgPath = dEl;

        resetMotionPath();

        // Audio
        let audioContext;
        let oscillator;
        let filter;
        let gainNode;
        let isPlaying = false;

        // Initialize Web Audio
        function initAudio() {
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          if (audioContext.state !== 'running') audioContext.resume();
        }

        function resetMotionPath() {
          // It is necessary to use a "dummy" <g> element for MotionPathHelper to work
          motionTween = gsap.to('#dummy-g', {
            motionPath: {
              path: '#motionPath',
              align: '#motionPath',
              alignOrigin: [0.5, 0.5],
            },
          });
          helper = MotionPathHelper.create('#dummy-g');
        }

        // *** KEY FIX: Watch for path changes from MotionPathHelper ***
        let lastPathData = motionPathEl.getAttribute('d');

        // Use MutationObserver to detect path changes in real-time
        const pathObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (
              mutation.type === 'attributes' &&
              mutation.attributeName === 'd'
            ) {
              const currentPathData = motionPathEl.getAttribute('d');
              if (currentPathData !== lastPathData) {
                console.log(
                  'Path changed via MotionPathHelper:',
                  currentPathData
                );
                lastPathData = currentPathData;
                isPathModified = true;

                // Create a CustomEase from the modified path
                try {
                  // Normalize the path data for CustomEase (should be 0-1 coordinates)
                  const normalizedPath =
                    normalizePathForEasing(currentPathData);
                  currentCustomEase = CustomEase.create(
                    'pathEase',
                    normalizedPath
                  );
                  debugInfo.textContent = `Path modified! Using custom ease from SVG`;
                } catch (e) {
                  console.error('Failed to create CustomEase from path:', e);
                  debugInfo.textContent = `Path modified but couldn't create ease: ${e.message}`;
                }
              }
            }
          });
        });

        // Start observing path changes
        pathObserver.observe(motionPathEl, {
          attributes: true,
          attributeFilter: ['d'],
        });

        // Function to normalize SVG path coordinates to 0-1 range for CustomEase
        function normalizePathForEasing(pathData) {
          // Parse the path and convert coordinates to 0-1 range
          // This is a simplified approach - for complex paths you might need more robust parsing

          // Extract all coordinate pairs from the path
          const coordMatches = pathData.match(/[\d.]+/g);
          if (!coordMatches || coordMatches.length < 4) {
            throw new Error('Invalid path data');
          }

          const coords = coordMatches.map(Number);
          let minX = Math.min(...coords.filter((_, i) => i % 2 === 0));
          let maxX = Math.max(...coords.filter((_, i) => i % 2 === 0));
          let minY = Math.min(...coords.filter((_, i) => i % 2 === 1));
          let maxY = Math.max(...coords.filter((_, i) => i % 2 === 1));

          // Ensure we have a reasonable range
          if (maxX - minX === 0) maxX = minX + 1;
          if (maxY - minY === 0) maxY = minY + 1;

          // Reconstruct path with normalized coordinates
          let normalizedPath = pathData.replace(
            /[\d.]+/g,
            (match, offset, string) => {
              const index =
                string.substring(0, offset).match(/[\d.]+/g)?.length || 0;
              const isX = index % 2 === 0;
              const value = Number(match);

              if (isX) {
                return ((value - minX) / (maxX - minX)).toFixed(3);
              } else {
                // Flip Y coordinate (SVG Y increases downward, ease Y increases upward)
                return (1 - (value - minY) / (maxY - minY)).toFixed(3);
              }
            }
          );

          console.log('Normalized path:', normalizedPath);
          return normalizedPath;
        }

        easeSelect.addEventListener('change', () => {
          currentEaseName = easeSelect.value;
          isPathModified = false; // Reset to use built-in ease
          currentCustomEase = null;

          // Check if it's a simple custom ease or built-in GSAP ease
          if (simpleEases[currentEaseName]) {
            // Use our simple custom ease
            svgPath = CustomEase.getSVGData(currentEaseName, {
              width: 500,
              height: 500,
            });

            // But also set the path directly for cleaner MotionPathHelper editing
            const simplePath = simpleEases[currentEaseName]
              .replace(/([ML]?)([0-9.]+),([0-9.]+)/g, (match, cmd, x, y) => {
                const newX = parseFloat(x) * 500;
                const newY = 500 - parseFloat(y) * 500; // Flip Y for SVG coordinates
                return `${cmd || 'L'}${newX},${newY}`;
              })
              .replace(/C([0-9.,\s]+)/g, (match, coords) => {
                const numbers = coords
                  .split(/[,\s]+/)
                  .map((n) => parseFloat(n));
                const converted = [];
                for (let i = 0; i < numbers.length; i += 2) {
                  converted.push(numbers[i] * 500); // X
                  converted.push(500 - numbers[i + 1] * 500); // Y flipped
                }
                return `C${converted.join(',')}`;
              });

            console.log('Using simple custom ease:', currentEaseName);
            debugInfo.textContent = `Using simple ease: ${currentEaseName} (editable)`;

            // Set the path directly instead of morphing
            motionPathEl.setAttribute('d', simplePath);
            if (motionTween) motionTween.kill();
            if (helper) helper.kill();
            resetMotionPath();
          } else {
            // Use built-in GSAP ease (will have many points)
            svgPath = CustomEase.getSVGData(currentEaseName, {
              width: 500,
              height: 500,
            });
            console.log('Using built-in ease:', currentEaseName);
            debugInfo.textContent = `Using built-in ease: ${currentEaseName} (many points)`;

            if (motionTween) motionTween.kill();
            if (helper) helper.kill();

            motionTween = gsap.to('#motionPath', {
              morphSVG: svgPath,
              duration: 0.1,
              onComplete: () => resetMotionPath(),
            });
          }
        });

        btnEl.addEventListener('click', () => {
          initAudio();
          const now = audioContext.currentTime;

          gsap.fromTo(
            '#motionPath',
            { drawSVG: '0% 0%' },
            { duration: duration, drawSVG: '0% 100%' }
          );

          // Use the appropriate easing source
          const easingSource = isPathModified
            ? currentCustomEase
            : currentEaseName;
          playWithEasing(easingSource, now);
        });

        // *** UPDATED: Support both built-in eases and custom path-based eases ***
        function getEasingValues(
          easingSource,
          duration = 1,
          sampleRate = 1000
        ) {
          const audioValues = [];
          const timeStep = duration / sampleRate;

          let easingFunction;

          if (typeof easingSource === 'string') {
            // Built-in ease
            const dummyTween = gsap.to({}, { duration: 1, ease: easingSource });
            easingFunction = dummyTween._ease;
            dummyTween.kill();
          } else if (easingSource && typeof easingSource === 'function') {
            // Custom ease function
            easingFunction = easingSource;
          } else {
            // Fallback to linear
            easingFunction = (t) => t;
          }

          for (let i = 0; i < sampleRate; i++) {
            const time = i * timeStep;
            const normalizedTime = time / duration; // 0 to 1

            // Call the actual easing function
            const easedProgress = easingFunction(normalizedTime);

            // Convert eased progress to frequency
            const clampedProgress = Math.max(0, Math.min(1, easedProgress));
            const frequency = 200 + clampedProgress * 1000; // 200Hz to 1200Hz

            audioValues.push({
              time: time,
              value: frequency,
            });
          }

          return audioValues;
        }

        // Play audio with easing automation
        function playWithEasing(
          easingSource,
          startTime = audioContext.currentTime
        ) {
          if (isPlaying) return;

          initAudio();
          isPlaying = true;

          // Get easing values from either built-in ease or custom path ease
          const audioValues = getEasingValues(easingSource, duration);
          console.log('Audio Values (first 10):', audioValues.slice(0, 10));
          console.log(
            'Using easing source:',
            isPathModified ? 'Custom Path' : easingSource
          );

          // Create audio nodes
          oscillator = audioContext.createOscillator();
          filter = audioContext.createBiquadFilter();
          gainNode = audioContext.createGain();

          // Configure oscillator
          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(audioValues[0].value, startTime);

          // Configure filter
          filter.type = 'lowpass';
          filter.Q.setValueAtTime(1, startTime);
          filter.frequency.setValueAtTime(2000, startTime);

          // Apply the easing-based frequency automation
          audioValues.forEach((point, index) => {
            oscillator.frequency.setValueAtTime(
              point.value,
              startTime + point.time
            );
          });

          // Configure gain (volume envelope)
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
          gainNode.gain.setValueAtTime(0.1, startTime + duration - 0.1);
          gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

          // Connect the nodes
          oscillator.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(audioContext.destination);

          // Start and stop
          oscillator.start(startTime);
          oscillator.stop(startTime + duration);

          oscillator.onended = () => {
            isPlaying = false;
          };
        }

        function stopAudio() {
          if (oscillator && isPlaying) {
            oscillator.stop();
            isPlaying = false;
          }
        }
      });
    </script>
  </body>
</html>
