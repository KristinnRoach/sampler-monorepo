<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Ease Viz</title>
    <style>
      body {
        background: #1d1d1d;
        font-family: sans-serif;
        color: #e8f5e9;
        display: flex;
        align-items: center;
        flex-direction: column;
      }
      svg {
        width: clamp(360px, 60vw, 600px);
        overflow: visible;
      }
      .nav {
        width: clamp(375px, 60vw, 600px);
      }
      line {
        stroke: #ccc;
        opacity: 0.5;
      }
      select {
        margin: 10px 0 18px 0;
        outline: none;
        cursor: pointer;
        background-color: #eee;
        border-radius: 5px;
        padding: 10px;
        box-shadow: 5px 5px 20px rgba(0, 0, 0, 0.4);
        font-size: 16px;
        font-weight: bold;
        text-align: center;
      }
      .debug {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        margin: 10px 0;
        border-radius: 5px;
        font-size: 12px;
        font-family: monospace;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomEase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MorphSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/DrawSVGPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathPlugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathHelper.min.js"></script>
  </head>
  <body>
    <div class="nav">


    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500" width="500">
      <path id="motionPath" d="M 0 500 L 500 0" fill="none" stroke="green" />
      <g id="dummy-g"></g>

      <!-- Grid lines -->
      <g>
        <line x1="1" y1="1" x2="1" y2="500"></line>
        <line x1="100" y1="0" x2="100" y2="500"></line>
        <line x1="200" y1="0" x2="200" y2="500"></line>
        <line x1="300" y1="0" x2="300" y2="500"></line>
        <line x1="400" y1="0" x2="400" y2="500"></line>
        <line x1="499" y1="0" x2="499" y2="500"></line>
      </g>

      <!-- Horizontal grid -->
      <g transform="matrix(0, 1, -1, 0, 500, 0)">
        <line x1="1" y1="1" x2="1" y2="500"></line>
        <line x1="100" y1="0" x2="100" y2="500"></line>
        <line x1="200" y1="0" x2="200" y2="500"></line>
        <line x1="300" y1="0" x2="300" y2="500"></line>
        <line x1="400" y1="0" x2="400" y2="500"></line>
        <line x1="499" y1="0" x2="499" y2="500"></line>
      </g>
    </svg>

    <button id="startBtn">Start</button>
    <div class="debug" id="debugInfo">Ready</div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        gsap.registerPlugin(
          CustomEase,
          MorphSVGPlugin,
          DrawSVGPlugin,
          MotionPathPlugin
        );

        const btnEl = document.getElementById('startBtn');
        const motionPathEl = document.getElementById('motionPath');
        const debugInfo = document.getElementById('debugInfo');

        let duration = 1;
        let currentEaseName = 'linear';
        let currentCustomEase = null;
        let isPathModified = false;
        let motionTween;
        let helper;
        let audioContext;
        let isPlaying = false;

        // const simpleEases = {
        //   linear: 'M0,0 L1,1',
        //   easeOut: 'M0,0 C0,0 0.2,1 1,1',
        //   easeInOut: 'M0,0 C0.4,0 0.6,1 1,1',
        //   bounce: 'M0,0 C0.3,0 0.3,1.4 0.5,1 C0.7,0.6 0.7,1.2 1,1',
        //   elastic: 'M0,0 C0.2,0 0.2,1.6 0.4,1 C0.6,0.4 0.8,1.4 1,1',
        // };

        function resetMotionPath() {
          motionTween = gsap.to('#dummy-g', {
            motionPath: {
              path: '#motionPath',
              align: '#motionPath',
              alignOrigin: [0.5, 0.5],
            },
          });
          helper = MotionPathHelper.create('#dummy-g');
        }

        let lastPathData = motionPathEl.getAttribute('d');
        const pathObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (
              mutation.type === 'attributes' &&
              mutation.attributeName === 'd'
            ) {
              const currentPathData = motionPathEl.getAttribute('d');
              if (currentPathData !== lastPathData) {
                lastPathData = currentPathData;
                isPathModified = true;
                try {
                  const normalizedPath =
                    normalizePathForEasing(currentPathData);
                  currentCustomEase = CustomEase.create(
                    'pathEase',
                    normalizedPath
                  );
                  debugInfo.textContent = 'Using custom path ease';
                } catch (e) {
                  debugInfo.textContent = `Path error: ${e.message}`;
                }
              }
            }
          });
        });

        pathObserver.observe(motionPathEl, {
          attributes: true,
          attributeFilter: ['d'],
        });


        btnEl.addEventListener('click', () => {
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          if (audioContext.state !== 'running') audioContext.resume();

          gsap.fromTo(
            '#motionPath',
            { drawSVG: '0% 0%' },
            { duration: duration, drawSVG: '0% 100%' }
          );

          const easingSource = isPathModified
            ? currentCustomEase
            : currentEaseName;
          playWithEasing(easingSource);
        });

        function getEasingValues(
          easingSource,
          duration = 1,
          sampleRate = 1000
        ) {
          const audioValues = [];
          const timeStep = duration / sampleRate;

          let easingFunction;
          if (typeof easingSource === 'string') {
            easingFunction = gsap.parseEase(easingSource);
          } else if (easingSource && typeof easingSource === 'function') {
            easingFunction = easingSource;
          } else {
            easingFunction = (t) => t;
          }

          for (let i = 0; i < sampleRate; i++) {
            const time = i * timeStep;
            const normalizedTime = time / duration;
            const easedProgress = easingFunction(normalizedTime);
            const clampedProgress = Math.max(0, Math.min(1, easedProgress));
            const frequency = 200 + clampedProgress * 1000;

            audioValues.push({ time: time, value: frequency });
          }

          return audioValues;
        }

        function playWithEasing(easingSource) {
          if (isPlaying) return;
          isPlaying = true;

          const startTime = audioContext.currentTime;
          const audioValues = getEasingValues(easingSource, duration);

          const oscillator = audioContext.createOscillator();
          const filter = audioContext.createBiquadFilter();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sawtooth';
          oscillator.frequency.setValueAtTime(audioValues[0].value, startTime);

          filter.type = 'lowpass';
          filter.Q.setValueAtTime(1, startTime);
          filter.frequency.setValueAtTime(2000, startTime);

          audioValues.forEach((point) => {
            oscillator.frequency.setValueAtTime(
              point.value,
              startTime + point.time
            );
          });

          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.1, startTime + 0.01);
          gainNode.gain.setValueAtTime(0.1, startTime + duration - 0.1);
          gainNode.gain.linearRampToValueAtTime(0, startTime + duration);

          oscillator.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.start(startTime);
          oscillator.stop(startTime + duration);

          oscillator.onended = () => {
            isPlaying = false;
          };
        }

        resetMotionPath();
      });
    </script>
  </body>
</html>
