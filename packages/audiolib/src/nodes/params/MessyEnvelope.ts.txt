import { cancelScheduledParamValues } from '@/utils';
import { DEFAULT_AMP_ENV } from '.';

export interface EnvelopePoint {
  time: number; // 0-1 normalized
  value: number; // 0-1
  curve?: 'linear' | 'exponential'; // Curve type to next point
}

export interface EnvelopeData {
  points: EnvelopePoint[];
  loop?: boolean;
}

export interface CustomEnvelopeProps {
  audioContext: AudioContext;
  params?: AudioParam | AudioParam[];
  descriptors?: any;
  duration?: number;
  loop?: boolean;
  defaultPoints?: EnvelopePoint[];
}

export class CustomEnvelope {
  private context: AudioContext;
  private points: EnvelopePoint[] = DEFAULT_AMP_ENV;
  private loop = false;
  private envelopeDuration: number = 1.0;
  private loopType: 'restart' | 'ping-pong' = 'restart';

  private listeners: Set<() => void> = new Set();

  private notifyChange() {
    this.listeners.forEach((listener) => listener());
  }

  get sustainIdx() {
    return this.points.length - 2;
  }

  get releaseStartIdx() {
    return this.points.length - 2;
  }

  get duration() {
    return this.envelopeDuration;
  }

  set duration(value: number) {
    this.envelopeDuration = Math.max(0.001, value);
    this.notifyChange();
  }

  get loopMode() {
    return this.loopType;
  }

  setLoopMode(mode: 'restart' | 'ping-pong') {
    this.loopType = mode;
    this.notifyChange();
  }

  constructor(options: CustomEnvelopeProps) {
    this.context = options.audioContext;
    // todo: add setDuration ? const { params, descriptors, duration = 1, loop = false } = options;
    //
  }

  // Public method for UI to subscribe
  onChange(callback: () => void): () => void {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback); // Returns unsubscribe fn
  }

  getEnvelopeData(): EnvelopeData {
    return {
      points: this.points,
      loop: this.loop,
    };
  }

  addPoint(
    time: number,
    value: number,
    curve: 'linear' | 'exponential' = 'linear'
  ) {
    const insertIndex = this.points.findIndex((p) => p.time > time);
    const newPoint = { time, value, curve };

    if (insertIndex === -1) {
      this.points.push(newPoint);
    } else {
      this.points.splice(insertIndex, 0, newPoint);
    }

    this.notifyChange();
  }

  updatePoint(index: number, time: number, value: number) {
    if (index >= 0 && index < this.points.length) {
      if (index === 0) {
        this.points[index] = { ...this.points[index], value };
      } else if (index === this.points.length - 1) {
        this.points[index] = { ...this.points[index], value };
      } else {
        this.points[index] = { ...this.points[index], time, value };
      }

      this.notifyChange();
    }
  }

  deletePoint(index: number) {
    if (index > 0 && index < this.points.length - 1) {
      this.points.splice(index, 1);
      this.notifyChange();
    }
  }

  getPoints(): EnvelopePoint[] {
    return [...this.points];
  }

  setPoints(points: EnvelopePoint[]) {
    if (points.length < 2) {
      console.warn('Envelope requires at least two points. Using default.');
      this.points = DEFAULT_AMP_ENV;
    } else {
      // Sort points by time
      this.points = [...points].sort((a, b) => a.time - b.time);
    }

    this.notifyChange();
    return this;
  }

  getValueAtTime(normalizedTime: number): number {
    return this.interpolateValueAtTime(normalizedTime);
  }

  // Web Audio scheduling

  SAFE_SCHEDULE_CURRTIME_ADD = 0.003;
  private scheduledUntil: number = 0;

  private scheduleTimer: number | null = null;

  private isLooping = false;
  private loopTimer: number | null = null;

  // Add this method to stop looping (call this from SampleVoice.release):
  stopLooping() {
    this.isLooping = false;
    if (this.loopTimer) {
      clearTimeout(this.loopTimer);
      this.loopTimer = null;
    }
  }

  // applyToAudioParam(audioParam: AudioParam, startTime: number, loop = false) {
  //   console.log(
  //     `ENV: Applying envelope, duration=${this.envelopeDuration}s, loop=${loop}`
  //   );

  //   const safeStartTime = startTime + this.SAFE_SCHEDULE_CURRTIME_ADD;

  //   cancelScheduledParamValues(audioParam, startTime);

  //   // Start from the first envelope point
  //   audioParam.setValueAtTime(this.interpolateValueAtTime(0), safeStartTime);

  //   const sampleRate = 1000;
  //   const numSamples = Math.max(
  //     2,
  //     Math.floor(this.envelopeDuration * sampleRate)
  //   );
  //   const curve = new Float32Array(numSamples);

  //   for (let i = 0; i < numSamples; i++) {
  //     const normalizedTime = i / (numSamples - 1);
  //     curve[i] = this.interpolateValueAtTime(normalizedTime);
  //   }

  //   audioParam.setValueCurveAtTime(curve, safeStartTime, this.envelopeDuration);

  //   // KEY FIX: Reset to the starting value at the end of each cycle
  //   // This ensures the next loop starts from the beginning again
  //   audioParam.setValueAtTime(
  //     this.interpolateValueAtTime(0),
  //     safeStartTime + this.envelopeDuration
  //   );
  // }

  applyToAudioParam(audioParam: AudioParam, startTime: number, loop = true) {
    // console.log('First value:', this.interpolateValueAtTime(0));
    // console.log('Last value:', this.interpolateValueAtTime(1));
    const safeStartTime = startTime + this.SAFE_SCHEDULE_CURRTIME_ADD;

    cancelScheduledParamValues(audioParam, startTime);
    audioParam.setValueAtTime(this.interpolateValueAtTime(0), safeStartTime);

    if (!loop) {
      // Original non-looping behavior
      const sampleRate = 1000;
      const numSamples = Math.max(
        2,
        Math.floor(this.envelopeDuration * sampleRate)
      );
      const curve = new Float32Array(numSamples);

      for (let i = 0; i < numSamples; i++) {
        const normalizedTime = i / (numSamples - 1);
        const value = this.interpolateValueAtTime(normalizedTime);

        if (i === 0) {
          curve[i] = 0;
        } else if (i === numSamples - 1) {
          curve[i] = 0;
        } else {
          curve[i] = value;
        }
      }

      // SIMPLE LOOP: Schedule 10 cycles immediately
      for (let i = 0; i < 10; i++) {
        const cycleStart = safeStartTime + i * this.envelopeDuration;
        const curve = this.generateSingleCycleCurve(
          i,
          this.envelopeDuration,
          0
        );
        // audioParam.setValueCurveAtTime(
        //   curve,
        //   cycleStart,
        //   this.envelopeDuration
        // );
      }

      audioParam.setValueCurveAtTime(
        curve,
        safeStartTime,
        this.envelopeDuration
      );
      return;
    }

    this.isLooping = true;
    if (this.loopTimer) {
      clearTimeout(this.loopTimer);
    }

    // Apply first cycle
    const curve = this.generateSingleCycleCurve(0, this.envelopeDuration, 0);
    audioParam.setValueCurveAtTime(curve, safeStartTime, this.envelopeDuration);

    // Schedule continuous looping
    const scheduleNextCycle = (cycleNumber: number) => {
      if (!this.isLooping) return;

      this.loopTimer = setTimeout(
        () => {
          // Double-check we're still looping
          if (!this.isLooping) return;

          const nextStartTime = this.context.currentTime + 0.003;
          audioParam.setValueAtTime(
            this.interpolateValueAtTime(0),
            nextStartTime
          );

          const nextCurve = this.generateSingleCycleCurve(
            cycleNumber,
            this.envelopeDuration,
            0
          );
          audioParam.setValueCurveAtTime(
            nextCurve,
            nextStartTime,
            this.envelopeDuration
          );

          scheduleNextCycle(cycleNumber + 1);
        },
        this.envelopeDuration * 1000 - 50
      );
    };

    // Start the continuous loop
    scheduleNextCycle(1);
  }

  private scheduleEnvelopeCycles(
    audioParam: AudioParam,
    fromTime: number,
    minValue: number
  ) {
    const cyclesToSchedule = 3; // Small buffer
    const cycleDuration = this.envelopeDuration;

    for (let i = 0; i < cyclesToSchedule; i++) {
      const cycleStartTime = this.scheduledUntil + i * cycleDuration;
      const actualDuration = cycleDuration - 0.001; // Prevent overlap

      // Set starting value for seamless transition
      if (i === 0) {
        audioParam.setValueAtTime(
          this.interpolateValueAtTime(0),
          cycleStartTime
        );
      }

      const curve = this.generateSingleCycleCurve(i, actualDuration, minValue);
      audioParam.setValueCurveAtTime(curve, cycleStartTime, actualDuration);
    }

    this.scheduledUntil += cyclesToSchedule * cycleDuration;

    // Schedule next batch before current one ends
    const rescheduleTime = (cyclesToSchedule - 1) * cycleDuration * 1000; // Convert to ms
    this.scheduleTimer = setTimeout(() => {
      this.scheduleEnvelopeCycles(audioParam, this.scheduledUntil, minValue);
    }, rescheduleTime);
  }

  private generateSingleCycleCurve(
    cycleNumber: number,
    duration: number,
    minValue: number
  ): Float32Array {
    const sampleRate = 1000;
    const numSamples = Math.max(2, Math.floor(duration * sampleRate));
    const curve = new Float32Array(numSamples);

    for (let i = 0; i < numSamples; i++) {
      const cyclePosition = i / (numSamples - 1); // 0 to 1 within this cycle

      let normalizedTime;
      if (this.loopMode === 'ping-pong') {
        // Ping-pong: reverse direction on odd cycles
        const isReverse = cycleNumber % 2 === 1;
        normalizedTime = isReverse ? 1 - cyclePosition : cyclePosition;
      } else {
        // Restart: always 0â†’1
        normalizedTime = cyclePosition;
      }

      const value = this.interpolateValueAtTime(normalizedTime);
      curve[i] = Math.max(value, minValue);
    }

    return curve;
  }

  /**
   * Applies the release portion of the envelope to an AudioParam.
   * This assumes the envelope should decay from its current value to 0 over the releaseDuration.
   * It finds the effective starting point for the release within the envelope's definition.
   * @param audioParam The AudioParam to schedule.
   * @param releaseStartTime The Web Audio API timestamp to start the release.
   * @param releaseDuration The duration of the release phase.
   * @param currentValue The actual current value of the audioParam at releaseStartTime.
   * @param targetValue The value the envelope should reach at the end of the release. (Usually 0 or minValue)
   * @param minValue A minimum value to ensure no complete silence (avoids denormals).
   */
  applyReleaseToAudioParam(
    audioParam: AudioParam,
    releaseStartTime: number,
    releaseDuration: number,
    currentValue: number,
    targetValue: number = 0.00001,
    minValue: number = 0.00001
  ) {
    cancelScheduledParamValues(audioParam, releaseStartTime);
    audioParam.setValueAtTime(audioParam.value, releaseStartTime);

    // Determine the curve type for the *last segment* of the envelope
    const effectiveCurveType =
      this.points.length > 1
        ? this.points[this.points.length - 2]?.curve || 'linear'
        : 'linear';

    switch (effectiveCurveType) {
      case 'exponential':
        // Exponential ramp requires start and end to be > 0.
        if (currentValue > minValue && targetValue > 0) {
          audioParam.exponentialRampToValueAtTime(
            targetValue,
            releaseStartTime + releaseDuration
          );
        } else {
          audioParam.linearRampToValueAtTime(
            targetValue,
            releaseStartTime + releaseDuration
          );
        }
        break;
      case 'linear':
      default:
        audioParam.linearRampToValueAtTime(
          targetValue,
          releaseStartTime + releaseDuration
        );
        break;
    }
  }

  private interpolateValueAtTime(normalizedTime: number): number {
    const sortedPoints = [...this.points].sort((a, b) => a.time - b.time);

    if (sortedPoints.length === 0) return 0;
    if (sortedPoints.length === 1) return sortedPoints[0].value;

    // Handle time outside bounds
    if (normalizedTime <= sortedPoints[0].time) {
      return sortedPoints[0].value;
    }
    if (normalizedTime >= sortedPoints[sortedPoints.length - 1].time) {
      return sortedPoints[sortedPoints.length - 1].value;
    }

    // Find surrounding points
    let leftIndex = 0;
    let rightIndex = sortedPoints.length - 1;

    for (let i = 0; i < sortedPoints.length - 1; i++) {
      if (
        normalizedTime >= sortedPoints[i].time &&
        normalizedTime <= sortedPoints[i + 1].time
      ) {
        leftIndex = i;
        rightIndex = i + 1;
        break;
      }
    }

    const leftPoint = sortedPoints[leftIndex];
    const rightPoint = sortedPoints[rightIndex];

    if (leftIndex === rightIndex) {
      return leftPoint.value;
    }

    // Calculate interpolation factor
    const segmentDuration = rightPoint.time - leftPoint.time;
    const t =
      segmentDuration === 0
        ? 0
        : (normalizedTime - leftPoint.time) / segmentDuration;

    // Apply curve type
    switch (leftPoint.curve) {
      case 'exponential':
        if (leftPoint.value > 0 && rightPoint.value > 0) {
          // Exponential interpolation: start * (end/start)^t
          return (
            leftPoint.value * Math.pow(rightPoint.value / leftPoint.value, t)
          );
        }
        // Fallback to linear if values are problematic
        return leftPoint.value + (rightPoint.value - leftPoint.value) * t;

      case 'linear':
      default:
        // Linear interpolation
        return leftPoint.value + (rightPoint.value - leftPoint.value) * t;
    }
  }

  getSVGPath(width: number = 400, height: number = 200): string {
    if (this.points.length < 2) return `M0,${height} L${width},${height}`;

    const sortedPoints = [...this.points].sort((a, b) => a.time - b.time);
    let path = `M${sortedPoints[0].time * width},${(1 - sortedPoints[0].value) * height}`;

    for (let i = 1; i < sortedPoints.length; i++) {
      const point = sortedPoints[i];
      const prevPoint = sortedPoints[i - 1];

      const x = point.time * width;
      const y = (1 - point.value) * height;

      if (prevPoint.curve === 'exponential') {
        const prevX = prevPoint.time * width;
        const prevY = (1 - prevPoint.value) * height;
        const cp1X = prevX + (x - prevX) * 0.3;
        const cp1Y = prevY;
        const cp2X = prevX + (x - prevX) * 0.7;
        const cp2Y = y;

        path += ` C${cp1X},${cp1Y} ${cp2X},${cp2Y} ${x},${y}`;
      } else {
        path += ` L${x},${y}`;
      }
    }

    return path;
  }

  loadPreset(preset: 'adsr' | 'pluck' | 'pad' | 'organ') {
    const presets = {
      adsr: [
        { time: 0, value: 0, curve: 'linear' as const },
        { time: 0.2, value: 1, curve: 'exponential' as const },
        { time: 0.4, value: 0.7, curve: 'linear' as const },
        { time: 0.8, value: 0.7, curve: 'exponential' as const },
        { time: 1, value: 0, curve: 'linear' as const },
      ],
      pluck: [
        { time: 0, value: 0, curve: 'linear' as const },
        { time: 0.05, value: 1, curve: 'exponential' as const },
        { time: 1, value: 0, curve: 'exponential' as const },
      ],
      pad: [
        { time: 0, value: 0, curve: 'exponential' as const },
        { time: 0.6, value: 1, curve: 'linear' as const },
        { time: 0.8, value: 0.8, curve: 'exponential' as const },
        { time: 1, value: 0, curve: 'exponential' as const },
      ],
      organ: [
        { time: 0, value: 0, curve: 'linear' as const },
        { time: 0.1, value: 1, curve: 'linear' as const },
        { time: 0.9, value: 1, curve: 'linear' as const },
        { time: 1, value: 0, curve: 'linear' as const },
      ],
    };

    this.points = presets[preset];
    this.notifyChange();
  }
}

export const createCustomEnvelope = (options: CustomEnvelopeProps) => {
  return new CustomEnvelope(options);
};

//   applyEnvelopeToParam(audioParam: AudioParam, envelopeData, duration) {
//   const curve = envelopeData.loop
//     ? this.generateLoopedCurve(envelopeData.points, duration)
//     : this.generateCurveFromPoints(envelopeData.points, duration);

//   audioParam.setValueCurveAtTime(curve, this.context.currentTime, duration);
// }

// generateLoopedCurve(points, totalDuration) {
//   const sampleRate = 1000;
//   const totalSamples = Math.floor(totalDuration * sampleRate);

//   // Generate one cycle of the envelope
//   const cycleLength = 500; // 0.5 seconds per cycle (adjust as needed)
//   const oneCycle = new Float32Array(cycleLength);

//   for (let i = 0; i < cycleLength; i++) {
//     const normalizedTime = i / (cycleLength - 1);
//     oneCycle[i] = this.interpolateValueAtTime(points, normalizedTime);
//   }

//   // Repeat the cycle to fill total duration
//   const curve = new Float32Array(totalSamples);
//   for (let i = 0; i < totalSamples; i++) {
//     curve[i] = oneCycle[i % cycleLength];
//   }

//   return curve;
// }

/**
 * Applies envelope with sustain behavior - plays until second-to-last point, then sustains
 * @param audioParam The AudioParam to control
 * @param startTime When to start the envelope
 * @param duration Total duration to play envelope points (minus sustain)
 * @param minValue Minimum value to prevent denormals
 * @returns Object with sustainValue and methods to handle release
 */

// applyWithSustain(
//   audioParam: AudioParam,
//   startTime: number,
//   duration: number,
//   minValue: number = 0.001
// ): {
//   sustainValue: number;
//   release: (releaseStartTime: number) => void;
// } {
//   if (this.points.length < 2) {
//     console.warn('Envelope needs at least 2 points for sustain behavior');
//     return {
//       sustainValue: this.points[0]?.value || 0,
//       release: () => {},
//     };
//   }

//   cancelScheduledParamValues(audioParam, startTime);

//   // Get sustain point (second-to-last) and final point
//   const sustainPoint = this.points[this.points.length - 2];
//   const finalPoint = this.points[this.points.length - 1];

//   // Create envelope curve up to (and including) sustain point
//   const sustainPoints = this.points.slice(0, -1); // All points except the last

//   // Calculate duration to reach sustain point
//   const sustainDuration = duration * sustainPoint.time;

//   if (sustainDuration > 0) {
//     // Generate curve for attack + decay phases (up to sustain)
//     const sampleRate = 1000; // 1000 samples per second
//     const numSamples = Math.max(2, Math.floor(sustainDuration * sampleRate));
//     const curve = new Float32Array(numSamples);

//     // Fill curve up to sustain point
//     for (let i = 0; i < numSamples; i++) {
//       // Normalize time to sustain point (0 to sustainPoint.time)
//       const normalizedTime = (i / (numSamples - 1)) * sustainPoint.time;
//       const value = this.interpolateValueAtTime(normalizedTime);
//       curve[i] = Math.max(value, minValue);
//     }

//     // Apply the curve up to sustain
//     audioParam.setValueAtTime(curve[0], startTime);
//     audioParam.setValueCurveAtTime(curve, startTime, sustainDuration);

//     // Hold at sustain value indefinitely
//     audioParam.setValueAtTime(
//       sustainPoint.value,
//       startTime + sustainDuration
//     );
//   } else {
//     // If no duration to sustain point, jump directly to sustain value
//     audioParam.setValueAtTime(sustainPoint.value, startTime);
//   }

//   return {
//     sustainValue: sustainPoint.value,
//     release: (releaseStartTime: number) => {
//       // Calculate release duration from envelope
//       const releaseDuration = duration * (1 - sustainPoint.time);

//       if (releaseDuration > 0) {
//         // Apply release curve from sustain to final point
//         this.applyReleaseCurve(
//           audioParam,
//           releaseStartTime,
//           releaseDuration,
//           sustainPoint.value,
//           finalPoint.value,
//           sustainPoint.curve || 'linear'
//         );
//       } else {
//         // Immediate jump to final value if no release duration
//         audioParam.setValueAtTime(finalPoint.value, releaseStartTime);
//       }
//     },
//   };
// }

// /**
//  * Helper method to apply release curve
//  */
// private applyReleaseCurve(
//   audioParam: AudioParam,
//   startTime: number,
//   duration: number,
//   startValue: number,
//   endValue: number,
//   curveType: 'linear' | 'exponential'
// ): void {
//   cancelScheduledParamValues(audioParam, startTime);
//   audioParam.setValueAtTime(startValue, startTime);

//   switch (curveType) {
//     case 'exponential':
//       if (startValue > 0.001 && endValue > 0.001) {
//         audioParam.exponentialRampToValueAtTime(
//           endValue,
//           startTime + duration
//         );
//       } else {
//         // Fallback to linear if values are problematic for exponential
//         audioParam.linearRampToValueAtTime(endValue, startTime + duration);
//       }
//       break;
//     case 'linear':
//     default:
//       audioParam.linearRampToValueAtTime(endValue, startTime + duration);
//       break;
//   }
// }

// applyToAudioParam(
//   audioParam: AudioParam,
//   startTime: number,
//   // samplePlaybackDuration: number,
//   minValue: number = 0.001,
//   loop = true
// ) {
//   const safeStartTime = startTime + this.SAFE_SCHEDULE_CURRTIME_ADD;

//   cancelScheduledParamValues(audioParam, startTime);

//   // Set inital value for first cycle
//   audioParam.setValueAtTime(this.interpolateValueAtTime(0), safeStartTime);

//   if (!loop) {
//     // Original non-looping behavior
//     const envSamplingRate = 1000;
//     const numSamples = Math.max(
//       2,
//       Math.floor(this.envelopeDuration * envSamplingRate)
//     );

//     const curve = new Float32Array(numSamples);

//     for (let i = 0; i < numSamples; i++) {
//       const normalizedTime = i / (numSamples - 1);
//       const value = this.interpolateValueAtTime(normalizedTime);
//       curve[i] = Math.max(value, minValue);
//     }

//     audioParam.setValueCurveAtTime(
//       curve,
//       safeStartTime,
//       this.envelopeDuration
//     );

//     setTimeout(() => {

//     })
//     return;
//   }

//   // SIMPLEST POSSIBLE: Just schedule 2 cycles manually
//   const cycleDuration = this.envelopeDuration + 0.001;
//   // const safeStartTime = startTime + this.SAFE_SCHEDULE_CURRTIME_ADD;

//   // Cycle 1
//   const curve1 = this.generateSingleCycleCurve(
//     0,
//     cycleDuration, //  + 0.001,
//     minValue
//   );
//   audioParam.setValueAtTime(this.interpolateValueAtTime(0), safeStartTime);
//   audioParam.setValueCurveAtTime(
//     curve1,
//     safeStartTime,
//     cycleDuration //  - 0.001
//   );

//   // Cycle 2
//   const cycle2Start = safeStartTime + cycleDuration;
//   const curve2 = this.generateSingleCycleCurve(
//     1,
//     cycleDuration, // - 0.001,
//     minValue
//   );
//   audioParam.setValueAtTime(this.interpolateValueAtTime(0), cycle2Start);
//   audioParam.setValueCurveAtTime(curve2, cycle2Start, cycleDuration); // - 0.001);
// }

//   //   // For looping: schedule multiple cycles
//   //   const cycleDuration = this.envelopeDuration;
//   //   const numCycles = Math.ceil(samplePlaybackDuration / cycleDuration);

//   //   const maxCycles = 5;

//   //   for (let cycle = 0; cycle < maxCycles; cycle++) {
//   //     const cycleStartTime = safeStartTime + cycle * cycleDuration;
//   //     const nextCycleStartTime = safeStartTime + (cycle + 1) * cycleDuration;
//   //     const actualDuration = nextCycleStartTime - cycleStartTime - 0.001; // Small gap

//   //     const curve = this.generateSingleCycleCurve(
//   //       cycle,
//   //       actualDuration,
//   //       minValue
//   //     );
//   //     audioParam.setValueCurveAtTime(curve, cycleStartTime, actualDuration);
//   //   }
//   // }

//   //   // Start looping schedule
//   //   this.scheduledUntil = safeStartTime;
//   //   this.scheduleEnvelopeCycles(audioParam, safeStartTime, minValue);
//   // }

// private generateSingleCycleCurve(
//   cycleNumber: number,
//   duration: number,
//   minValue: number
// ): Float32Array {
//   const sampleRate = 1000;
//   const numSamples = Math.max(2, Math.floor(duration * sampleRate));
//   const curve = new Float32Array(numSamples);

//   // Force first sample to always be the envelope start value
//   const startValue = this.interpolateValueAtTime(0);
//   curve[0] = Math.max(startValue, minValue);

//   for (let i = 1; i < numSamples; i++) {
//     // Start from i=1
//     const cyclePosition = i / (numSamples - 1);

//     let normalizedTime;
//     if (this.loopMode === 'ping-pong') {
//       const isReverse = cycleNumber % 2 === 1;
//       normalizedTime = isReverse ? 1 - cyclePosition : cyclePosition;
//     } else {
//       normalizedTime = cyclePosition;
//     }

//     const value = this.interpolateValueAtTime(normalizedTime);
//     curve[i] = Math.max(value, minValue);
//   }

//   return curve;
// }

// applyToAudioParam(
//   audioParam: AudioParam,
//   startTime: number,
//   loop = true
//   // minValue: number = 0.001,
// ) {
//   console.log('First value:', this.interpolateValueAtTime(0));
//   console.log('Last value:', this.interpolateValueAtTime(1));

//   const safeStartTime = startTime + this.SAFE_SCHEDULE_CURRTIME_ADD;

//   cancelScheduledParamValues(audioParam, startTime);
//   audioParam.setValueAtTime(this.interpolateValueAtTime(0), safeStartTime);

//   if (!loop) {
//     // Original non-looping behavior
//     const sampleRate = 1000;
//     const numSamples = Math.max(
//       2,
//       Math.floor(this.envelopeDuration * sampleRate)
//     );
//     const curve = new Float32Array(numSamples);

//     for (let i = 0; i < numSamples; i++) {
//       const normalizedTime = i / (numSamples - 1);
//       const value = this.interpolateValueAtTime(normalizedTime);
//       // Force first and last samples to exact values for seamless looping
//       if (i === 0) {
//         curve[i] = 0; // Always start at 0
//       } else if (i === numSamples - 1) {
//         curve[i] = 0; // Always end at 0
//       } else {
//         curve[i] = value;
//       }
//     }

//     audioParam.setValueCurveAtTime(
//       curve,
//       safeStartTime,
//       this.envelopeDuration
//     );
//     return;
//   }

//   // Apply first cycle
//   const curve = this.generateSingleCycleCurve(0, this.envelopeDuration, 0);
//   audioParam.setValueCurveAtTime(curve, safeStartTime, this.envelopeDuration);

//   // Schedule next cycle via setTimeout
//   const scheduleNextCycle = (cycleNumber: number) => {
//     setTimeout(
//       () => {
//         const nextStartTime = this.context.currentTime + 0.003;
//         audioParam.setValueAtTime(
//           this.interpolateValueAtTime(0),
//           nextStartTime
//         );

//         const nextCurve = this.generateSingleCycleCurve(
//           cycleNumber,
//           this.envelopeDuration,
//           0
//         );
//         audioParam.setValueCurveAtTime(
//           nextCurve,
//           nextStartTime,
//           this.envelopeDuration
//         );

//         // Schedule the cycle after this one
//         scheduleNextCycle(cycleNumber + 1);
//       },
//       this.envelopeDuration * 1000 - 50
//     ); // 50ms early to avoid gaps
//   };

//   // Start the cycle
//   scheduleNextCycle(1);
// }
