<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loop Worklet Test</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }
      .controls {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      button {
        padding: 8px 16px;
        margin: 0 10px 10px 0;
        cursor: pointer;
      }
      .slider-container {
        margin: 10px 0;
      }
      .status {
        margin-top: 20px;
        padding: 10px;
        background-color: #f0f0f0;
        border-radius: 5px;
      }
      .waveform {
        width: 100%;
        height: 150px;
        background: #eee;
        margin-top: 20px;
        position: relative;
      }
      .loop-region {
        position: absolute;
        height: 100%;
        background: rgba(0, 128, 255, 0.3);
        top: 0;
      }
    </style>
  </head>
  <body>
    <h1>Loop Worklet Test</h1>

    <div class="controls">
      <button id="loadSound">Load Sound</button>
      <button id="playSound" disabled>Play</button>
      <button id="stopSound" disabled>Stop</button>

      <div class="slider-container">
        <label for="loopStart">Loop Start:</label>
        <input
          type="range"
          id="loopStart"
          min="0"
          max="1"
          value="0"
          step="0.01"
          disabled
        />
        <span id="loopStartValue">0.00s</span>
      </div>

      <div class="slider-container">
        <label for="loopEnd">Loop End:</label>
        <input
          type="range"
          id="loopEnd"
          min="0"
          max="1"
          value="1"
          step="0.01"
          disabled
        />
        <span id="loopEndValue">0.00s</span>
      </div>

      <div class="slider-container">
        <label for="interpolation">Interpolation Speed:</label>
        <input
          type="range"
          id="interpolation"
          min="0.001"
          max="1"
          value="0.05"
          step="0.001"
          disabled
        />
        <span id="interpolationValue">0.050</span>
      </div>
    </div>

    <div class="waveform" id="waveform">
      <div class="loop-region" id="loopRegion"></div>
    </div>

    <div class="status" id="status">Status: Ready to load sound</div>

    <script type="module">
      import { TestWorkletManager } from './TestWorkletManager.js';
      import { TestLoopWorkletNode } from './TestLoopWorkletNode.js';

      let audioContext = null;
      let sourceNode = null;
      let loopWorklet = null;
      let audioBuffer = null;
      let duration = 0;

      const manager = new TestWorkletManager();

      // UI Elements
      const loadButton = document.getElementById('loadSound');
      const playButton = document.getElementById('playSound');
      const stopButton = document.getElementById('stopSound');
      const loopStartSlider = document.getElementById('loopStart');
      const loopEndSlider = document.getElementById('loopEnd');
      const interpolationSlider = document.getElementById('interpolation');
      const loopStartValue = document.getElementById('loopStartValue');
      const loopEndValue = document.getElementById('loopEndValue');
      const interpolationValue = document.getElementById('interpolationValue');
      const statusDisplay = document.getElementById('status');
      const loopRegion = document.getElementById('loopRegion');

      // Status logging helper
      function logStatus(message) {
        statusDisplay.textContent = 'Status: ' + message;
        console.log(message);
      }

      // Update loop visualization
      function updateLoopVisualization() {
        const startPercent =
          (parseFloat(loopStartSlider.value) / duration) * 100;
        const endPercent = (parseFloat(loopEndSlider.value) / duration) * 100;

        loopRegion.style.left = startPercent + '%';
        loopRegion.style.width = endPercent - startPercent + '%';
      }

      // Load a sample sound
      async function loadSampleSound() {
        try {
          // Create audio context if not already created
          if (!audioContext) {
            audioContext = new AudioContext();
          }

          // Load a sample sound (replace with your own URL)
          const response = await fetch(
            'https://actions.google.com/sounds/v1/alarms/digital_watch_alarm_long.ogg'
          );
          const arrayBuffer = await response.arrayBuffer();
          audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          duration = audioBuffer.duration;

          // Update UI
          loopStartSlider.max = duration;
          loopEndSlider.max = duration;
          loopEndSlider.value = duration;
          loopEndValue.textContent = duration.toFixed(2) + 's';

          // Enable controls
          playButton.disabled = false;
          loopStartSlider.disabled = false;
          loopEndSlider.disabled = false;
          interpolationSlider.disabled = false;

          updateLoopVisualization();

          logStatus(`Sound loaded: ${duration.toFixed(2)} seconds`);
        } catch (error) {
          logStatus('Error loading sound: ' + error.message);
          console.error(error);
        }
      }

      // Create source node and loop worklet
      async function setupAudio() {
        if (!audioBuffer) return;

        try {
          // Create source node
          sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.loop = true;

          // Set initial loop points
          sourceNode.loopStart = parseFloat(loopStartSlider.value);
          sourceNode.loopEnd = parseFloat(loopEndSlider.value);

          // Create loop worklet if not already created
          if (!loopWorklet) {
            loopWorklet = await TestLoopWorkletNode.create(
              audioContext,
              manager
            );

            // Add message handling for logging
            const originalOnMessage = loopWorklet.port.onmessage;
            loopWorklet.port.onmessage = (event) => {
              if (event.data.type === 'update') {
                // Only log every 30 updates to avoid flooding console
                if (Math.random() < 0.03) {
                  console.log(
                    `Loop updated: ${event.data.loopStart.toFixed(2)}s - ${event.data.loopEnd.toFixed(2)}s`
                  );
                }
              }
              // Call original handler
              if (originalOnMessage) originalOnMessage(event);
            };
          }

          // Connect the worklet to the source
          loopWorklet.connectToSource(sourceNode);

          // Connect source to output
          sourceNode.connect(audioContext.destination);

          // Update parameters
          loopWorklet.setLoopStart(parseFloat(loopStartSlider.value));
          loopWorklet.setLoopEnd(parseFloat(loopEndSlider.value));
          loopWorklet.setInterpolationSpeed(
            parseFloat(interpolationSlider.value)
          );

          return true;
        } catch (error) {
          logStatus('Error setting up audio: ' + error.message);
          console.error(error);
          return false;
        }
      }

      // Play the sound
      async function playSound() {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        if (sourceNode && sourceNode.context.state === 'running') {
          // Already playing
          return;
        }

        if (await setupAudio()) {
          sourceNode.start();
          playButton.disabled = true;
          stopButton.disabled = false;
          logStatus('Playing sound');
        }
      }

      // Stop the sound
      function stopSound() {
        if (sourceNode) {
          sourceNode.stop();
          sourceNode = null;
          playButton.disabled = false;
          stopButton.disabled = true;
          logStatus('Stopped sound');
        }
      }

      // Event Listeners
      loadButton.addEventListener('click', loadSampleSound);
      playButton.addEventListener('click', playSound);
      stopButton.addEventListener('click', stopSound);

      loopStartSlider.addEventListener('input', () => {
        const value = parseFloat(loopStartSlider.value);
        loopStartValue.textContent = value.toFixed(2) + 's';

        // Ensure loop start doesn't exceed loop end
        if (value >= parseFloat(loopEndSlider.value)) {
          loopStartSlider.value = parseFloat(loopEndSlider.value) - 0.01;
        }

        if (loopWorklet) {
          loopWorklet.setLoopStart(parseFloat(loopStartSlider.value));
        }

        updateLoopVisualization();
      });

      loopEndSlider.addEventListener('input', () => {
        const value = parseFloat(loopEndSlider.value);
        loopEndValue.textContent = value.toFixed(2) + 's';

        // Ensure loop end doesn't go below loop start
        if (value <= parseFloat(loopStartSlider.value)) {
          loopEndSlider.value = parseFloat(loopStartSlider.value) + 0.01;
        }

        if (loopWorklet) {
          loopWorklet.setLoopEnd(parseFloat(loopEndSlider.value));
        }

        updateLoopVisualization();
      });

      interpolationSlider.addEventListener('input', () => {
        const value = parseFloat(interpolationSlider.value);
        interpolationValue.textContent = value.toFixed(3);

        if (loopWorklet) {
          loopWorklet.setInterpolationSpeed(value);
        }
      });

      // Initial status
      logStatus('Ready - Click "Load Sound" to begin');
    </script>
  </body>
</html>
